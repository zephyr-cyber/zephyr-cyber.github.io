<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChaunceyZhang&amp;Xia</title>
  
  
  <link href="http://zephyr-cyber.github.io/atom.xml" rel="self"/>
  
  <link href="http://zephyr-cyber.github.io/"/>
  <updated>2022-12-12T08:40:05.446Z</updated>
  <id>http://zephyr-cyber.github.io/</id>
  
  <author>
    <name>ChaunceyZhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html</id>
    <published>2022-12-12T09:43:46.000Z</published>
    <updated>2022-12-12T08:40:05.446Z</updated>
    
    <content type="html"><![CDATA[<p><a name="BB9gb"></a></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a name="XmLxR"></a></p><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><p><a name="yOnLQ"></a></p><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：<br />同步通讯：就像打电话，需要实时响应。<br />异步通讯：就像发邮件，不需要马上回复。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786612-bfe09fbc-30b0-4ba5-910b-97900e8beb5b.png#averageHue=%23578994&crop=0&crop=0&crop=1&crop=1&id=YHjCb&originHeight=605&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<br><a name="jd0te"></a></p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>之前学的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786722-2f92b8d1-d782-4fcb-84d7-9fb639ee530a.png#averageHue=%23faf7f7&crop=0&crop=0&crop=1&crop=1&id=CFRUo&originHeight=678&originWidth=1556&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />总结：<br />同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li><p>耦合度高</p></li><li><p>性能和吞吐能力下降</p></li><li><p>有额外的资源消耗</p></li><li><p>有级联失败问题<br><a name="deD2y"></a></p><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：<br />我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br />在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。<br />订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。<br />为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786818-ba19cdaf-61ca-42b6-a40b-4eb4fd29e8de.png#averageHue=%23e6d6cc&crop=0&crop=0&crop=1&crop=1&id=f2pma&originHeight=134&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。<br />好处：</p></li><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。<br><a name="W2lsn"></a></p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br />比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br />追求可靠性：RabbitMQ、RocketMQ<br />追求吞吐能力：RocketMQ、Kafka<br />追求消息低延迟：RabbitMQ、Kafka<br><a name="v1IoI"></a></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h1><p><a name="bjPW9"></a></p><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786900-d1c5001a-d83f-4982-9a78-1c0961aba74a.png#averageHue=%23fbf9f7&crop=0&crop=0&crop=1&crop=1&id=QLlPG&originHeight=138&originWidth=318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />MQ的基本结构：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786980-394cb4b6-1a99-45ee-850b-ae9b4ba24d42.png#averageHue=%23e8d7b3&crop=0&crop=0&crop=1&crop=1&id=Z7b9M&originHeight=610&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />RabbitMQ中的一些角色：</p><ul><li><p>publisher：生产者</p></li><li><p>consumer：消费者</p></li><li><p>exchange个：交换机，负责消息路由</p></li><li><p>queue：队列，存储消息</p></li><li><p>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离<br><a name="T1HjP"></a></p><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787076-9308a9f3-2e8c-471a-87cd-766ff8f3b446.png#averageHue=%23f8f5f5&crop=0&crop=0&crop=1&crop=1&id=f2Tmk&originHeight=715&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="T4zLf"></a></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787199-2013017b-c013-4ce5-b453-0c0a9e013841.png#averageHue=%23c7ad84&crop=0&crop=0&crop=1&crop=1&id=ldcHW&originHeight=112&originWidth=232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />导入后可以看到结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787276-88d553b3-7a16-4531-af56-641a9f37ad2d.png#averageHue=%23eef3ed&crop=0&crop=0&crop=1&crop=1&id=cV4YR&originHeight=193&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />包括三部分：</p></li><li><p>mq-demo：父工程，管理项目依赖</p></li><li><p>publisher：消息的发送者</p></li><li><p>consumer：消息的消费者<br><a name="Z2HZj"></a></p><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787363-fed4f089-38aa-4236-8c22-9f304e67805b.png#averageHue=%23f6f3eb&crop=0&crop=0&crop=1&crop=1&id=J3t1L&originHeight=215&originWidth=1247&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p></li><li><p>publisher：消息发布者，将消息发送到队列queue</p></li><li><p>queue：消息队列，负责接受并缓存消息</p></li><li><p>consumer：订阅队列，处理队列中的消息<br><a name="n0JyN"></a></p><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p></li><li><p>建立连接</p></li><li><p>创建Channel</p></li><li><p>声明队列</p></li><li><p>发送消息</p></li><li><p>关闭连接和channel</p></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bEghi"></a></p><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="qBU7O"></a></p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定<br><a name="VVz3G"></a><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。<br />SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787451-72dee171-3ecd-46e2-b098-a05b68db0ca6.png#averageHue=%23eeeeee&crop=0&crop=0&crop=1&crop=1&id=DXBQE&originHeight=499&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787527-cb46096b-aab7-4885-beb4-994fb00c84c6.png#averageHue=%23ededed&crop=0&crop=0&crop=1&crop=1&id=hBf4u&originHeight=453&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />SpringAMQP提供了三个功能：</li></ol><ul><li><p>自动声明队列、交换机及其绑定关系</p></li><li><p>基于注解的监听器模式，异步接收消息</p></li><li><p>封装了RabbitTemplate工具，用于发送消息<br><a name="VPYnW"></a></p><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="QttGI"></a></p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lqD7e"></a></p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bi81Z"></a></p><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息<br><a name="y2Ocd"></a></p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787605-9d2eff6e-6a64-413a-9509-7a5377fee1d2.png#averageHue=%23fdfafa&crop=0&crop=0&crop=1&crop=1&id=iSaeo&originHeight=471&originWidth=1253&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br />此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<br><a name="yJv4d"></a></p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br />在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dcex7"></a></p><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。<br><a name="S3N47"></a></p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br />可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。<br />也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br><a name="Rqsrd"></a></p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p><a name="CMhwi"></a></p><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p></li><li><p>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</p></li><li><p>通过设置prefetch来控制消费者预取的消息数量<br><a name="Vjep9"></a></p><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787681-4aeb1677-7204-4ad4-8527-0df956d43573.png#averageHue=%23fcf7f7&crop=0&crop=0&crop=1&crop=1&id=e81wW&originHeight=462&originWidth=1431&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p></li><li><p>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p></li><li><p>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li><p>Consumer：消费者，与以前一样，订阅队列，没有变化</p></li><li><p>Queue：消息队列也与以前一样，接收消息、缓存消息。</p></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br><a name="yGXsj"></a></p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787762-a73eeff1-b2d6-4549-9fb2-5406a6c2eee3.png#averageHue=%23fcf6f6&crop=0&crop=0&crop=1&crop=1&id=uR1Vd&originHeight=431&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787843-757ef8b9-af77-4a7b-9279-be6dd1ba6dc3.png#averageHue=%23faf4f4&crop=0&crop=0&crop=1&crop=1&id=crdxG&originHeight=265&originWidth=1219&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="F3BJ3"></a></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787931-230738f8-6723-4ae1-9111-64e027bca438.png#averageHue=%23ecf3e4&crop=0&crop=0&crop=1&crop=1&id=rQnLa&originHeight=332&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="y22gD"></a></p><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KP2F9"></a></p><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="InRp8"></a></p><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li><p>Queue</p></li><li><p>FanoutExchange</p></li><li><p>Binding<br><a name="XbUES"></a></p><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788019-955e2d17-01d7-45b3-8d6f-62a8313177a4.png#averageHue=%23fcf5f5&crop=0&crop=0&crop=1&crop=1&id=yOiFA&originHeight=494&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在Direct模型下：</p></li><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</p></li><li><p>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</p></li><li><p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</p></li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788106-e7b49dcc-e945-401c-a98d-7481e0a711c1.png#averageHue=%23fbf5f5&crop=0&crop=0&crop=1&crop=1&id=Aj1Pf&originHeight=444&originWidth=1201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="nE7lQ"></a></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br />在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="oy60j"></a></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Zua1L"></a></p><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li><p><a href="/Queue">_@_Queue </a></p></li><li><p><a href="/Exchange">_@_Exchange </a><br><a name="sZ0IL"></a></p><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><p><a name="iWcOC"></a></p><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br /><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br />通配符规则：<br /><code>#</code>：匹配一个或多个词<br /><code>*</code>：匹配不多不少恰好1个词<br />举例：<br /><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code><br /><code>item.*</code>：只能匹配<code>item.spu</code><br />图示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788193-3b31831c-3646-424d-818e-4a8c9ff69f27.png#averageHue=%23f8f0ef&crop=0&crop=0&crop=1&crop=1&id=r1SbP&originHeight=557&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />解释：</p></li><li><p>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</p></li><li><p>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</p></li></ul><p>案例需求：<br />实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788285-52c1019e-b1a5-4f71-bf8f-e2d570632ca1.png#averageHue=%23fbf4f4&crop=0&crop=0&crop=1&crop=1&id=tcuAJ&originHeight=349&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="JqciL"></a></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JDboz"></a></p><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PARTg"></a></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li><p>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</p></li><li><p>Topic交换机与队列绑定时的bindingKey可以指定通配符</p></li><li><p><code>#</code>：代表0个或多个词</p></li><li><p><code>*</code>：代表1个词<br><a name="nEmH2"></a></p><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788362-85cd58d8-6ff7-4b5d-9f87-dfd2505c40e2.png#averageHue=%23d7e8ca&crop=0&crop=0&crop=1&crop=1&id=RW0nO&originHeight=294&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p></li><li><p>数据体积过大</p></li><li><p>有安全漏洞</p></li><li><p>可读性差</p></li></ul><p>我们来测试一下。<br><a name="thtY7"></a></p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务<br />发送消息后查看控制台：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788452-169f9ba6-21ff-4c85-b9e9-c3f7c91c3653.png#averageHue=%23f9f8f7&crop=0&crop=0&crop=1&crop=1&id=ObbD9&originHeight=388&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Aijdb"></a></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。<br />在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。<br />在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;BB9gb&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;XmLxR&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="生活杂谈" scheme="http://zephyr-cyber.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java实现坦克大战练手小游戏</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html</id>
    <published>2020-09-18T13:45:28.000Z</published>
    <updated>2022-12-12T08:57:30.888Z</updated>
    
    <content type="html"><![CDATA[<p>自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单看看源码。</p><blockquote><p><a href="https://github.com/glassy-sky-lisong/TankGame">坦克大战传送门</a></p></blockquote><p>有有个.idea文件夹，上传时不小心上传上去了，大家clone下来删掉即可，这是idea的个人配置文件夹。不过，idea敲java是真香，[手动狗头.jpg]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/tags/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/tags/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Maven一直reading读取pom.xml文件问题</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html</id>
    <published>2020-09-05T15:24:11.000Z</published>
    <updated>2022-12-12T08:57:52.636Z</updated>
    
    <content type="html"><![CDATA[<p>关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉IDEA的桌面任务，然后想通过卸载IDEA来重新建项目，但是没有效果，无奈只能面向百度了，看了一些帖子，据说是网络配置问题，其解决的方案大致这有几种：</p><ol><li>修改HOST文件的 127.0.0.1为localhost，在终端输入 *** netsh winsock reset*** 我的HOST的确是在安装navicat时候改过，然后就修改重启后也没有效果</li><li>添加本地maven到环境变量，这个有效，不过是在降低springboot版本之后添加的</li><li>降低springboot版本，默认是2.3.3，降低到2.2.*</li><li>在IDEA的Help菜单下的showlogExpore，查看运行日志，检查问题，我看了一遍，并没有明显的错误</li></ol><p>折腾了挺长时间，现在分享给大家，帮助大家在遇到此类问题的小伙伴能尽快解决，以免耽误工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉ID</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/Maven/"/>
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/tags/Java/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/tags/Maven/"/>
    
    <category term="SpringBoot" scheme="http://zephyr-cyber.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型之上、下边界通配符的理解(适合初学)</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html</id>
    <published>2020-09-02T11:15:25.000Z</published>
    <updated>2022-12-12T08:56:49.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的由来"><a href="#泛型的由来" class="headerlink" title="泛型的由来"></a>泛型的由来</h2><h3 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h3><p>&emsp;&emsp;Java的数据类型一般都是在定义时就需要确定，这种强制的好处就是类型安全，不会出现像弄一个ClassCastException的数据给jvm，数据安全那么执行的class就会很稳定。但是假如说我不知道这个参数要传什么类型的，因为公司需求在变，如果写死的那就只能便以此需求就改一次，很麻烦。sun公司也注意到这个问题，这样会让代码的灵活性降低，他们就研究出了泛型。</p><h3 id="泛型初识"><a href="#泛型初识" class="headerlink" title="泛型初识"></a>泛型初识</h3><p>&emsp;&emsp;什么是泛型，可以字面理解就是一个泛泛的类型，他是不确定的，在Java代码编译的时候用泛型是不会出错的，而在运行期时就会报错，说你这种第一是不合理的。这是为什么呢。因为为了提高灵活性，就在编译时期将条件放宽，但是泛型一定要在运行的时候告诉jvm你给我的数据到底是什么类型的，否则jvm会是懵逼的。所以泛型的好处就是将类型的灵活性提高，也只是在Java语法的基础上提高，不过泛型还是比较实用的。</p><h3 id="何时使用泛型"><a href="#何时使用泛型" class="headerlink" title="何时使用泛型"></a>何时使用泛型</h3><p>&emsp;&emsp;泛型的应用场景就是应用在模型（可以理解为存储数据的盒子），我为了这个盒子适用更多的地方我就用将需要存入的数据用一个泛型表示，当然可以传入多值。如果是相同类型的对象就用一个泛型的数组比较好，学过集合的小伙伴应该都知道，没学过的那你应该补补课了。</p><p><em><strong>泛型的语法</strong></em></p><pre><code>public class A&lt;T extends B&gt;&#123;   T t;&#125;</code></pre><h2 id="泛型的缺点或者为什么需要上、下边界"><a href="#泛型的缺点或者为什么需要上、下边界" class="headerlink" title="泛型的缺点或者为什么需要上、下边界"></a>泛型的缺点或者为什么需要上、下边界</h2><p>&emsp;&emsp;泛型的虽然强大，但是世界上任何东西东部是完美的。它也有缺陷。比如说我有一个盒子我想装苹果，但是我还可能想装香蕉那怎么办。那还不好说，在给一个参数不就行了，那十个呢，二十个呢。em….的确是。如果说我们想装的东西都属于一个类并且只要是这个类的子类就可以装。这个想法sun为我们想好了。那就是用上边界通配符。语法是<T entends M> T是泛型，M是T的父类。我们就定义一个水果类（Fruit），盛装就容器就是盘子（Dish），现在我们就可以装任何水果了，不错吧！</p><p><em><strong>上边界Java代码</strong></em></p><pre><code>public class Dish&lt;T extends Fruit&gt;&#123;  private T fruitChild;  public Dish(T fruitChild)&#123;    this.fruitChild = fruitChild;  &#125;  public T getFruitChild()&#123;    return fruitChild;  &#125;    public void setFruitChild(T f)&#123;    this.fruitChild = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;apple&gt;();    Apple apple = new apple(); //apple must be Fruit child;    dish.setFruitChild(apple);    system.out.printf(dish.getFruitChild);  &#125;&#125;</code></pre><p><em><strong>下边界Java代码</strong></em></p><pre><code>public class Dish&lt;T super Apple&gt;&#123;  private T appleFather;  public Dish(T appleFather)&#123;    this.appleFather = appleFather;  &#125;  public T getAppleFather()&#123;    return appleFather;  &#125;    public void setAppleFather(T f)&#123;    this.appleFather = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;Fruit&gt;();    Fruit fruit = new Fruit(); //fruit must be apple son;    dish.setAppleFather(fruit);    system.out.printf(dish.getAppleFather);  &#125;&#125;</code></pre><h2 id="什么是上边界通配符"><a href="#什么是上边界通配符" class="headerlink" title="什么是上边界通配符"></a>什么是上边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T extends A> 的A类型到A类型任何子类的限制域，可以匹配任何在此限制域中的类型，此种表示叫上边界通配符。<br>###上边界通配符理解<br><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png" alt="png"></p><h2 id="什么是下边界通配符"><a href="#什么是下边界通配符" class="headerlink" title="什么是下边界通配符"></a>什么是下边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T super A> 的A类型到A类型任何父类的限制域，可以匹配任何在此限制域中的类型，此种表示叫下边界通配符。</p><h3 id="下边界通配符理解"><a href="#下边界通配符理解" class="headerlink" title="下边界通配符理解"></a>下边界通配符理解</h3><p><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png" alt="png"></p><h2 id="上下边界通配符的缺点"><a href="#上下边界通配符的缺点" class="headerlink" title="上下边界通配符的缺点"></a>上下边界通配符的缺点</h2><p>&emsp;&emsp;上界&lt;? extends T&gt;不能往里存，只能往外取。<br>###解释<br>&emsp;&emsp;因为编译器只知道传入的是T的子类，但具体是哪一个编译器不知道，他只标注了一个占位符，当？传过来时，他不知道这能不能和占位符匹配，所以set不了。<br>&emsp;&emsp;下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>&emsp;&emsp;因为下边界已经限制了？的粒度，他只可能是T本身或者是T的父类。我们想想，我想要一个T，你却返回给我一个比T小的Object，这样我们就因为精度损失而拿不到想要的数据了。</p><blockquote><p>感谢各位童鞋的阅读，希望大家动一动发财的小手点一下推荐QAQ。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的由来&quot;&gt;&lt;a href=&quot;#泛型的由来&quot; class=&quot;headerlink&quot; title=&quot;泛型的由来&quot;&gt;&lt;/a&gt;泛型的由来&lt;/h2&gt;&lt;h3 id=&quot;为什么需要泛型&quot;&gt;&lt;a href=&quot;#为什么需要泛型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
    <category term="博客园" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>超实用的SQL语句之嵌套查询</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/f3908263.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/f3908263.html</id>
    <published>2020-08-31T11:40:33.000Z</published>
    <updated>2022-12-12T08:59:08.456Z</updated>
    
    <content type="html"><![CDATA[<h2>嵌套查询</h2><h3>什么是嵌套查询</h3>. 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。<h3>嵌套查询的工作方式</h3> 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。<h2>子查询的组成</h2> 1、包含标准选择列表组件的标准select查询。<p> 2、包含一个或多个表或者视图名称的标准from子句。</p><p> 3、可选的where子句。</p><p> 4、可选的group by子句。</p><p> 5、可选的having子句。</p><h2>子查询的语法规则</h2> 1、子查询的select查询总是使用圆括号括起来。<p> 2、不能包括compute或for.browse子句。</p><p> 3、如果同时指定top子句，则可能只包括order by子句。</p><p> 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。</p><p> 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。</p><p> 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。</p><h2>简单子查询</h2><strong>示例：</strong><pre><code>select name,age from person where age &gt;     (        select age from person         where name = &#39;孙权&#39;    )</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg" alt="1"></p><h2>in嵌套查询</h2> 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。<p><strong>示例：</strong></p><pre><code>select name from person where countryid in (select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong></p><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg" alt="2"><h2>some嵌套查询</h2><h3>语法</h3> 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：<pre><code>&lt;表达式&gt;&#123; =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;&#125;some(子查询)</code></pre><p><strong>示例：</strong></p><pre><code>select name from person where countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回(select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg" alt="3"></p><h2>all嵌套查询</h2> 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。<h3>语法</h3><pre><code>&lt;表达式&gt;&#123; =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;&#125;all(子查询)</code></pre><p><strong>示例：</strong></p><pre><code>select name from person where countryid &gt; all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回(select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg" alt="4"></p><h2>exists嵌套查询</h2><h3>语法</h3> 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style="color:red">一旦找到第一个匹配的记录后，就马上停止查找。</span><pre><code>exists　子查询</code></pre><p> 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。<br>exists 的意思是，子查询是否有结果集返回。<br><strong>例如：</strong></p><pre><code>SELECT * FROM PersonWHERE exists(SELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行)</code></pre><p> 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：</p><pre><code>SELECT * FROM PersonWHERE exists(SELECT * FROM Person WHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行)</code></pre><p>最后感谢<a href="https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html">不玩博客了！</a>同学的分享，么么哒！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;嵌套查询&lt;/h2&gt;
&lt;h3&gt;什么是嵌套查询&lt;/h3&gt;.
 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。
&lt;h3&gt;嵌</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="mybatis" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/mybatis/"/>
    
    
    <category term="MySQL" scheme="http://zephyr-cyber.github.io/tags/MySQL/"/>
    
    <category term="MyBatis" scheme="http://zephyr-cyber.github.io/tags/MyBatis/"/>
    
    <category term="SQL技巧" scheme="http://zephyr-cyber.github.io/tags/SQL%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>博客美化——Silence主题皮肤</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/3ba53770.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/3ba53770.html</id>
    <published>2020-08-30T12:08:31.000Z</published>
    <updated>2022-12-12T08:58:09.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。</p><ul><li><a href="https://github.com/glassy-sky-lisong/SilenceSkin">博客皮肤源码地址</a></li><li><a href="https://www.cnblogs.com/esofar">预览地址</a></li><li><a href="https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md">如何部署、使用皮肤</a></li><li><a href="https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html">Silence作者的友链</a></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>简洁优雅、精致漂亮的 UI 设计</li><li>提供多种风格主题以便适应各类用户的偏好</li><li>响应式设计，兼容手机端浏览器</li><li>提供事无巨细的部署文档</li><li>源码结构清晰并且注释完整，方便扩展</li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。</p><pre><code> git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码 cd cnblogs-theme-silence                                        # 进入项目 npm install                                                     # 安装依赖 npm run build</code></pre><p>&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见’如何部署、使用皮肤’，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）<br><em><strong>CSS</strong></em></p><pre><code>&lt;!-- 溢出隐藏设置（放置在管理--&gt; 设置--&gt; css模块中） --&gt;#topics, #mainContent &#123;    overflow: visible;&#125;.cnblogs-markdown .hljs&#123;    display:block;    color:#333;    overflow-x:auto;    background:#F2F4F5!important;    border:none!important;    font-family:Consolas,Monaco,&#39;Andale Mono&#39;,&#39;Ubuntu Mono&#39;,monospace!important;    padding:1em!important;    font-size:14px!important    &#125;</code></pre><p><em><strong>侧边栏公告</strong></em></p><pre><code>&lt;!-- 在管理--&gt; 设置-&gt; 侧边栏公告(支持js代码、支持html代码) --&gt;&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/silence.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $.silence(&#123;        profile: &#123;            enable: true,            avatar: &#39;https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&#39;,            favicon: &#39;https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&#39;,        &#125;,        catalog: &#123;            enable: true,            move: true,            index: true,            level1: &#39;h2&#39;,            level2: &#39;h3&#39;,            level3: &#39;h4&#39;,        &#125;,        signature: &#123;            enable: true,            home: &#39;https://www.cnblogs.com/glassysky/&#39;,            license: &#39;署名 4.0 国际&#39;,            link: &#39;https://creativecommons.org/licenses/by/4.0&#39;        &#125;,        reward: &#123;            enable: true,            title: &#39;感谢小可爱投食&#39;,            wechat: &#39;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png&#39;,            alipay: &#39;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png&#39;        &#125;,        github: &#123;            enable: true,            color: &#39;#fff&#39;,            fill: null,            link: &#39;https://github.com/glassy-sky-lisong&#39;        &#125;    &#125;);&lt;/script&gt;&lt;!--外置主题css补丁--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/sli.css&quot;/&gt;</code></pre><p><em><strong>会动的title</strong></em></p><pre><code>&lt;!-- 动态titlejs --&gt;&lt;script&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&#39;visibilitychange&#39;, function () &#123; if                 (document.hidden) &#123; document.title = &#39;╭(°A°`)╮ 页面崩溃啦 ~&#39;; clearTimeout(titleTime); &#125; else &#123; document.title = &#39;(ฅ&gt;ω&lt;*ฅ) 噫又    好了~&#39; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); &lt;/script&gt;</code></pre><p><em><strong>图片放大功能</strong></em></p><pre><code>&lt;!--图片放大的zoomcss和js--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.css&quot;/&gt;&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.js&quot;&gt;&lt;/script&gt;&lt;!-- Bootstrap 的 transition.js cdn（过渡动画插件）--&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(&#39;#cnblogs_post_body img&#39;).attr(&#39;data-action&#39;, &#39;zoom&#39;);&lt;/script&gt;</code></pre><h2 id="博客的皮肤风格"><a href="#博客的皮肤风格" class="headerlink" title="博客的皮肤风格"></a>博客的皮肤风格</h2><ul><li>简约·蓝<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png" alt="img1"> </li><li>暗黑·绿<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png" alt="img2"></li><li>女神·粉<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png" alt="img3">  </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
    <category term="博客园" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch高级</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/2376083540.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/2376083540.html</id>
    <published>2020-07-22T09:43:46.000Z</published>
    <updated>2022-12-12T09:20:21.968Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。<br />所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。<br><a name="IO9W4"></a></p><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><p><a name="xZaJf"></a></p><h1 id="1-DSL查询文档"><a href="#1-DSL查询文档" class="headerlink" title="1.DSL查询文档"></a>1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。<br><a name="wR3NH"></a></p><h2 id="1-1-DSL查询分类"><a href="#1-1-DSL查询分类" class="headerlink" title="1.1.DSL查询分类"></a>1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_query-dsl/">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</li><li><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>multi_match_query</li></ul></li><li><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li><strong>地理（geo）查询</strong>：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span>: <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li><p>查询类型为match_all</p></li><li><p>没有查询条件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。<br><a name="sP5bU"></a></p><h2 id="1-2-全文检索查询"><a href="#1-2-全文检索查询" class="headerlink" title="1.2.全文检索查询"></a>1.2.全文检索查询</h2><p><a name="Q3afF"></a></p><h3 id="1-2-1-使用场景"><a href="#1-2-1-使用场景" class="headerlink" title="1.2.1.使用场景"></a>1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p></li><li><p>对用户搜索的内容做分词，得到词条</p></li><li><p>根据词条去倒排索引库中匹配，得到文档id</p></li><li><p>根据文档id找到文档，返回给用户</p></li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490101-124b9131-b8c7-4a21-9990-7242f0175454.png#averageHue=%23f6efee&crop=0&crop=0&crop=1&crop=1&id=WGb76&originHeight=186&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。<br><a name="QXFkb"></a></p><h3 id="1-2-2-基本语法"><a href="#1-2-2-基本语法" class="headerlink" title="1.2.2.基本语法"></a>1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;FIELD1&quot;</span>, <span class="string">&quot; FIELD12&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e0oma"></a></p><h3 id="1-2-3-示例"><a href="#1-2-3-示例" class="headerlink" title="1.2.3.示例"></a>1.2.3.示例</h3><p>match查询示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490209-54b063cd-9946-4b84-891b-f76e4d5f0a59.png#averageHue=%23d8e8e7&crop=0&crop=0&crop=1&crop=1&id=uKm2T&originHeight=588&originWidth=1758&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />multi_match查询示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490384-9c56b5a9-9e87-44e3-9cd7-f914077479a7.png#averageHue=%23f3f7fa&crop=0&crop=0&crop=1&crop=1&id=KXO9Z&originHeight=586&originWidth=1761&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，两种查询结果是一样的，为什么？<br />因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。<br />但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。<br><a name="qn18A"></a></p><h3 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4.总结"></a>1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li><p>match：根据一个字段查询</p></li><li><p>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差<br><a name="MGeCg"></a></p><h2 id="1-3-精准查询"><a href="#1-3-精准查询" class="headerlink" title="1.3.精准查询"></a>1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p></li><li><p>term：根据词条精确值查询</p></li><li><p>range：根据值的范围查询<br><a name="pKtFT"></a></p><h3 id="1-3-1-term查询"><a href="#1-3-1-term查询" class="headerlink" title="1.3.1.term查询"></a>1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。<br />语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br />当我搜索的是精确词条时，能正确查询出结果：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490580-c26c1550-7727-4d83-9e25-8d46070627d7.png#averageHue=%23f3f7fa&crop=0&crop=0&crop=1&crop=1&id=OzfCr&originHeight=557&originWidth=1557&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490726-dda8a24e-be56-45de-817b-35252d3f8898.png#averageHue=%23f2f5f9&crop=0&crop=0&crop=1&crop=1&id=qYqlA&originHeight=463&originWidth=1307&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="QWMFR"></a></p><h3 id="1-3-2-range查询"><a href="#1-3-2-range查询" class="headerlink" title="1.3.2.range查询"></a>1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。<br />基本语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">10</span>, <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490838-418aa4de-63d5-452e-8767-d74c1f414e87.png#averageHue=%23f0f5f8&crop=0&crop=0&crop=1&crop=1&id=UxMVD&originHeight=414&originWidth=1482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Yhnin"></a></p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><p>精确查询常见的有哪些？</p></li><li><p>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</p></li><li><p>range查询：根据数值范围查询，可以是数值、日期的范围<br><a name="bTbvn"></a></p><h2 id="1-4-地理坐标查询"><a href="#1-4-地理坐标查询" class="headerlink" title="1.4.地理坐标查询"></a>1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_geo-queries/">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a><br />常见的使用场景包括：</p></li><li><p>携程：搜索我附近的酒店</p></li><li><p>滴滴：搜索我附近的出租车</p></li><li><p>微信：搜索我附近的人</p></li></ul><p>附近的酒店：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490964-d895b121-bf0b-4f8e-8f1a-6396ab746832.png#averageHue=%23f2ece1&crop=0&crop=0&crop=1&crop=1&id=KoZgm&originHeight=398&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />附近的车：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491071-5fac23a9-4cd8-43e7-a4d1-0783fd4370c4.png#averageHue=%2358b8a3&crop=0&crop=0&crop=1&crop=1&id=Mbbzj&originHeight=502&originWidth=295&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="S0XhR"></a></p><h3 id="1-4-1-矩形范围查询"><a href="#1-4-1-矩形范围查询" class="headerlink" title="1.4.1.矩形范围查询"></a>1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/21797045/1670218491205-88950fd2-d714-49b9-9056-464de70528cd.gif#averageHue=%23bed2b7&crop=0&crop=0&crop=1&crop=1&id=MiNrT&originHeight=170&originWidth=336&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。<br />语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span>: &#123; <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">31.1</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span>: &#123; <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">30.9</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.7</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。<br><a name="L633j"></a></p><h3 id="1-4-2-附近查询"><a href="#1-4-2-附近查询" class="headerlink" title="1.4.2.附近查询"></a>1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。<br />换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/21797045/1670218491356-c33f6739-59e6-4972-9fff-c539d50a11fb.gif#averageHue=%23c2e3ca&crop=0&crop=0&crop=1&crop=1&id=WhBQf&originHeight=323&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;15km&quot;</span>, <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br />我们先搜索陆家嘴附近15km的酒店：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491517-6e16f6f0-e21e-47fd-8f6c-bf52913f5703.png#averageHue=%23f2f6f9&crop=0&crop=0&crop=1&crop=1&id=WGm5m&originHeight=474&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />发现共有47家酒店。<br />然后把半径缩短到3公里：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491648-07b84b6e-ca6a-495d-a050-546acdd6727b.png#averageHue=%23d9e9ea&crop=0&crop=0&crop=1&crop=1&id=aHt4l&originHeight=470&originWidth=1308&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以发现，搜索到的酒店数量减少到了5家。<br><a name="wDQsr"></a></p><h2 id="1-5-复合查询"><a href="#1-5-复合查询" class="headerlink" title="1.5.复合查询"></a>1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li><p>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</p></li><li><p>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索<br><a name="iqCru"></a></p><h3 id="1-5-1-相关性算分"><a href="#1-5-1-相关性算分" class="headerlink" title="1.5.1.相关性算分"></a>1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。<br />例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">17.850193</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;虹桥如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">12.259849</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;外滩如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">11.91091</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;迪士尼如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491765-3cee45ba-785c-4889-98c3-a61dc10197eb.png#averageHue=%23a6a6a6&crop=0&crop=0&crop=1&crop=1&id=g9Pl5&originHeight=376&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491848-2d5a1b84-f1ef-4710-9587-c512c08ca4ba.png#averageHue=%23979797&crop=0&crop=0&crop=1&crop=1&id=R2iwH&originHeight=195&originWidth=912&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491939-f41ebd42-83f3-486d-b9c2-1b298981979e.png#averageHue=%23f6f6f6&crop=0&crop=0&crop=1&crop=1&id=FbqnK&originHeight=416&originWidth=589&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p></li><li><p>TF-IDF算法</p></li><li><p>BM25算法，elasticsearch5.1版本后采用的算法<br><a name="Zvzuv"></a></p><h3 id="1-5-2-算分函数查询"><a href="#1-5-2-算分函数查询" class="headerlink" title="1.5.2.算分函数查询"></a>1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。<br />以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492057-425fabba-6a06-4bca-82d9-a01ffd71b18e.png#averageHue=%23f9e7e5&crop=0&crop=0&crop=1&crop=1&id=FJOd9&originHeight=332&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。<br><a name="a207P"></a></p><h4 id="1）语法说明"><a href="#1）语法说明" class="headerlink" title="1）语法说明"></a>1）语法说明</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492148-edc999a4-3d92-4f9b-a9ff-19da37f00cd0.png#averageHue=%23f5f7f0&crop=0&crop=0&crop=1&crop=1&id=o9OVq&originHeight=556&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />function score 查询中包含四部分内容：</p></li><li><p><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</p></li><li><p><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</p></li><li><p><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数</p><ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><p><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：</p><ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li><p>过滤条件：决定哪些文档的算分被修改</p></li><li><p>算分函数：决定函数算分的算法</p></li><li><p>运算模式：决定最终算分结果<br><a name="kWA3W"></a></p><h4 id="2）示例"><a href="#2）示例" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些<br />翻译一下这个需求，转换为之前说的四个要点：</p></li><li><p>原始条件：不确定，可以任意变化</p></li><li><p>过滤条件：brand = “如家”</p></li><li><p>算分函数：可以简单粗暴，直接给固定的算分结果，weight</p></li><li><p>运算模式：比如求和</p></li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: &#123;  .... &#125;, <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span>: [ <span class="comment">// 算分函数</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: &#123; <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span> <span class="comment">// 算分权重为2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span>: <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492248-817c4411-b68d-421e-a1ad-65cbf7c9d786.png#averageHue=%23f0f4f9&crop=0&crop=0&crop=1&crop=1&id=SUIpi&originHeight=444&originWidth=1340&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />添加了算分函数后，如家得分就提升了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492372-5644632e-653c-4a0f-9dc5-bfe5d63f234e.png#averageHue=%23eef3f8&crop=0&crop=0&crop=1&crop=1&id=jML3i&originHeight=568&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="m2oYy"></a></p><h4 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li><p>过滤条件：哪些文档要加分</p></li><li><p>算分函数：如何计算function score</p></li><li><p>加权方式：function score 与 query score如何运算<br><a name="H8qsR"></a></p><h3 id="1-5-3-布尔查询"><a href="#1-5-3-布尔查询" class="headerlink" title="1.5.3.布尔查询"></a>1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p></li><li><p>must：必须匹配每个子查询，类似“与”</p></li><li><p>should：选择性匹配子查询，类似“或”</p></li><li><p>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</p></li><li><p>filter：必须匹配，<strong>不参与算分</strong></p></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492523-1dc17c69-429e-4198-ad9f-587bff4d51a1.png#crop=0&crop=0&crop=1&crop=1&id=Gw9NO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。<br />需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li><p>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</p></li><li><p>其它过滤条件，采用filter查询。不参与算分<br><a name="mXen0"></a></p><h4 id="1）语法示例："><a href="#1）语法示例：" class="headerlink" title="1）语法示例："></a>1）语法示例：</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;皇冠假日&quot;</span> &#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华美达&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;lte&quot;</span>: <span class="number">500</span> &#125; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123;<span class="attr">&quot;score&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="number">45</span> &#125; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="DtuOc"></a></p><h4 id="2）示例-1"><a href="#2）示例-1" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。<br />分析：</p></li><li><p>名称搜索，属于全文检索查询，应该参与算分。放到must中</p></li><li><p>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</p></li><li><p>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492606-d72216b0-1d28-4c6a-af46-3e68dbf2f137.png#crop=0&crop=0&crop=1&crop=1&id=U3kx0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="yGKJH"></a></p><h4 id="3）小结-1"><a href="#3）小结-1" class="headerlink" title="3）小结"></a>3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li><p>must：必须匹配的条件，可以理解为“与”</p></li><li><p>should：选择性匹配的条件，可以理解为“或”</p></li><li><p>must_not：必须不匹配的条件，不参与打分</p></li><li><p>filter：必须匹配的条件，不参与打分<br><a name="uHHyB"></a></p><h1 id="2-搜索结果处理"><a href="#2-搜索结果处理" class="headerlink" title="2.搜索结果处理"></a>2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。<br><a name="Nfc3U"></a></p><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1.排序"></a>2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_sort-search-results/">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。<br><a name="ET6BV"></a></p><h3 id="2-1-1-普通字段排序"><a href="#2-1-1-普通字段排序" class="headerlink" title="2.1.1.普通字段排序"></a>2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。<br /><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推<br /><strong>示例</strong>：<br />需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492745-bedb9856-69f2-4a13-a5a2-3b6598f4c735.png#crop=0&crop=0&crop=1&crop=1&id=ndvIJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="dqDbO"></a></p><h3 id="2-1-2-地理坐标排序"><a href="#2-1-2-地理坐标排序" class="headerlink" title="2.1.2.地理坐标排序"></a>2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。<br /><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>, <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>, <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询的含义是：</p></li><li><p>指定一个坐标，作为目标点</p></li><li><p>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</p></li><li><p>根据距离排序</p></li></ul><p><strong>示例：</strong><br />需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序<br />提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a><br />假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492847-628ecb7c-3f46-4c4e-8da3-d120e861fd5f.png#crop=0&crop=0&crop=1&crop=1&id=gmSeC&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="iimGN"></a></p><h2 id="2-2-分页"><a href="#2-2-分页" class="headerlink" title="2.2.分页"></a>2.2.分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code><br><a name="VFQue"></a></p><h3 id="2-2-1-基本的分页"><a href="#2-2-1-基本的分页" class="headerlink" title="2.2.1.基本的分页"></a>2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pacqf"></a></p><h3 id="2-2-2-深度分页问题"><a href="#2-2-2-深度分页问题" class="headerlink" title="2.2.2.深度分页问题"></a>2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">990</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是查询990开始的数据，也就是 第990<del>第1000条 数据。<br />不过，elasticsearch内部分页时，必须先查询 0</del>1000条，然后截取其中的990 ~ 1000的这10条：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492964-71c4dce9-8c55-45e9-a212-197347ea1e1d.png#crop=0&crop=0&crop=1&crop=1&id=hgCFJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />查询TOP1000，如果es是单点模式，这并无太大影响。<br />但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。<br />因为节点A的TOP200，在另一个节点可能排到10000名以外了。<br />因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493047-7c110509-bf9d-49ae-ad1b-7213cd91e371.png#crop=0&crop=0&crop=1&crop=1&id=EJsoD&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？<br />当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。<br />针对深度分页，ES提供了两种解决方案，<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_paginate-search-results/">官方文档</a>：</p><ul><li><p>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</p></li><li><p>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。<br><a name="uFEyF"></a></p><h3 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3.小结"></a>2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p></li><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。<br><a name="c4vBF"></a><h2 id="2-3-高亮"><a href="#2-3-高亮" class="headerlink" title="2.3.高亮"></a>2.3.高亮</h2><a name="AoJ4q"></a><h3 id="2-3-1-高亮原理"><a href="#2-3-1-高亮原理" class="headerlink" title="2.3.1.高亮原理"></a>2.3.1.高亮原理</h3>什么是高亮显示呢？<br />我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493133-cfbc56a0-3f3c-4ac4-a944-4a9a9fff6ae2.png#crop=0&crop=0&crop=1&crop=1&id=wvmDs&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />高亮显示的实现分为两步：</li></ul></li><li><p>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</p></li><li><p>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式<br><a name="DdXpw"></a></p><h3 id="2-3-2-实现高亮"><a href="#2-3-2-实现高亮" class="headerlink" title="2.3.2.实现高亮"></a>2.3.2.实现高亮</h3></li></ul><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123; <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul><p><strong>示例</strong>：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493238-db0da126-e3de-4e7a-92a8-c32833e20160.png#crop=0&crop=0&crop=1&crop=1&id=B54no&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="bFCA7"></a></p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4.总结"></a>2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493354-9794652a-3b39-4e01-a152-eb99436247fb.png#crop=0&crop=0&crop=1&crop=1&id=LqpcM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Gcds8"></a></p><h1 id="3-RestClient查询文档"><a href="#3-RestClient查询文档" class="headerlink" title="3.RestClient查询文档"></a>3.RestClient查询文档</h1><p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li><p>1）准备Request对象</p></li><li><p>2）准备请求参数</p></li><li><p>3）发起请求</p></li><li><p>4）解析响应<br><a name="Q86qC"></a></p><h2 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1.快速入门"></a>3.1.快速入门</h2><p>我们以match_all查询为例<br><a name="kfL1y"></a></p><h3 id="3-1-1-发起查询请求"><a href="#3-1-1-发起查询请求" class="headerlink" title="3.1.1.发起查询请求"></a>3.1.1.发起查询请求</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493440-cf56f498-34d3-4e4a-b700-932289b4139d.png#crop=0&crop=0&crop=1&crop=1&id=PcXeM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />代码解读：</p></li><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493525-bd78e7f4-cb40-484e-8d27-e427bf92d82f.png#crop=0&crop=0&crop=1&crop=1&id=hyoqn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493628-5a0dc86a-057d-4d63-a7ef-066a92c33a12.png#crop=0&crop=0&crop=1&crop=1&id=pWnaH&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="lnXTZ"></a></p><h3 id="3-1-2-解析响应"><a href="#3-1-2-解析响应" class="headerlink" title="3.1.2.解析响应"></a>3.1.2.解析响应</h3><p>响应结果的解析：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493732-1de1fd56-86bc-4274-8068-c0a9ace82388.png#crop=0&crop=0&crop=1&crop=1&id=P5XJT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据<br><a name="fUDpm"></a><h3 id="3-1-3-完整代码"><a href="#3-1-3-完整代码" class="headerlink" title="3.1.3.完整代码"></a>3.1.3.完整代码</h3>完整代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="Hojaa"></a><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3>查询的基本步骤是：</li></ul></li></ul></li></ul><ol><li>创建SearchRequest对象</li><li>准备Request.source()，也就是DSL。<br />① QueryBuilders来构建查询条件<br />② 传入Request.source() 的 query() 方法</li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）<br><a name="d21au"></a><h2 id="3-2-match查询"><a href="#3-2-match查询" class="headerlink" title="3.2.match查询"></a>3.2.match查询</h2>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493834-27e3a085-dd03-46db-ac9e-93d5704d262e.png#crop=0&crop=0&crop=1&crop=1&id=YPdY7&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493916-d328ce68-ae46-4d4e-9d3b-9e33f49d94c5.png#crop=0&crop=0&crop=1&crop=1&id=cxC8D&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />而结果解析代码则完全一致，可以抽取并共享。<br />完整代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="SJxZ6"></a><h2 id="3-3-精确查询"><a href="#3-3-精确查询" class="headerlink" title="3.3.精确查询"></a>3.3.精确查询</h2>精确查询主要是两者：</li></ol><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。<br />查询条件构造的API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493997-e01c8096-099d-4628-a5b4-5aac85f61072.png#crop=0&crop=0&crop=1&crop=1&id=NLajm&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="e3ZiE"></a></p><h2 id="3-4-布尔查询"><a href="#3-4-布尔查询" class="headerlink" title="3.4.布尔查询"></a>3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494072-0e6e90bd-140a-4a67-af22-57b4cd008974.png#crop=0&crop=0&crop=1&crop=1&id=X877l&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。<br />完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dcZ6O"></a></p><h2 id="3-5-排序、分页"><a href="#3-5-排序、分页" class="headerlink" title="3.5.排序、分页"></a>3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。<br />对应的API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494155-d6440e41-b65d-49c9-8e0a-b7eccd1dade4.png#crop=0&crop=0&crop=1&crop=1&id=u5LXJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />完整代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="zdHBB"></a></p><h2 id="3-6-高亮"><a href="#3-6-高亮" class="headerlink" title="3.6.高亮"></a>3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li><p>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</p></li><li><p>结果解析：结果除了要解析_source文档数据，还要解析高亮结果<br><a name="h16Js"></a></p><h3 id="3-6-1-高亮请求构建"><a href="#3-6-1-高亮请求构建" class="headerlink" title="3.6.1.高亮请求构建"></a>3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494243-d059b656-6c1c-475e-9cbb-40f244307091.png#crop=0&crop=0&crop=1&crop=1&id=T8Ayb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。<br />完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> HighlightBuilder().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hRaMJ"></a></p><h3 id="3-6-2-高亮结果解析"><a href="#3-6-2-高亮结果解析" class="headerlink" title="3.6.2.高亮结果解析"></a>3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。<br />因此解析高亮的代码需要额外处理：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494319-f91bae56-d104-4696-8278-a418817409f9.png#crop=0&crop=0&crop=1&crop=1&id=Vq85f&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />代码解读：</p></li><li><p>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</p></li><li><p>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</p></li><li><p>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</p></li><li><p>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</p></li><li><p>第五步：用高亮的结果替换HotelDoc中的非高亮结果</p></li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            HighlightField highlightField = highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                String name = highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="kia2F"></a></p><h1 id="4-黑马旅游案例"><a href="#4-黑马旅游案例" class="headerlink" title="4.黑马旅游案例"></a>4.黑马旅游案例</h1><p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。<br />我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8089，就能看到项目页面了：">http://localhost:8089，就能看到项目页面了：</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494418-8049dac5-5565-459e-915b-7d06b0736b31.png#crop=0&crop=0&crop=1&crop=1&id=Cuz36&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="dbIsn"></a></p><h2 id="4-1-酒店搜索和分页"><a href="#4-1-酒店搜索和分页" class="headerlink" title="4.1.酒店搜索和分页"></a>4.1.酒店搜索和分页</h2><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页<br><a name="ABIHk"></a></p><h3 id="4-1-1-需求分析"><a href="#4-1-1-需求分析" class="headerlink" title="4.1.1.需求分析"></a>4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494532-97408c6c-b5ed-4384-ab05-4ea96d0447e2.png#crop=0&crop=0&crop=1&crop=1&id=Y49XZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />点击搜索按钮，可以看到浏览器控制台发出了请求：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494637-c39ce9d6-1997-4438-a3b8-293d1f608d64.png#crop=0&crop=0&crop=1&crop=1&id=jF0KH&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />请求参数如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494736-ccec06bc-96ab-4214-a8ab-d48a1180de79.png#crop=0&crop=0&crop=1&crop=1&id=rlN1v&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：/hotel/list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li><p>步骤一：定义实体类，接收请求参数的JSON对象</p></li><li><p>步骤二：编写controller，接收页面的请求</p></li><li><p>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页<br><a name="oo2u1"></a></p><h3 id="4-1-2-定义实体类"><a href="#4-1-2-定义实体类" class="headerlink" title="4.1.2.定义实体类"></a>4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。<br />1）请求参数<br />前端请求的json结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;搜索关键字&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;sortBy&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）返回值<br />分页查询，需要返回分页结果PageResult，包含两个属性：</p></li><li><p><code>total</code>：总条数</p></li><li><p><code>List&lt;HotelDoc&gt;</code>：当前页的数据</p></li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.hotels = hotels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GA0TO"></a></p><h3 id="4-1-3-定义controller"><a href="#4-1-3-定义controller" class="headerlink" title="4.1.3.定义controller"></a>4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：/hotel/list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Dj6ni"></a></p><h3 id="4-1-4-实现搜索业务"><a href="#4-1-4-实现搜索业务" class="headerlink" title="4.1.4.实现搜索业务"></a>4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。<br />1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PageResult <span class="title">search</span><span class="params">(RequestParams params)</span></span>;</span><br></pre></td></tr></table></figure><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        String key = params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PageResult <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line"><span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageResult(total, hotels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EW3eD"></a></p><h2 id="4-2-酒店结果过滤"><a href="#4-2-酒店结果过滤" class="headerlink" title="4.2.酒店结果过滤"></a>4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能<br><a name="s3UZL"></a></p><h3 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1.需求分析"></a>4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494821-065a9d5d-3814-40a4-84ee-378df2d9ca6f.png#crop=0&crop=0&crop=1&crop=1&id=xUg2b&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />传递的参数如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494902-750c4893-9dee-4647-a535-10ca8908dec0.png#crop=0&crop=0&crop=1&crop=1&id=yC7p2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li><p>修改请求参数的对象RequestParams，接收上述参数</p></li><li><p>修改业务逻辑，在搜索条件之外，添加一些过滤条件<br><a name="sMZ7z"></a></p><h3 id="4-2-2-修改实体类"><a href="#4-2-2-修改实体类" class="headerlink" title="4.2.2.修改实体类"></a>4.2.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pTvoX"></a></p><h3 id="4-2-3-修改搜索业务"><a href="#4-2-3-修改搜索业务" class="headerlink" title="4.2.3.修改搜索业务"></a>4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。<br />在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p></li><li><p>品牌过滤：是keyword类型，用term查询</p></li><li><p>星级过滤：是keyword类型，用term查询</p></li><li><p>价格过滤：是数值类型，用range查询</p></li><li><p>城市过滤：是keyword类型，用term查询</p></li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494985-fec63bb5-e380-4ce8-ae93-f34db02ae6bb.png#crop=0&crop=0&crop=1&crop=1&id=pikbA&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />buildBasicQuery的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fSVGa"></a></p><h2 id="4-3-我周边的酒店"><a href="#4-3-我周边的酒店" class="headerlink" title="4.3.我周边的酒店"></a>4.3.我周边的酒店</h2><p>需求：我附近的酒店<br><a name="keepO"></a></p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495089-1667f471-4fd5-46d7-ac21-b9c3c51603ff.png#crop=0&crop=0&crop=1&crop=1&id=jhCy9&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />并且，在前端会发起查询请求，将你的坐标发送到服务端：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495175-e5ed1d2c-b785-4ace-a50f-1303173615fe.png#crop=0&crop=0&crop=1&crop=1&id=fFSzm&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li><p>修改RequestParams参数，接收location字段</p></li><li><p>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能<br><a name="eEkXX"></a></p><h3 id="4-3-2-修改实体类"><a href="#4-3-2-修改实体类" class="headerlink" title="4.3.2.修改实体类"></a>4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JPXUP"></a></p><h3 id="4-3-3-距离排序API"><a href="#4-3-3-距离排序API" class="headerlink" title="4.3.3.距离排序API"></a>4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p></li><li><p>普通字段排序</p></li><li><p>地理坐标排序</p></li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的java代码示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495264-d2db6fda-f456-4275-9435-dc95ab3ec889.png#crop=0&crop=0&crop=1&crop=1&id=tpjTC&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="oMYAm"></a></p><h3 id="4-3-4-添加距离排序"><a href="#4-3-4-添加距离排序" class="headerlink" title="4.3.4.添加距离排序"></a>4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495351-04ee55b5-584d-4653-9ade-7aded636e019.png#crop=0&crop=0&crop=1&crop=1&id=gG9B2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        String location = params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="keyword">null</span> &amp;&amp; !location.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> GeoPoint(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mmhdD"></a></p><h3 id="4-3-5-排序距离显示"><a href="#4-3-5-排序距离显示" class="headerlink" title="4.3.5.排序距离显示"></a>4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495456-a4576d2e-ba29-4653-9575-a4520495ccec.png#crop=0&crop=0&crop=1&crop=1&id=mAfVx&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？<br />排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495570-0e2f70eb-d95d-45fb-ab5a-f207c210a6d3.png#crop=0&crop=0&crop=1&crop=1&id=dmuFo&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。<br />我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）修改HotelService中的handleResponse方法<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495665-339c3bf2-820e-44cc-8429-09576817cc19.png#crop=0&crop=0&crop=1&crop=1&id=wQX6I&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />重启后测试，发现页面能成功显示距离了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495771-85b34aa7-a6b1-4e70-965e-baec474275da.png#crop=0&crop=0&crop=1&crop=1&id=F5OtP&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="n9lvz"></a></p><h2 id="4-4-酒店竞价排名"><a href="#4-4-酒店竞价排名" class="headerlink" title="4.4.酒店竞价排名"></a>4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶<br><a name="aeE3C"></a></p><h3 id="4-4-1-需求分析"><a href="#4-4-1-需求分析" class="headerlink" title="4.4.1.需求分析"></a>4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495902-04dd3626-b298-48be-927b-2c17a907b27b.png#crop=0&crop=0&crop=1&crop=1&id=T6MMZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />页面会给指定的酒店添加<strong>广告</strong>标记。<br />那怎样才能让指定的酒店排名置顶呢？<br />我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。<br />比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li>给HotelDoc类添加isAD字段，Boolean类型</li><li>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</li><li>修改search方法，添加function score功能，给isAD值为true的酒店增加权重<br><a name="cLG2Z"></a><h3 id="4-4-2-修改HotelDoc实体"><a href="#4-4-2-修改HotelDoc实体" class="headerlink" title="4.4.2.修改HotelDoc实体"></a>4.4.2.修改HotelDoc实体</h3>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218496005-858ef65f-ef79-4c48-a59f-7d418444dd0d.png#crop=0&crop=0&crop=1&crop=1&id=te8i2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="PPZPz"></a><h3 id="4-4-3-添加广告标记"><a href="#4-4-3-添加广告标记" class="headerlink" title="4.4.3.添加广告标记"></a>4.4.3.添加广告标记</h3>接下来，我们挑几个酒店，添加isAD字段，设置为true：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="eLLiF"></a><h3 id="4-4-4-添加算分函数查询"><a href="#4-4-4-添加算分函数查询" class="headerlink" title="4.4.4.添加算分函数查询"></a>4.4.4.添加算分函数查询</h3>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。<br />function_score查询结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492148-edc999a4-3d92-4f9b-a9ff-19da37f00cd0.png#crop=0&crop=0&crop=1&crop=1&id=MsYEG&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />对应的JavaAPI如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218496098-9d63e4f3-de19-4ea0-a6be-1d86722dcebd.png#crop=0&crop=0&crop=1&crop=1&id=qeZny&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。<br />修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    FunctionScoreQueryBuilder functionScoreQuery =</span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123;</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;isAD&quot;</span>, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。&lt;br /&gt;所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用&lt;strong&gt;DSL&lt;/s</summary>
      
    
    
    
    
    <category term="生活杂谈" scheme="http://zephyr-cyber.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
