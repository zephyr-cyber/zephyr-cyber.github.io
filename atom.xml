<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChaunceyZhang&amp;Xia</title>
  
  
  <link href="http://zephyr-cyber.github.io/atom.xml" rel="self"/>
  
  <link href="http://zephyr-cyber.github.io/"/>
  <updated>2022-12-12T08:40:05.446Z</updated>
  <id>http://zephyr-cyber.github.io/</id>
  
  <author>
    <name>ChaunceyZhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html</id>
    <published>2022-12-12T09:43:46.000Z</published>
    <updated>2022-12-12T08:40:05.446Z</updated>
    
    <content type="html"><![CDATA[<p><a name="BB9gb"></a></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a name="XmLxR"></a></p><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><p><a name="yOnLQ"></a></p><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：<br />同步通讯：就像打电话，需要实时响应。<br />异步通讯：就像发邮件，不需要马上回复。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786612-bfe09fbc-30b0-4ba5-910b-97900e8beb5b.png#averageHue=%23578994&crop=0&crop=0&crop=1&crop=1&id=YHjCb&originHeight=605&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<br><a name="jd0te"></a></p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>之前学的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786722-2f92b8d1-d782-4fcb-84d7-9fb639ee530a.png#averageHue=%23faf7f7&crop=0&crop=0&crop=1&crop=1&id=CFRUo&originHeight=678&originWidth=1556&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />总结：<br />同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li><p>耦合度高</p></li><li><p>性能和吞吐能力下降</p></li><li><p>有额外的资源消耗</p></li><li><p>有级联失败问题<br><a name="deD2y"></a></p><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：<br />我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br />在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。<br />订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。<br />为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786818-ba19cdaf-61ca-42b6-a40b-4eb4fd29e8de.png#averageHue=%23e6d6cc&crop=0&crop=0&crop=1&crop=1&id=f2pma&originHeight=134&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。<br />好处：</p></li><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。<br><a name="W2lsn"></a></p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br />比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br />追求可靠性：RabbitMQ、RocketMQ<br />追求吞吐能力：RocketMQ、Kafka<br />追求消息低延迟：RabbitMQ、Kafka<br><a name="v1IoI"></a></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h1><p><a name="bjPW9"></a></p><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786900-d1c5001a-d83f-4982-9a78-1c0961aba74a.png#averageHue=%23fbf9f7&crop=0&crop=0&crop=1&crop=1&id=QLlPG&originHeight=138&originWidth=318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />MQ的基本结构：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786980-394cb4b6-1a99-45ee-850b-ae9b4ba24d42.png#averageHue=%23e8d7b3&crop=0&crop=0&crop=1&crop=1&id=Z7b9M&originHeight=610&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />RabbitMQ中的一些角色：</p><ul><li><p>publisher：生产者</p></li><li><p>consumer：消费者</p></li><li><p>exchange个：交换机，负责消息路由</p></li><li><p>queue：队列，存储消息</p></li><li><p>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离<br><a name="T1HjP"></a></p><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787076-9308a9f3-2e8c-471a-87cd-766ff8f3b446.png#averageHue=%23f8f5f5&crop=0&crop=0&crop=1&crop=1&id=f2Tmk&originHeight=715&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="T4zLf"></a></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787199-2013017b-c013-4ce5-b453-0c0a9e013841.png#averageHue=%23c7ad84&crop=0&crop=0&crop=1&crop=1&id=ldcHW&originHeight=112&originWidth=232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />导入后可以看到结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787276-88d553b3-7a16-4531-af56-641a9f37ad2d.png#averageHue=%23eef3ed&crop=0&crop=0&crop=1&crop=1&id=cV4YR&originHeight=193&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />包括三部分：</p></li><li><p>mq-demo：父工程，管理项目依赖</p></li><li><p>publisher：消息的发送者</p></li><li><p>consumer：消息的消费者<br><a name="Z2HZj"></a></p><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787363-fed4f089-38aa-4236-8c22-9f304e67805b.png#averageHue=%23f6f3eb&crop=0&crop=0&crop=1&crop=1&id=J3t1L&originHeight=215&originWidth=1247&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p></li><li><p>publisher：消息发布者，将消息发送到队列queue</p></li><li><p>queue：消息队列，负责接受并缓存消息</p></li><li><p>consumer：订阅队列，处理队列中的消息<br><a name="n0JyN"></a></p><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p></li><li><p>建立连接</p></li><li><p>创建Channel</p></li><li><p>声明队列</p></li><li><p>发送消息</p></li><li><p>关闭连接和channel</p></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bEghi"></a></p><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="qBU7O"></a></p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定<br><a name="VVz3G"></a><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。<br />SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787451-72dee171-3ecd-46e2-b098-a05b68db0ca6.png#averageHue=%23eeeeee&crop=0&crop=0&crop=1&crop=1&id=DXBQE&originHeight=499&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787527-cb46096b-aab7-4885-beb4-994fb00c84c6.png#averageHue=%23ededed&crop=0&crop=0&crop=1&crop=1&id=hBf4u&originHeight=453&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />SpringAMQP提供了三个功能：</li></ol><ul><li><p>自动声明队列、交换机及其绑定关系</p></li><li><p>基于注解的监听器模式，异步接收消息</p></li><li><p>封装了RabbitTemplate工具，用于发送消息<br><a name="VPYnW"></a></p><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="QttGI"></a></p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lqD7e"></a></p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bi81Z"></a></p><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息<br><a name="y2Ocd"></a></p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787605-9d2eff6e-6a64-413a-9509-7a5377fee1d2.png#averageHue=%23fdfafa&crop=0&crop=0&crop=1&crop=1&id=iSaeo&originHeight=471&originWidth=1253&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br />此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<br><a name="yJv4d"></a></p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br />在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dcex7"></a></p><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。<br><a name="S3N47"></a></p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br />可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。<br />也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br><a name="Rqsrd"></a></p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p><a name="CMhwi"></a></p><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p></li><li><p>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</p></li><li><p>通过设置prefetch来控制消费者预取的消息数量<br><a name="Vjep9"></a></p><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787681-4aeb1677-7204-4ad4-8527-0df956d43573.png#averageHue=%23fcf7f7&crop=0&crop=0&crop=1&crop=1&id=e81wW&originHeight=462&originWidth=1431&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p></li><li><p>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p></li><li><p>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li><p>Consumer：消费者，与以前一样，订阅队列，没有变化</p></li><li><p>Queue：消息队列也与以前一样，接收消息、缓存消息。</p></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br><a name="yGXsj"></a></p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787762-a73eeff1-b2d6-4549-9fb2-5406a6c2eee3.png#averageHue=%23fcf6f6&crop=0&crop=0&crop=1&crop=1&id=uR1Vd&originHeight=431&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787843-757ef8b9-af77-4a7b-9279-be6dd1ba6dc3.png#averageHue=%23faf4f4&crop=0&crop=0&crop=1&crop=1&id=crdxG&originHeight=265&originWidth=1219&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="F3BJ3"></a></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787931-230738f8-6723-4ae1-9111-64e027bca438.png#averageHue=%23ecf3e4&crop=0&crop=0&crop=1&crop=1&id=rQnLa&originHeight=332&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="y22gD"></a></p><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KP2F9"></a></p><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="InRp8"></a></p><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li><p>Queue</p></li><li><p>FanoutExchange</p></li><li><p>Binding<br><a name="XbUES"></a></p><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788019-955e2d17-01d7-45b3-8d6f-62a8313177a4.png#averageHue=%23fcf5f5&crop=0&crop=0&crop=1&crop=1&id=yOiFA&originHeight=494&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在Direct模型下：</p></li><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</p></li><li><p>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</p></li><li><p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</p></li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788106-e7b49dcc-e945-401c-a98d-7481e0a711c1.png#averageHue=%23fbf5f5&crop=0&crop=0&crop=1&crop=1&id=Aj1Pf&originHeight=444&originWidth=1201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="nE7lQ"></a></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br />在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="oy60j"></a></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Zua1L"></a></p><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li><p><a href="/Queue">_@_Queue </a></p></li><li><p><a href="/Exchange">_@_Exchange </a><br><a name="sZ0IL"></a></p><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><p><a name="iWcOC"></a></p><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br /><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br />通配符规则：<br /><code>#</code>：匹配一个或多个词<br /><code>*</code>：匹配不多不少恰好1个词<br />举例：<br /><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code><br /><code>item.*</code>：只能匹配<code>item.spu</code><br />图示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788193-3b31831c-3646-424d-818e-4a8c9ff69f27.png#averageHue=%23f8f0ef&crop=0&crop=0&crop=1&crop=1&id=r1SbP&originHeight=557&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />解释：</p></li><li><p>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</p></li><li><p>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</p></li></ul><p>案例需求：<br />实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788285-52c1019e-b1a5-4f71-bf8f-e2d570632ca1.png#averageHue=%23fbf4f4&crop=0&crop=0&crop=1&crop=1&id=tcuAJ&originHeight=349&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="JqciL"></a></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JDboz"></a></p><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PARTg"></a></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li><p>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</p></li><li><p>Topic交换机与队列绑定时的bindingKey可以指定通配符</p></li><li><p><code>#</code>：代表0个或多个词</p></li><li><p><code>*</code>：代表1个词<br><a name="nEmH2"></a></p><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788362-85cd58d8-6ff7-4b5d-9f87-dfd2505c40e2.png#averageHue=%23d7e8ca&crop=0&crop=0&crop=1&crop=1&id=RW0nO&originHeight=294&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p></li><li><p>数据体积过大</p></li><li><p>有安全漏洞</p></li><li><p>可读性差</p></li></ul><p>我们来测试一下。<br><a name="thtY7"></a></p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务<br />发送消息后查看控制台：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788452-169f9ba6-21ff-4c85-b9e9-c3f7c91c3653.png#averageHue=%23f9f8f7&crop=0&crop=0&crop=1&crop=1&id=ObbD9&originHeight=388&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Aijdb"></a></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。<br />在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。<br />在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;BB9gb&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;XmLxR&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="生活杂谈" scheme="http://zephyr-cyber.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/1243066710.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/1243066710.html</id>
    <published>2022-12-11T14:37:20.308Z</published>
    <updated>2021-07-07T09:44:59.673Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java实现坦克大战练手小游戏</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html</id>
    <published>2020-09-18T13:45:28.000Z</published>
    <updated>2020-09-18T13:59:43.391Z</updated>
    
    <content type="html"><![CDATA[<p>自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单看看源码。</p><blockquote><p><a href="https://github.com/glassy-sky-lisong/TankGame">坦克大战传送门</a></p></blockquote><p>有有个.idea文件夹，上传时不小心上传上去了，大家clone下来删掉即可，这是idea的个人配置文件夹。不过，idea敲java是真香，[手动狗头.jpg]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/tags/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/tags/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Maven一直reading读取pom.xml文件问题</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html</id>
    <published>2020-09-05T15:24:11.000Z</published>
    <updated>2020-09-05T16:59:09.443Z</updated>
    
    <content type="html"><![CDATA[<p>关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉IDEA的桌面任务，然后想通过卸载IDEA来重新建项目，但是没有效果，无奈只能面向百度了，看了一些帖子，据说是网络配置问题，其解决的方案大致这有几种：</p><ol><li>修改HOST文件的 127.0.0.1为localhost，在终端输入 *** netsh winsock reset*** 我的HOST的确是在安装navicat时候改过，然后就修改重启后也没有效果</li><li>添加本地maven到环境变量，这个有效，不过是在降低springboot版本之后添加的</li><li>降低springboot版本，默认是2.3.3，降低到2.2.*</li><li>在IDEA的Help菜单下的showlogExpore，查看运行日志，检查问题，我看了一遍，并没有明显的错误</li></ol><p>折腾了挺长时间，现在分享给大家，帮助大家在遇到此类问题的小伙伴能尽快解决，以免耽误工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉ID</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/Maven/"/>
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/tags/Java/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/tags/Maven/"/>
    
    <category term="SpringBoot" scheme="http://zephyr-cyber.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型之上、下边界通配符的理解(适合初学)</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html</id>
    <published>2020-09-02T11:15:25.000Z</published>
    <updated>2020-09-02T11:26:05.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的由来"><a href="#泛型的由来" class="headerlink" title="泛型的由来"></a>泛型的由来</h2><h3 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h3><p>&emsp;&emsp;Java的数据类型一般都是在定义时就需要确定，这种强制的好处就是类型安全，不会出现像弄一个ClassCastException的数据给jvm，数据安全那么执行的class就会很稳定。但是假如说我不知道这个参数要传什么类型的，因为公司需求在变，如果写死的那就只能便以此需求就改一次，很麻烦。sun公司也注意到这个问题，这样会让代码的灵活性降低，他们就研究出了泛型。</p><h3 id="泛型初识"><a href="#泛型初识" class="headerlink" title="泛型初识"></a>泛型初识</h3><p>&emsp;&emsp;什么是泛型，可以字面理解就是一个泛泛的类型，他是不确定的，在Java代码编译的时候用泛型是不会出错的，而在运行期时就会报错，说你这种第一是不合理的。这是为什么呢。因为为了提高灵活性，就在编译时期将条件放宽，但是泛型一定要在运行的时候告诉jvm你给我的数据到底是什么类型的，否则jvm会是懵逼的。所以泛型的好处就是将类型的灵活性提高，也只是在Java语法的基础上提高，不过泛型还是比较实用的。</p><h3 id="何时使用泛型"><a href="#何时使用泛型" class="headerlink" title="何时使用泛型"></a>何时使用泛型</h3><p>&emsp;&emsp;泛型的应用场景就是应用在模型（可以理解为存储数据的盒子），我为了这个盒子适用更多的地方我就用将需要存入的数据用一个泛型表示，当然可以传入多值。如果是相同类型的对象就用一个泛型的数组比较好，学过集合的小伙伴应该都知道，没学过的那你应该补补课了。</p><p><em><strong>泛型的语法</strong></em></p><pre><code>public class A&lt;T extends B&gt;&#123;   T t;&#125;</code></pre><h2 id="泛型的缺点或者为什么需要上、下边界"><a href="#泛型的缺点或者为什么需要上、下边界" class="headerlink" title="泛型的缺点或者为什么需要上、下边界"></a>泛型的缺点或者为什么需要上、下边界</h2><p>&emsp;&emsp;泛型的虽然强大，但是世界上任何东西东部是完美的。它也有缺陷。比如说我有一个盒子我想装苹果，但是我还可能想装香蕉那怎么办。那还不好说，在给一个参数不就行了，那十个呢，二十个呢。em….的确是。如果说我们想装的东西都属于一个类并且只要是这个类的子类就可以装。这个想法sun为我们想好了。那就是用上边界通配符。语法是<T entends M> T是泛型，M是T的父类。我们就定义一个水果类（Fruit），盛装就容器就是盘子（Dish），现在我们就可以装任何水果了，不错吧！</p><p><em><strong>上边界Java代码</strong></em></p><pre><code>public class Dish&lt;T extends Fruit&gt;&#123;  private T fruitChild;  public Dish(T fruitChild)&#123;    this.fruitChild = fruitChild;  &#125;  public T getFruitChild()&#123;    return fruitChild;  &#125;    public void setFruitChild(T f)&#123;    this.fruitChild = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;apple&gt;();    Apple apple = new apple(); //apple must be Fruit child;    dish.setFruitChild(apple);    system.out.printf(dish.getFruitChild);  &#125;&#125;</code></pre><p><em><strong>下边界Java代码</strong></em></p><pre><code>public class Dish&lt;T super Apple&gt;&#123;  private T appleFather;  public Dish(T appleFather)&#123;    this.appleFather = appleFather;  &#125;  public T getAppleFather()&#123;    return appleFather;  &#125;  public void setAppleFather(T f)&#123;    this.appleFather = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;Fruit&gt;();    Fruit fruit = new Fruit(); //fruit must be apple son;    dish.setAppleFather(fruit);    system.out.printf(dish.getAppleFather);  &#125;&#125;</code></pre><h2 id="什么是上边界通配符"><a href="#什么是上边界通配符" class="headerlink" title="什么是上边界通配符"></a>什么是上边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T extends A> 的A类型到A类型任何子类的限制域，可以匹配任何在此限制域中的类型，此种表示叫上边界通配符。<br>###上边界通配符理解<br><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png" alt="png"></p><h2 id="什么是下边界通配符"><a href="#什么是下边界通配符" class="headerlink" title="什么是下边界通配符"></a>什么是下边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T super A> 的A类型到A类型任何父类的限制域，可以匹配任何在此限制域中的类型，此种表示叫下边界通配符。</p><h3 id="下边界通配符理解"><a href="#下边界通配符理解" class="headerlink" title="下边界通配符理解"></a>下边界通配符理解</h3><p><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png" alt="png"></p><h2 id="上下边界通配符的缺点"><a href="#上下边界通配符的缺点" class="headerlink" title="上下边界通配符的缺点"></a>上下边界通配符的缺点</h2><p>&emsp;&emsp;上界&lt;? extends T&gt;不能往里存，只能往外取。<br>###解释<br>&emsp;&emsp;因为编译器只知道传入的是T的子类，但具体是哪一个编译器不知道，他只标注了一个占位符，当？传过来时，他不知道这能不能和占位符匹配，所以set不了。<br>&emsp;&emsp;下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>&emsp;&emsp;因为下边界已经限制了？的粒度，他只可能是T本身或者是T的父类。我们想想，我想要一个T，你却返回给我一个比T小的Object，这样我们就因为精度损失而拿不到想要的数据了。</p><blockquote><p>感谢各位童鞋的阅读，希望大家动一动发财的小手点一下推荐QAQ。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的由来&quot;&gt;&lt;a href=&quot;#泛型的由来&quot; class=&quot;headerlink&quot; title=&quot;泛型的由来&quot;&gt;&lt;/a&gt;泛型的由来&lt;/h2&gt;&lt;h3 id=&quot;为什么需要泛型&quot;&gt;&lt;a href=&quot;#为什么需要泛型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
    <category term="博客园" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>超实用的SQL语句之嵌套查询</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/f3908263.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/f3908263.html</id>
    <published>2020-08-31T11:40:33.000Z</published>
    <updated>2020-08-31T12:09:04.784Z</updated>
    
    <content type="html"><![CDATA[<h2>嵌套查询</h2><h3>什么是嵌套查询</h3>. 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。<h3>嵌套查询的工作方式</h3> 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。<h2>子查询的组成</h2> 1、包含标准选择列表组件的标准select查询。<p> 2、包含一个或多个表或者视图名称的标准from子句。</p><p> 3、可选的where子句。</p><p> 4、可选的group by子句。</p><p> 5、可选的having子句。</p><h2>子查询的语法规则</h2> 1、子查询的select查询总是使用圆括号括起来。<p> 2、不能包括compute或for.browse子句。</p><p> 3、如果同时指定top子句，则可能只包括order by子句。</p><p> 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。</p><p> 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。</p><p> 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。</p><h2>简单子查询</h2><strong>示例：</strong>    <pre><code>select name,age from person where age &gt;     (        select age from person         where name = &#39;孙权&#39;    )</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg" alt="1"></p><h2>in嵌套查询</h2> 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。<p><strong>示例：</strong></p><pre><code>select name from person where countryid in (select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong></p><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg" alt="2"><h2>some嵌套查询</h2><h3>语法</h3> 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：<pre><code>&lt;表达式&gt;&#123; =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;&#125;some(子查询)</code></pre><p><strong>示例：</strong></p><pre><code>select name from person where countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回(select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg" alt="3"></p><h2>all嵌套查询</h2> 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。<h3>语法</h3><pre><code>&lt;表达式&gt;&#123; =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;&#125;all(子查询)</code></pre><p><strong>示例：</strong></p><pre><code>select name from person where countryid &gt; all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回(select countryid from countrywhere countryname = &#39;魏国&#39;)</code></pre><p><strong>输出结果为：</strong><br><img src="https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg" alt="4"></p><h2>exists嵌套查询</h2><h3>语法</h3> 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style="color:red">一旦找到第一个匹配的记录后，就马上停止查找。</span><pre><code>exists　子查询</code></pre><p> 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。<br>exists 的意思是，子查询是否有结果集返回。<br><strong>例如：</strong></p><pre><code>SELECT * FROM PersonWHERE exists(SELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行)</code></pre><p> 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：</p><pre><code>SELECT * FROM PersonWHERE exists(SELECT * FROM Person WHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行)</code></pre><p>最后感谢<a href="https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html">不玩博客了！</a>同学的分享，么么哒！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;嵌套查询&lt;/h2&gt;
&lt;h3&gt;什么是嵌套查询&lt;/h3&gt;.
 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。
&lt;h3&gt;嵌</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="mybatis" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/mybatis/"/>
    
    
    <category term="MySQL" scheme="http://zephyr-cyber.github.io/tags/MySQL/"/>
    
    <category term="MyBatis" scheme="http://zephyr-cyber.github.io/tags/MyBatis/"/>
    
    <category term="SQL技巧" scheme="http://zephyr-cyber.github.io/tags/SQL%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>博客美化——Silence主题皮肤</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/3ba53770.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/3ba53770.html</id>
    <published>2020-08-30T12:08:31.000Z</published>
    <updated>2020-08-30T12:25:02.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。</p><ul><li><a href="https://github.com/glassy-sky-lisong/SilenceSkin">博客皮肤源码地址</a></li><li><a href="https://www.cnblogs.com/esofar">预览地址</a></li><li><a href="https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md">如何部署、使用皮肤</a></li><li><a href="https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html">Silence作者的友链</a></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>简洁优雅、精致漂亮的 UI 设计</li><li>提供多种风格主题以便适应各类用户的偏好</li><li>响应式设计，兼容手机端浏览器</li><li>提供事无巨细的部署文档</li><li>源码结构清晰并且注释完整，方便扩展</li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。</p><pre><code> git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码 cd cnblogs-theme-silence                                        # 进入项目 npm install                                                     # 安装依赖 npm run build</code></pre><p>&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见’如何部署、使用皮肤’，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）<br><em><strong>CSS</strong></em></p><pre><code>&lt;!-- 溢出隐藏设置（放置在管理--&gt; 设置--&gt; css模块中） --&gt;#topics, #mainContent &#123;    overflow: visible;&#125;.cnblogs-markdown .hljs&#123;    display:block;    color:#333;    overflow-x:auto;    background:#F2F4F5!important;    border:none!important;    font-family:Consolas,Monaco,&#39;Andale Mono&#39;,&#39;Ubuntu Mono&#39;,monospace!important;    padding:1em!important;    font-size:14px!important    &#125;</code></pre><p><em><strong>侧边栏公告</strong></em></p><pre><code>&lt;!-- 在管理--&gt; 设置-&gt; 侧边栏公告(支持js代码、支持html代码) --&gt;&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/silence.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $.silence(&#123;        profile: &#123;            enable: true,            avatar: &#39;https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&#39;,            favicon: &#39;https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&#39;,        &#125;,        catalog: &#123;            enable: true,            move: true,            index: true,            level1: &#39;h2&#39;,            level2: &#39;h3&#39;,            level3: &#39;h4&#39;,        &#125;,        signature: &#123;            enable: true,            home: &#39;https://www.cnblogs.com/glassysky/&#39;,            license: &#39;署名 4.0 国际&#39;,            link: &#39;https://creativecommons.org/licenses/by/4.0&#39;        &#125;,        reward: &#123;            enable: true,            title: &#39;感谢小可爱投食&#39;,            wechat: &#39;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png&#39;,            alipay: &#39;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png&#39;        &#125;,        github: &#123;            enable: true,            color: &#39;#fff&#39;,            fill: null,            link: &#39;https://github.com/glassy-sky-lisong&#39;        &#125;    &#125;);&lt;/script&gt;&lt;!--外置主题css补丁--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/sli.css&quot;/&gt;</code></pre><p><em><strong>会动的title</strong></em></p><pre><code>&lt;!-- 动态titlejs --&gt;&lt;script&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&#39;visibilitychange&#39;, function () &#123; if                 (document.hidden) &#123; document.title = &#39;╭(°A°`)╮ 页面崩溃啦 ~&#39;; clearTimeout(titleTime); &#125; else &#123; document.title = &#39;(ฅ&gt;ω&lt;*ฅ) 噫又    好了~&#39; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); &lt;/script&gt;</code></pre><p><em><strong>图片放大功能</strong></em></p><pre><code>&lt;!--图片放大的zoomcss和js--&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.css&quot;/&gt;&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.js&quot;&gt;&lt;/script&gt;&lt;!-- Bootstrap 的 transition.js cdn（过渡动画插件）--&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(&#39;#cnblogs_post_body img&#39;).attr(&#39;data-action&#39;, &#39;zoom&#39;);&lt;/script&gt;</code></pre><h2 id="博客的皮肤风格"><a href="#博客的皮肤风格" class="headerlink" title="博客的皮肤风格"></a>博客的皮肤风格</h2><ul><li>简约·蓝<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png" alt="img1"> </li><li>暗黑·绿<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png" alt="img2"></li><li>女神·粉<br><img src="https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png" alt="img3">  </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
    <category term="博客园" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>测试分类</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/a1da6445.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/a1da6445.html</id>
    <published>2020-08-25T04:50:00.000Z</published>
    <updated>2020-08-30T11:35:10.466Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个测试</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="Hexo" scheme="http://zephyr-cyber.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://zephyr-cyber.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>你好</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/50a2b841.html</id>
    <published>2020-07-22T09:43:46.000Z</published>
    <updated>2022-12-12T08:40:51.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文本文字"><a href="#文本文字" class="headerlink" title="文本文字"></a>文本文字</h2><span class='p red'>红色</span><span class='p yellow'>黄色</span><span class='p blue'>蓝色</span><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><h2 id="外挂标签"><a href="#外挂标签" class="headerlink" title="外挂标签"></a>外挂标签</h2><div class="note red"><p>为简单的一句话提供的简便写法。</p></div><div class="note quote"><p>为简单的一句话提供的简便写法。</p></div><div class="note info"><p>为简单的一句话提供的简便写法。</p></div><div class="note warning"><p>为简单的一句话提供的简便写法。</p></div><div class="note done"><p>为简单的一句话提供的简便写法。</p></div><div class="note success"><p>为简单的一句话提供的简便写法</p></div> <div class="note danger"><p>为简单的一句话提供的简便写法</p></div><div class="note error"><p>为简单的一句话提供的简便写法。</p></div><h2 id="灰色标签"><a href="#灰色标签" class="headerlink" title="灰色标签"></a>灰色标签</h2><div class="note radiation"><p>为简单的一句话提供的简便写法</p></div><div class="note bug"><p>为简单的一句话提供的简便写法</p></div> <div class="note idea"><p>为简单的一句话提供的简便写法。</p></div><div class="note link"><p>为简单的一句话提供的简便写法</p></div><div class="note paperclip"><p>为简单的一句话提供的简便写法。</p></div><div class="note todo"><p>为简单的一句话提供的简便写法。</p></div> <div class="note msg"><p>为简单的一句话提供的简便写法。</p></div> <div class="note guide"><p>为简单的一句话提供的简便写法。</p></div><div class="note download"><p>为简单的一句话提供的简便写法。</p></div><div class="note up"><p>为简单的一句话提供的简便写法。</p></div><div class="note undo"><p>为简单的一句话提供的简便写法。</p></div> <h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h2><div class="note quote">            <p>Windows 10不是為所有人設計,而是為每個人設計</p><p class='p subtitle'>嵌套测试</p><div class="note ">          <p>请坐和放宽，我正在帮你搞定一切…  </p>        </div><p class='p subtitle'>Folding 测试</p><details ><summary> <p>点击查看更多</p> </summary>            <div class='content'>            <div class="note warning"><p>不要说我们没有警告过你</p></div><div class="note bug red">        <p>我们都有不顺利的时候    </p>      </div>              </div>          </details>          </div><h2 id="上标式标签"><a href="#上标式标签" class="headerlink" title="上标式标签"></a>上标式标签</h2><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 markdown 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><h1 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h1><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 markdown 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><p>This is my website, click the button <a class="btn-beautify button--animated " href="http://www.jerryc.me"   title="JerryC"><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated " href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="http://www.jerryc.me"   title="JerryC"><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a></p><a class="btn-beautify button--animated block" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated block center larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated block right outline larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated blue larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated pink larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated red larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated purple larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated orange larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated green larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><div class="btn-center"><a class="btn-beautify button--animated outline larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline blue larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline pink larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline red larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline purple larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline orange larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><a class="btn-beautify button--animated outline green larger" href="http://www.jerryc.me"   title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a></div><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: bg;color: color">display  </button><span class="hide-content">content</span></span><div class="hide-block"><button type="button" class="hide-button button--animated" style="background-color: bg;color: color">display    </button><div class="hide-content"><p>content</p></div></div><div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-id-1">标签名</button></li><li class="tab"><button type="button" data-href="#tab-id-2">标签名</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-id-1"><p><img src="https://i.loli.net/2020/03/18/f5PQlWisvm9zbgK.jpg"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-id-2"><p>这里面写内容，支持的语法格式有限，请尽量<u>不要</u>写太过复杂的东西。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><details ><summary> <p>查看图片测试</p> </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"></p>              </div>            </details><details cyan open><summary> <p>查看默认打开的折叠框</p> </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details green><summary> <p>查看代码测试</p> </summary>              <div class='content'>                            </div>            </details><details yellow><summary> <p>查看列表测试</p> </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details red><summary> <p>查看嵌套测试</p> </summary>              <div class='content'>              <details blue><summary> <p>查看嵌套测试2</p> </summary>              <div class='content'>              <details ><summary> <p>查看嵌套测试3</p> </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><div class="audio"><audio controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/xaoxuu/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><p>$$E(A)=\sum_{j=1}^v \frac {s_{1j}+s_{2j}+….s_{mj}} sI(s_{1j}+s_{2j}+….s_{mj})$$<br>$$I(s_{1j}+s_{2j}+….s_{mj})=-\sum_{i=1}^mp_{ij}log(p_{ij})\p_{ij}=\frac {s_{ij}} {|s_j|}$$</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><div class="tip success"><p>helloworld</p>          </div><hr><div class="tip wtgo"><p>为简单的一句话提供的简便写法。</p></div><div class="tip ban"><p>为简单的一句话提供的简便写法。</p></div><div class="tip home"><p>为简单的一句话提供的简便写法。</p></div><div class="tip important"><p>为简单的一句话提供的简便写法。</p></div><div class="tip ref"><p>为简单的一句话提供的简便写法。</p><p></p></div><div class="tip ffa"><p>为简单的一句话提供的简便写法。</p><p></p></div><div class="tip key"><p>为简单的一句话提供的简便写法。</p><p></p></div><div class="tip socd"><p>为简单的一句话提供的简便写法。</p><p></p></div>***<div class="tip success faa-wrench animated"><p>摇摆</p>          </div><div class="tip success faa-horizontal animated"><p>垂直抖动</p>          </div><div class="tip success faa-flash animated"><p>若隐若现</p>          </div><div class="tip success faa-pulse animated"><p>变色</p>          </div><div class="tip success faa-shake animated"><p>摇摆</p>          </div><h2 id="beautiful-btns"><a href="#beautiful-btns" class="headerlink" title="beautiful btns"></a>beautiful btns</h2><div class="btns circle grid5">            <a href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div><div class="btns rounded grid5">            <a href='/' title='下载源码'><i class='fa fa-download'></i>下载源码</a><a href='/' title='查看文档'><i class='fa fa-download'></i>查看文档</a>          </div><div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class="fas fa-apple"></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class="fas fa-apple"></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><h2 id="metingjs"><a href="#metingjs" class="headerlink" title="metingjs"></a>metingjs</h2>    <div id="aplayer-UcRqkYfa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="621465725" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86" data-listfolded="true" data-fixed="true" data-mini="true"    ></div><p>如左下角所示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文本文字&quot;&gt;&lt;a href=&quot;#文本文字&quot; class=&quot;headerlink&quot; title=&quot;文本文字&quot;&gt;&lt;/a&gt;文本文字&lt;/h2&gt;&lt;span class=&#39;p red&#39;&gt;红色&lt;/span&gt;
&lt;span class=&#39;p yellow&#39;&gt;黄色&lt;/span&gt;
&lt;s</summary>
      
    
    
    
    
    <category term="生活杂谈" scheme="http://zephyr-cyber.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
